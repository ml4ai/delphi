<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grounded Function Network (GrFN) Documentation &mdash; delphi  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="&lt;no title&gt;" href="delphi_database.html" />
    <link rel="prev" title="delphi.GrFN.networks.ForwardInfluenceBlanket.run" href="generated/delphi.GrFN.networks.ForwardInfluenceBlanket.run.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> delphi
            <img src="_static/delphi_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Delphi config file</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Grounded Function Network (GrFN) Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">[0.2.8]</span></code> - 2019-09-01</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#changes">Changes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grfn-spec-index">grfn_spec Index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#background-from-source-code-to-dynamic-system-representation">Background: From source code to dynamic system representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spec-notation-conventions">Spec Notation Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#preamble">Preamble</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifier">Identifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grounding-and-source-code-reference">Grounding and source code reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#base-name">Base Name</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scope-and-namespace-paths">Scope and Namespace Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="#path-strings">Path Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifier-string">Identifier String</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifier-gensym">Identifier Gensym</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grounding-metadata-spec">Grounding Metadata spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifier-specification">Identifier Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-naming-convention">Variable Naming Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-reference">Variable Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-naming-convention">Function Naming Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-value-domain">Variable Value Domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-spec-examples">&lt;variable_spec&gt; examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-assign-specification">Function Assign Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-assign-body-literal">Function assign body Literal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-assign-body-lambda">Function assign body Lambda</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function-container-specification">Function Container Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-reference-specification">Function Reference Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-loop-plate-specification">Function Loop Plate Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#change-log">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#added">Added</a></li>
<li class="toctree-l2"><a class="reference internal" href="#changed">Changed</a></li>
<li class="toctree-l2"><a class="reference internal" href="#added-1">Added</a></li>
<li class="toctree-l2"><a class="reference internal" href="#changed-1">Changed</a></li>
<li class="toctree-l2"><a class="reference internal" href="#removed">Removed</a></li>
<li class="toctree-l2"><a class="reference internal" href="#added-2">Added</a></li>
<li class="toctree-l2"><a class="reference internal" href="#changed-2">Changed</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="grfn_openapi.html">GrFN OpenAPI Specification</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">delphi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Grounded Function Network (GrFN) Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/grfn_spec.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="grounded-function-network-grfn-documentation">
<h1>Grounded Function Network (GrFN) Documentation<a class="headerlink" href="#grounded-function-network-grfn-documentation" title="Permalink to this headline"></a></h1>
<p><strong>Version 0.2.8</strong></p>
<section id="id1">
<h2><code class="docutils literal notranslate"><span class="pre">[0.2.8]</span></code> - 2019-09-01<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<p>Changes since [0.1.m9]</p>
<section id="changes">
<h3>Changes<a class="headerlink" href="#changes" title="Permalink to this headline"></a></h3>
<ul class="simple">
<li><p>Major refactoring of GrFN Spec into</p>
<ol class="arabic simple">
<li><p>OpenAPI</p></li>
<li><p>GrFN documentation (this document)</p></li>
</ol>
</li>
<li><p>Change GrFN specification versioning from <code class="docutils literal notranslate"><span class="pre">#.#.m#</span></code> to <code class="docutils literal notranslate"><span class="pre">#.#.#</span></code></p>
<ul>
<li><p>Previous release was <code class="docutils literal notranslate"><span class="pre">[0.1.m9]</span></code></p></li>
<li><p>Advancing minor version to 2 with refactoring to OpenAPI</p></li>
</ul>
</li>
</ul>
<p><a class="reference external" href="#change-og">Change Log</a> (from previous releases)</p>
<section id="grfn-spec-index">
<h4>grfn_spec Index<a class="headerlink" href="#grfn-spec-index" title="Permalink to this headline"></a></h4>
<p>Example whole system GrFN specification file structure</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace1</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace1_lambdas</span><span class="o">.</span><span class="n">py</span>
<span class="n">namespace2</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace2_lambdas</span><span class="o">.</span><span class="n">py</span>
<span class="o">...</span>
</pre></div>
</div>
<p>NOTE: <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ and
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__ are both formatted
as <code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__, but with particular
<a class="reference external" href="#variable-and-function-identifiers-and-references">naming
conventions</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;system_def&gt;</span></code> ::= # serves as an index; has to be a DAG</p>
<ul>
<li><p>“date_created” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # name of system; optional?</p></li>
<li><p>“components” : list of <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec_refs&gt;</span></code>[attrval] ::=</p>
<ul>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__</p></li>
<li><p>“imports” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__ # specifies
which grfn_spec files to load</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;grfn_spec&gt;</span></code> &lt;#top-level-grfn-specification&gt;`__[attrval] ::=</p>
<ul>
<li><p>“date_created” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“namespace” : <code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__ #
‘current’ namespace; grfn_spec filename will be the same</p></li>
<li><p>“imports” : list of <code class="docutils literal notranslate"><span class="pre">&lt;import_identifier_spec&gt;</span></code>[attrval] ::=</p>
<ul>
<li><p>“source_identifier” :
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__</p></li>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # the name as used locally in this
grfn_spec</p></li>
</ul>
</li>
<li><p>“source” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;source_code_file_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__</p></li>
<li><p>“start”: list of <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # ‘top-level’ function(s)</p></li>
<li><p>“identifiers” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_spec&gt;</span></code> &lt;#identifier-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“base_name” : <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__</p></li>
<li><p>“scope” : <code class="docutils literal notranslate"><span class="pre">`&lt;scope_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__</p></li>
<li><p>“namespace” :
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__</p></li>
<li><p>“source_references” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;source_code_reference&gt;</span></code> &lt;#grounding-and-source-code-reference&gt;`__</p></li>
<li><p>“gensym” : <code class="docutils literal notranslate"><span class="pre">`&lt;gensym&gt;</span></code> &lt;#identifier-gensym&gt;`__</p></li>
<li><p>“grounding” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;grounding_metadata_spec&gt;</span></code> &lt;#grounding-metadata-spec&gt;`__[attrval]
::=</p>
<ul>
<li><p>“source” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # URI to source document</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;definition&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;units&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;constraint&quot;</span></code></p></li>
<li><p>“value” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“score” : <code class="docutils literal notranslate"><span class="pre">&lt;real&gt;</span></code> # confidence score of grounding</p></li>
</ul>
</li>
</ul>
</li>
<li><p>“variables” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__[attrval] ::=</p>
<ul>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
<li><p>“domain” :
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_domain_type&gt;</span></code> &lt;#variable-value-domain&gt;`__[attrval]
::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;integer&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;boolean&quot;</span></code> |
<code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code></p></li>
<li><p>“precision” : TODO</p></li>
</ul>
</li>
<li><p>“domain_constraints” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # a disjunctive normal
form, with v := variable value</p>
<ul>
<li><p>e.g.,
<code class="docutils literal notranslate"><span class="pre">&quot;(or</span> <span class="pre">(and</span> <span class="pre">(&lt;</span> <span class="pre">v</span> <span class="pre">infty)</span> <span class="pre">(&gt;=</span> <span class="pre">v</span> <span class="pre">5)</span> <span class="pre">(and</span> <span class="pre">(&gt;</span> <span class="pre">v</span> <span class="pre">-infty)</span> <span class="pre">(&lt;</span> <span class="pre">v</span> <span class="pre">0)))&quot;</span></code></p></li>
<li><p>Could this more generally reference other variables?</p></li>
</ul>
</li>
<li><p>“mutable” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
</ul>
</li>
<li><p>“functions” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;function_spec&gt;</span></code> &lt;#function-specification&gt;`__ … instances of
the following:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_spec&gt;</span></code> &lt;#function-assign-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“name” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;assign&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;condition&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;decision&quot;</span></code></p></li>
<li><p>“arguments” : list of [
<code class="docutils literal notranslate"><span class="pre">`&lt;function_source_reference&gt;</span></code> &lt;#function-assign-specification&gt;`__
| <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ ]</p></li>
<li><p>“return_value” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_source_reference&gt;</span></code> &lt;#function-assign-specification&gt;`__
| <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
<li><p>“body” : one of the following:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_body_literal_spec&gt;</span></code> &lt;#function-assign-body-literal&gt;`__[attrval]
::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;literal&quot;</span></code></p></li>
<li><p>“value” :
<code class="docutils literal notranslate"><span class="pre">`&lt;literal_value&gt;</span></code> &lt;#function-assign-body-literal&gt;`__[attrval]
::=</p>
<ul>
<li><p>“dtype” : <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;integer&quot;</span></code> |
<code class="docutils literal notranslate"><span class="pre">&quot;boolean&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code></p></li>
<li><p>“value” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_body_lambda_spec&gt;</span></code> &lt;#function_assign_body_lambda&gt;`__[attrval]
::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;lambda&quot;</span></code></p></li>
<li><p>“name” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__</p></li>
<li><p>“reference” :
<code class="docutils literal notranslate"><span class="pre">`&lt;lambda_function_reference&gt;</span></code> &lt;#funciton-assign-body-lambda&gt;`__
::= a <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> denoting the python function in
<code class="docutils literal notranslate"><span class="pre">lambdas.py</span></code></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_container_spec&gt;</span></code> &lt;#function-container-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“name” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;container&quot;</span></code></p></li>
<li><p>“arguments” : list of [
<code class="docutils literal notranslate"><span class="pre">`&lt;function_source_reference&gt;</span></code> &lt;#function-assign-specification&gt;`__
| <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ ]</p></li>
<li><p>“updated” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ #
variables side-effected during execution</p></li>
<li><p>“return_value” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_source_reference&gt;</span></code> &lt;#function-assign-specification&gt;`__
| <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
<li><p>“body” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_loop_plate_spec&gt;</span></code> &lt;#function-loop-plate-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“name” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;loop_plate&quot;</span></code></p></li>
<li><p>“arguments” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
<li><p>“updated” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ #
variables side-effected during execution</p></li>
<li><p>“test_at_end” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
<li><p>“exit_condition” : <code class="docutils literal notranslate"><span class="pre">&lt;loop_condition&gt;</span></code> ::= # continue loop
WHILE predicate evaluates to “output_literal”</p>
<ul>
<li><p>“arguments” : list of [
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_reference&gt;</span></code> &lt;#variable-reference&gt;`__ |
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ ]</p></li>
<li><p>“return_value” :
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ #
the named variable of the exit_condition result</p></li>
<li><p>“output_literal” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
<li><p>“predicate” :
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__ #
reference to lambda fn computing the condition (which
must match the output_literal in order to exit)</p></li>
</ul>
</li>
<li><p>“body” : list of
<code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“function” : <code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__</p></li>
<li><p>“arguments” : list of [
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_reference&gt;</span></code> &lt;#variable-reference&gt;`__ |
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ ]</p></li>
<li><p>“return_value” :
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_reference&gt;</span></code> &lt;#variable-reference&gt;`__ |
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;function_source_reference&gt;</span></code> &lt;#function-assign-specification&gt;`__[attrval]
::=</p>
<ul>
<li><p>“name” : [ <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__
| <code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__ ]</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;variable&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;variable_reference&gt;</span></code> &lt;#variable-reference&gt;`__[attrval] ::=</p>
<ul>
<li><p>“variable” : <code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__</p></li>
<li><p>“index” : <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h4>
</section>
</section>
</section>
<section id="background-from-source-code-to-dynamic-system-representation">
<h2>Background: From source code to dynamic system representation<a class="headerlink" href="#background-from-source-code-to-dynamic-system-representation" title="Permalink to this headline"></a></h2>
<p>GrFN, pronounced “Griffin”, is the central representation generated and
manipulated by the <a class="reference external" href="https://ml4ai.github.io/automates/">AutoMATES</a>
system (incorporating <a class="reference external" href="https://ml4ai.github.io/delphi">Delphi</a>).</p>
<p>The goal of GrFN is to provide the end-point target for a translation
from the semantics of program (computation) specification (as asserted
in source code) and scientific domain concepts (as expressed in text and
equations) to the semantics of a (discretized) dynamic system model
(akin to an extended version of a probabilistic graphical model).</p>
<p>A key assumption is that the program source code we are analyzing is
intended to model aspects of some target physical domain, and that this
target physical domain is a dynamical system that evolves over time.
This means that some source code variables are assumed to correspond to
dynamical system states of the represented system.</p>
<p>The system is decomposed into a set of individual states (represented as
(random) variables), where the values of the states at any given time
are a function of the values of zero or more other states at the current
and/or previous time point(s). Because we are considering the evolution
of the system over time, in general every variable has an index. The
functional relationships may be instantaneous (based on the variables
indexed at the same point in time) or a function of states of variables
at different time indices.</p>
<p>There are four components in AutoMATES that generate (contribute to)
and/or consume (operate on) GrFN:</p>
<ul class="simple">
<li><p>Program Analysis (PA) - generates</p></li>
<li><p>Text Reading (TR) - generates</p></li>
<li><p>Equation Reading (ER) - generates</p></li>
<li><p>Model Analysis (MA) - consumes</p></li>
</ul>
<p>GrFN integrates the extracted <em>Function Network</em> representation of
source code (the result of Program Analysis) along with associated
extracted comments, links to natural language text (the result of
natural language processing by Text Reading), and links to and
representation of equations (the result of equation extraction by
Equation Reading).</p>
</section>
<section id="spec-notation-conventions">
<h2>Spec Notation Conventions<a class="headerlink" href="#spec-notation-conventions" title="Permalink to this headline"></a></h2>
<p>This specification (spec) document describes the GrFN JSON schema,
specifying the JSON format that is to be generated by Program Analysis,
Text Reading and Equation Reading. Model Analysis is the current main
consumer; we also hope that other scientific model analysis systems
(e.g., from the ASKE Program) will also be consumers and/or generators.</p>
<p>In this document we adopt a simplified <a class="reference external" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur Form
(BNF)</a>-inspired
grammar specification convention combined with a convention for
intuitively defining JSON attribute-value lists. The schema definitions
and instance GrFN examples are rendered in <code class="docutils literal notranslate"><span class="pre">monospaced</span> <span class="pre">font</span></code>, and
interspersed with comments/discussion.</p>
<p>Following BNF convention, elements in <code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code> denote nonterminals,
with <code class="docutils literal notranslate"><span class="pre">::=</span></code> indicating a definition of how a nonterminal is expanded.
We will use some common nonterminals with standard expected
interpretations, such as <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> for strings, <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> for
integers, etc. Many of the definitions below will specify JSON
attribute-value lists; when this is the case, we will decorate the
nonterminal element definition by adding <code class="docutils literal notranslate"><span class="pre">[attrval]</span></code>, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">::</span>
</pre></div>
</div>
<blockquote>
<div><p>&lt;element_name&gt;[attrval] ::=</p>
</div></blockquote>
<p>We will then specify the structure of the JSON attribute-value list
attributes (quoted strings) and their value types using a mixture of
<a class="reference external" href="https://www.json.org/">JSON</a> and
<a class="reference external" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>.</p>
<p>For example, the following grfn_spec definition</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span> <span class="o">|</span> <span class="s2">&quot;units&quot;</span> <span class="o">|</span> <span class="s2">&quot;constraint&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>specifies the structure of the grfn JSON instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="s2">&quot;http://epirecip.es/epicookbook/chapters/sir/intro&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span><span class="p">,</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="s2">&quot;susceptible individuals&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also use the following conventions in the discussion below:</p>
<ul class="simple">
<li><p>‘FUTURE’: Tags anticipated extensions that may be needed but not yet
supported.</p></li>
<li><p>‘CHOICE’: Captures discussion of a CHOICE that does not yet have a
clear resolution</p></li>
<li><p>‘FOR NOW’: Tags the approach being currently taken, eiher in response
to FUTURE or CHOICE.</p></li>
</ul>
</section>
<section id="preamble">
<h2>Preamble<a class="headerlink" href="#preamble" title="Permalink to this headline"></a></h2>
<p>The current GrFN design strategy is to separate <em>identifiers</em> (any
program symbol used to denote a program element) from the <em>program
elements</em> themselves (namely, variables and functions), as each program
element will be denoted by one or more identifiers, and the different
types of program elements themselves have intended scientific modeling
“functions”: variables (may) represent aspects of the modeled domain,
and functions represent processes that change variable states.</p>
<p>A key role of identifiers in the GrFN representation is to enable
<em>linking</em> (grounding) of program elements to information extracted by
Text and Equation Reading. Identifiers bring together two types of
information that make this linking possible:</p>
<ol class="arabic simple">
<li><p>The identifier name (<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__) and namespace
context (<a class="reference external" href="#scope-and-namespace-paths">scope and namespace paths</a>)
of the identifier as it appears in program source context are used as
evidence of potential semantic relations to other textual sources
based on string similarity or name embedding;</p></li>
<li><p>Information about the location and neighborhood in source code where
the identifier is used (a
<code class="docutils literal notranslate"><span class="pre">`&lt;source_code_reference&gt;</span></code> &lt;#grounding-and-source-code-reference&gt;`__)
provides additional sources of evidence, based on proximity to source
code comments and docstrings, as well as proximity to uses of other
identifiers.</p></li>
</ol>
<p>An linking/grounding inference algorithm uses string or embedding
similarity between base, scope and namespace names and information
extracted from documents by Text Reading to form hypotheses of potential
links between identifiers and the text-extracted information. Such link
hypotheses are explicitly connected to identifiers in GrFN (by instances
of <code class="docutils literal notranslate"><span class="pre">`&lt;grounding_metadata_spec&gt;</span></code> &lt;#grounding-metadata-spec&gt;`__).</p>
<p>Program elements (variables and functions) are associated with
identifiers based on declarations in source code, and thereafter, the
use of the same identifiers elsewher in source code is a denotation of
the variable or function. Information from Text Reading (e.g.,
“mentions” of domain concept terms or phrases in text) associated with
identifiers is then linked to program elements by association of the
idenifier. For example, the indicator ‘S’ may store an integer and be
described in documentation as associated with (defined as representing)
the “susceptible population”.</p>
</section>
<section id="identifier">
<h2>Identifier<a class="headerlink" href="#identifier" title="Permalink to this headline"></a></h2>
<p>An <a class="reference external" href="#identifier-specification">identifier</a> is a symbol used to
uniquely identify a program element in code, where a <em>program element</em>
is a</p>
<ul class="simple">
<li><p>constant value</p></li>
<li><p>variable</p></li>
<li><p>function</p></li>
</ul>
<blockquote>
<div><p>FUTURE: possibly: type, class</p>
</div></blockquote>
<p>More than one identifier can be used to denote the same program element,
but an identifier can only be associated with one program element at a
time.</p>
</section>
<section id="grounding-and-source-code-reference">
<h2>Grounding and source code reference<a class="headerlink" href="#grounding-and-source-code-reference" title="Permalink to this headline"></a></h2>
<p>Identifiers play a key role in connecting the model as implemented in
source code to the target domain that it models. <em>Grounding</em> is the task
of inferring what aspect of the target scientific domain a program
element may correspond to. Identifiers, by their <a class="reference external" href="#base-name">(base)
name(s)</a> and the context of their declaration and use
(i.e., where they occur in code, through their <a class="reference external" href="#scope-and-namespace-paths">scope and
namespace</a>), and the linline comment and
doc strings that occur around them, provide clues to what program
elements are intended to represent in the target domain. For this
reason, we need to associate with identifiers several pieces of
information. This information will be collected during program analysis
and associated with the identifier declaration:</p>
<blockquote>
<div><p>FUTURE: General handling of pointers/references (related to the
concept of having an “alias”) will require care, as this introduces
the possiblity of multiple identifiers being used to refer to the
same program element, and also a single identifier being used to
refer to different program elements in different contexts. In the
general case it is not possible to determine all pointer references
<em>statically</em>. (DSSAT does include some pointers.)</p>
</div></blockquote>
<p>To facilitate grounding inference, the
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_spec&gt;</span></code> &lt;#identifier-specification&gt;`__ will have a
“source_references” attribute whose value is a list of
<code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code>s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">source_code_reference</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The string contains information to indicate the location within the
source code where an identifier was used.</p>
<blockquote>
<div><p>TODO: Program Analysis and Text and Equation Reading (NLP processing
of comments and source literature) will determine how source code
references are represented within the string. It may be sufficient to
have a single line number to represent the source code line within
which the identifier was used.</p>
</div></blockquote>
</section>
<section id="base-name">
<h2>Base Name<a class="headerlink" href="#base-name" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> is intended to correspond (when available) to the
identifier token name as it appears in the source language (e.g.,
Fortran). The <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> is itself a string</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">base_name</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>but follows the conventions of <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">python identifier specification
rules</a>
(which includes Fortran naming syntax).</p>
<blockquote>
<div><p>FUTURE: may extend this as more source languages are supported.</p>
</div></blockquote>
<p>Below, we specify the conventions for <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code>s of identifiers
that do not originate in the source code:</p>
<ul class="simple">
<li><p><a class="reference external" href="#variable-naming-convention">Variable Naming Convention</a></p></li>
<li><p><a class="reference external" href="#function-naming-convention">Function Naming Convention</a></p></li>
</ul>
</section>
<section id="scope-and-namespace-paths">
<h2>Scope and Namespace Paths<a class="headerlink" href="#scope-and-namespace-paths" title="Permalink to this headline"></a></h2>
<p>Identifiers may have the same <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ (as it
appears in source code) but be distinguished by either (or both) the
“<a class="reference external" href="https://en.wikipedia.org/wiki/Scope_(computer_science)">scope</a>” and
“<a class="reference external" href="https://en.wikipedia.org/wiki/Namespace">namespace</a>” within which
they are defined in the source code.</p>
<p>Each source language has its own rules for specifying scope and
namespace, and it will be the responsibility of each program analysis
module (e.g., Fortran <code class="docutils literal notranslate"><span class="pre">for2py</span></code>) to identify the hierarchical structure
of the context that uniquely identifies the specific scope and/or
namespace within which an identifier <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ is
defined. However, generally scopes and namespaces may be defined
hierarchically, such that the name for each level of the hierarchy taken
together uniquely define the context. A “path” of names appears to be
sufficient to generally represent the hierarchical context for either a
specific scope or namespace. In general, names for a path are listed in
order from general (highest level in the hierarchy) to specific.</p>
<p>Examples:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>: As will be described below, program analysis will
assign unique names for scopes (see <a class="reference external" href="#function-naming-convention">discussion below under
conditional, container and loop_plate function naming
convention</a>). Given these names, the
scopes of the two inner loops within the outer loop of function
<code class="docutils literal notranslate"><span class="pre">foo</span></code> in this example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>      <span class="c1"># assigned name &#39;loop$1&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>  <span class="c1"># assigned name &#39;loop$1&#39; (in the scope</span>
                             <span class="c1">#    ... of the outer loop$1)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>  <span class="c1"># assigned name &#39;loop$2&#39; (also in the</span>
                             <span class="c1">#    ... scope of the outer loop$1)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>… would be uniquely specified by the following path (respectively):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$2&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>In general, it is not necessary within GrFN to independently declare
scopes. Instead, we simply specify the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code> in an
indicator declaration as a list of strings under the “scope”
attribute in the identifier declaration (below).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">scope_path</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “top” level of the file (i.e., not enclosed within another
program block context) will be assigned the default scope name of
“_TOP”. All other scopes are either explicitly named (such as a
named function), or are assigned a unique name by program analysis
according to the rules of the type of scope (such as container, loop,
conditional, etc), defined below. In such cases other than top, there
is no need to include the “_TOP” in the path – it will be assumed
that those named scopes are all within the default top-level scope.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code>: Different languages have different conventions
for defining namespaces, but in general they are either (1)
explicitly defined within source code by namespace declarations (such
as Fortran “modules” or C++ “namespace”s), or (2) implicitly defined
by the project directory structure within which a file is located (as
in Python). In the case of namespaces defined by project directory
structure, two files in different locations in the project directory
tree may have the same name. To distinguish these, program analysis
will capture the path of the directory tree from the root to the
file. The final name in the path, which is the name of the source
file, will drop the file extension. For example, the namespace for
file <code class="docutils literal notranslate"><span class="pre">baz.py</span></code> within the following directory tree</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">/</span>
    <span class="n">bar</span><span class="o">/</span>
        <span class="n">baz</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>would be the uniquely specified by the following path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="s2">&quot;baz&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the case of declared namespaces, the namespace declaration will
determine the path (which may only consist of one string name).</p>
<p>Again, it is not necessary within GrFN to independently declare a
namespace; like the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>, we specify the
<code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code> within an identifier declaration as a list
strings under the “namespace” attribute in the identifier
declaration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">namespace_path</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Like the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>, the string names of the path uniquely
defining the namespace are in in order from general to specific, with
the last string name either being the implicit namespace defined by
the source code file, or the user-defined name of the namespace.</p>
</li>
</ul>
</section>
<section id="path-strings">
<h2>Path Strings<a class="headerlink" href="#path-strings" title="Permalink to this headline"></a></h2>
<p>It will be convenient to be able to express
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__s and
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__s using single
strings within GrFN (particularly when building an identifier string).
For this we introduce a special string notation in which the string
names that make up a path are expressed in order but separated by
periods. These representations will be referred to as the
<code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code>, respectively.
The string representations of the
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__ and
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__ examples above
would be:</p>
<ul>
<li><p>Example <code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.loop$1.loop$1&quot;</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.loop$1.loop$2&quot;</span>
</pre></div>
</div>
</li>
<li><p>Example <code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.bar.baz&quot;</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="identifier-string">
<h2>Identifier String<a class="headerlink" href="#identifier-string" title="Permalink to this headline"></a></h2>
<p>Identifiers are uniquely defined by their
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__,
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__, and
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__. It will be
convenient to refer unambiguously to any identifier using a single
string, outside of the identifier specification declaration (defined
below). We define an <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code> by combining the
‘namespace’, ‘scope’ and ‘base_name’ (in that order) within a single
string by separating the
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__,
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path_string&gt;</span></code> &lt;#path-strings&gt;`__ and
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ by double-colons:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;&lt;namespace_path_string&gt;::&lt;scope_path_string&gt;::&lt;base_name&gt;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>s will be used to denote identifiers as they
are used in variable and function specifications (described below).</p>
</section>
<section id="identifier-gensym">
<h2>Identifier Gensym<a class="headerlink" href="#identifier-gensym" title="Permalink to this headline"></a></h2>
<p>One of the outputs of program analysis is a functionally equivalent
version of the original source code and lambda functions (described
below), both expressed in Python (as the intermediate target language).
All identifiers in the output Python must match identifiers in GrFN.
Since capturing the semantics (particularly the namespace and scope
context) results in a representation that does not appear to be
consistently expressible in legal Python symbol names, we will use
<code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s that can be represented (generally more compactly) as
legal Python names and associated uniquely with identifiers.</p>
<blockquote>
<div><p>FUTURE: Create a hashing function that can translate uniquely back
and forth between <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s and identifier strings.</p>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: Generate <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s as Python names that start with a
letter followed by a unique integer. The letter could be ‘g’ for a
generic gensym (e.g., g2381), or ‘v’ to indicate a variable
identifier (e.g., v921) and ‘f’ to indicate a function identifier
(e.g. f38).</p>
</div></blockquote>
<p>Each identifier will be associated one-to-one with a unique
<code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>.</p>
</section>
<section id="grounding-metadata-spec">
<h2>Grounding Metadata spec<a class="headerlink" href="#grounding-metadata-spec" title="Permalink to this headline"></a></h2>
<p>Text Reading is currently working on extracting three types of
information that can be associated with identifiers:</p>
<ul class="simple">
<li><p>Definitions (e.g., ‘wind speed’, ‘susceptible individuals’)</p></li>
<li><p>Units (e.g., ‘millimeters’, ‘per capita’)</p></li>
<li><p>Constraints (e.g., ‘&gt; 0’, ‘&lt;= 100’)</p></li>
</ul>
<p>Each of these types can be expressed as an instance of a
<code class="docutils literal notranslate"><span class="pre">&lt;grounding_metadata_spec&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span> <span class="o">|</span> <span class="s2">&quot;units&quot;</span> <span class="o">|</span> <span class="s2">&quot;constraint&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>FUTURE: add confidence/belief score</p>
</div></blockquote>
</section>
<section id="identifier-specification">
<h2>Identifier Specification<a class="headerlink" href="#identifier-specification" title="Permalink to this headline"></a></h2>
<p>Each identifier within a GrFN specification will have a single
<code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code> declaration. An identifier will be declared in the
GrFN spec JSON by the following attribute-value list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">identifier_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;base_name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">base_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;scope&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">scope_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;namespace&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">namespace_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;source_references&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">source_code_reference</span><span class="o">&gt;</span>
    <span class="s2">&quot;gensym&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">gensym</span><span class="o">&gt;</span>
    <span class="s2">&quot;grounding&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="variable-naming-convention">
<h2>Variable Naming Convention<a class="headerlink" href="#variable-naming-convention" title="Permalink to this headline"></a></h2>
<p>A variable name will be an
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>A top level source variable named ABSORPTION would then simply have the
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ of “ABSORPTION” plus the relevant
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__ and
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path_string&gt;</span></code> &lt;#path-strings&gt;`__.</p>
<p>When there are two (or more) separate instances of new variable
declarations in the same context (same namespace and scope) using the
same name, then we’ll add an underscore and number to the
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ to distinguish them. For example, if
ABSORPTION is defined twice in the same namespace and scope, then the
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ of the first (in order in the source
code) is named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ABSORPTION_1&quot;</span>
</pre></div>
</div>
<p>And the second:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ABSORPTION_2&quot;</span>
</pre></div>
</div>
<p>Finally, in some cases (described below), program analysis will
introduce variables (e.g., when analyzing conditionals). The naming
conventions for the <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ of such introduced
variables are described below.</p>
</section>
<section id="variable-reference">
<h2>Variable Reference<a class="headerlink" href="#variable-reference" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;variable&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In addition to capturing source code variable environment context in
variable declarations, we also need a mechanism to disambiguate specific
instances of <em>use</em> of the same variable within the same context to
accurately capture the logical order of variable value updates. In this
case, we consider this as a repeated reference to the same variable. The
semantics of repeated reference is captured by the variable “index”
attribute of a <code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code>. The index integer serves to
disambiguate the execution order of the variable state references, as
determined during program analysis.</p>
</section>
<section id="function-naming-convention">
<h2>Function Naming Convention<a class="headerlink" href="#function-naming-convention" title="Permalink to this headline"></a></h2>
<p>Function names, like variable names, are also ultimately
<a class="reference external" href="#identifier-specification">identifiers</a> that will commonly be
referenced within GrFN by their
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__ (and therefore include
their <code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__ and
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path_string&gt;</span></code> &lt;#path-strings&gt;`__)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>However, there are additional rules for determining the
<code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ of the function. Because of this
particular set of rules, the <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__ of the
function name will be referred to as a <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>. The
general string format for a <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;function_base_name&gt; ::= &lt;function_type&gt;[$[&lt;var_affected&gt;|&lt;code_given_name&gt;]]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_type&gt;</span></code> is the string representing which of the four
types the function belongs to (the types are described in more detail,
below): <a class="reference external" href="#function-assign-specification">“assign”</a>,
<a class="reference external" href="#function-assign-specification">“condition”</a>,
<a class="reference external" href="#function-assign-specification">“decision”</a>,
<a class="reference external" href="#function-container-specification">“container”</a>,
<a class="reference external" href="#function-loop-plate-specification">“loop_plate”</a>. In the case of a
loop_plate, we will name the specific loop using the generic name “loop”
along with an integer (starting with value 1) uniquely distinguishing
loops within the same namespace and scope.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> is used when the function identified
by program analysis has also been given a name within source code. For
example, in this python example:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">foo</span><span class="p">()</span><span class="o">:</span>
    <span class="p">...</span>
</pre></div>
</div>
<p>the function foo is a type of “container” and its <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code>
is “foo”, making the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;container$foo&quot;</span>
</pre></div>
</div>
<p>The optional <code class="docutils literal notranslate"><span class="pre">&lt;var_affected&gt;</span></code> will only be relevant for assign,
condition and decision function types, and the name of the variable
affected will be added after the <code class="docutils literal notranslate"><span class="pre">&lt;function_type&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code>. For
example, a condition involving the setting of the (inferred) boolean
variable IF_1 would have the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;condition$IF_1&quot;</span>
</pre></div>
</div>
<p>Here are example function names for each function type. In each example,
we assume the function is defined within the scope of another function,
UPDATE_EST, and the namespace CROP_YIELD.</p>
<ul>
<li><p><a class="reference external" href="#function-assign-specification">Assign</a>: An assignment of the
variable with the <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>
“CROP_YIELD::UPDATE_EST::YIELD_EST” (which denotes the identifier
with <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> “YIELD_EST” in the scope of the function
UPDATE_EST declared in the namespace CROP_YIELD) has the
<code class="docutils literal notranslate"><span class="pre">function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;assign$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
<p>If this assignment takes place in the function UPDATE_EST and the
namespace CROP_YIELD, then the full
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__ of the function
identifier would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::UPDATE_EST::assign$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-assign-specification">Condition</a>: A condition assigning
the (inferred) boolean variable IF_1 in the scope of the function
UPDATE_EST of the namespace CROP_YIELD would have the
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::UPDATE_EST::condition$IF_1&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-assign-specification">Decision</a>: A decision function
assigns a variable a value based on the (outcome) state of a
condition variable. If the variable “YIELD_EST” (from the namespace
“CROP_YIELD” and scope “UPDATE_EST”) is being updated as a result of
a conditional outcome in the namespace “CROP_YIELD” and scope
“DERIVE_YIELD”, then the
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__ would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::DERIVE_YIELD::decision$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-container-specification">Container</a>: A container
function declared in source code to have the name CROP_YIELD would
then have the <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> of CROP_YIELD, and if this was
declared at the top level of a file (defining the namespace) called
CROP_YIELD would have the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;container$CROP_YIELD&quot;</span>
</pre></div>
</div>
<p>and the full <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code> of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::NULL::container$CROP_YIELD&quot;</span>
</pre></div>
</div>
<p>(Note that the first occurrence of “CROP_YIELD” in the string is for
the namespace, the NULL is because it’s defined at the top level, and
then the second occurrence of “CROP_YIELD” is the
<code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> of CROP_YIELD.)</p>
</li>
<li><p><a class="reference external" href="#function-loop-plate-specification">Loop_plate</a>: Loops themselves
are not assigned identifiers within source code, so identifiers will
be assigned during program analysis. As described above, the
<code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> of the loop_plate function type is “loop”
followed by a ‘$’ and an integer starting from <code class="docutils literal notranslate"><span class="pre">1</span></code> that
distinguishes the loop from any other loops occurring in the same
namespace and scope.</p>
<ul>
<li><p>A single loop within the function CROP_YIELD of the namespace
CROP_YIELD has the <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD::loop$1&quot;</span>
</pre></div>
</div>
</li>
<li><p>The third of three loops within the function CROP_YIELD of
namespace CROP_YIELD:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD::loop$3&quot;</span>
</pre></div>
</div>
</li>
<li><p>A loop nested in the context of the second loop, “loop$2”, in the
CROP_YIELD function within the CROP_YIELD namespace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD.loop$2::loop$1&quot;</span>
</pre></div>
</div>
</li>
<li><p>An assignment of the variable “CROP_YIELD::_TOP::RAIN” (i.e., the
variable “RAIN” was defined in the default “top”-level scope,
within the namespace CROP_YIELD) within a single loop in the
CROP_YIELD function in the CROP_YIELD namespace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD.loop$1::assign$CROP_YIELD::_TOP::RAIN&quot;</span>
</pre></div>
</div>
<p>(Note that the above string is still unambiguous to parse to
recover the components pieces of the name: the first two names
separated by ‘::’ are the
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path_string&gt;</span></code> &lt;#path-strings&gt;`__ followed by the
<code class="docutils literal notranslate"><span class="pre">`&lt;scope_path_string&gt;</span></code> &lt;#path-strings&gt;`__, with the rest being
the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> of the function, which itself is an
“assign” of a variable that itself is a complete
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__)</p>
</li>
</ul>
</li>
</ul>
<p>The top-level structure of the GrFN specification is the <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code>
and is itself a JSON attribute-value list, with the following schema
definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grfn_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;date_created&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">source_code_file_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;identifiers&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">identifier_spec</span><span class="o">&gt;</span>
    <span class="s2">&quot;variables&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_spec</span><span class="o">&gt;</span>
    <span class="s2">&quot;functions&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “date_created” attribute is a string representing the date+time that
the current GrFN was generated (this helps resolve what version of the
program analysis code (e.g., for2py) was used).</p>
<p>There may be a single GrFN spec file for multiple source code files.</p>
<blockquote>
<div><p>CHOICE: A source file may define identifiers and program elements
that are then referenced/used in many other system program unit
components (other files). We can defined the concepts of a “Program”
as the collection of source code from a file plus any other files
containing source code that it references/uses. If we have a single
GrFN spec for each “Program”, then we will be repeatedly reproducing
many identifiers and other program element declarations (variables,
functions). The alternatives are:</p>
</div></blockquote>
<blockquote>
<div><ol class="arabic simple">
<li><p>A single GrFN spec for a given “Program” and live with the
redundant re-representation of source code that is shared across
different units.</p></li>
<li><p>Have a single GrFN spec for each individual file and develop
method for importing/using GrFN specs that are used by other GrFN
specs. (A variant of this approach could allow only including GrFN
spec for the parts of the shared source code that are directly
relevant to a “Program”.)</p></li>
</ol>
<p>FOR NOW: Go with Option (1): The main target of a GrFN spec file is
<em>all</em> of the source code files involved in defining a “Program”.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE: Add ability for GrFN specs to “import” and/or “use” other
GrFN specs of other modules (leading to the more efficient option
(2)).</p>
<p>FOR NOW: the “source” attribute is a list of one or more
<code class="docutils literal notranslate"><span class="pre">&lt;source_code_file_path&gt;</span></code>s. The <code class="docutils literal notranslate"><span class="pre">&lt;source_code_file_path&gt;</span></code>
identifying a source file is represented the same way as a
<code class="docutils literal notranslate"><span class="pre">`&lt;namespace_path&gt;</span></code> &lt;#scope-and-namespace-paths&gt;`__, except that
the final name (the name of the file itself) <em>will</em> include the file
extension.</p>
</div></blockquote>
<p>It is conventient to explicitly represent the functions that are
intended to be called as the “top level” functions of the “Program”. We
will refer to these as “start” points. These may be explicity specified
by a programmer/user.</p>
<blockquote>
<div><p>FOR NOW: “start” points will be manually specified.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE: Consider methods of automatically inferring the “start”
points. For example, these might be the roots of the computation
graph representing the “Program”. However, there are subtleties here:
e.g., function call loops (fn1 calls fn2, which calls fn1).</p>
</div></blockquote>
<p>To capture this concept, the “start” attribute is a list of zero or more
names of the entry point(s) of the (Fortran) source code (for example,
the PROGRAM module). These will be function
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__s. In the absence of
any entry point, this value will be an empty list: <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>The “identifiers” attributes contains a list of
<code class="docutils literal notranslate"><span class="pre">`&lt;identifer_spec&gt;</span></code> &lt;#identifier-specification&gt;`__s.</p>
<blockquote>
<div><p>FUTURE: It may also be desirable to add an attribute to represent the
program analysis code version used to generate the GrFN (as the
program analysis code is evolving and each change has different
properties).</p>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: “dateCreated” will play this role.</p>
</div></blockquote>
<p>The “variables” attribute contains a list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__s.</p>
<blockquote>
<div><p>(NOTE: In GrFN version 0.1.m3,
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__s were defined in
the context of <code class="docutils literal notranslate"><span class="pre">`&lt;function_spec&gt;</span></code> &lt;#function-specification&gt;`__s.
With need to iterate over variables (e.g. when performing inference
for associating comments and text with variable definitions), it is
more convenient to group variable specifications at the top level.
Starting in GrFN version 0.1.m5, references to variables within
functions will use
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__s to identify the
variables, and <code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__s
will be listed in the top-level GrFN “variables” attribute.)</p>
</div></blockquote>
<p>A (partial) example instance of the JSON generated for a <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code>
of an analyzed file in the path ‘crop_system/yield/crop_yield.py’ is:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;dateCreated&quot;</span><span class="o">:</span> <span class="s2">&quot;20190127&quot;</span><span class="p">,</span>
    <span class="s2">&quot;source&quot;</span><span class="o">:</span> <span class="p">[[</span><span class="s2">&quot;crop_system&quot;</span><span class="p">,</span> <span class="s2">&quot;yield&quot;</span><span class="p">,</span> <span class="s2">&quot;crop_yield.py&quot;</span><span class="p">]],</span>
    <span class="s2">&quot;start&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;MAIN&quot;</span><span class="p">],</span>
    <span class="s2">&quot;identifiers&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">identifier_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
    <span class="s2">&quot;variables&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">variable_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
    <span class="s2">&quot;functions&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">function_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;domain&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_domain_type</span><span class="o">&gt;</span>
    <span class="s2">&quot;mutable&quot;</span> <span class="p">:</span> <span class="n">TRUE</span> <span class="o">|</span> <span class="n">FALSE</span>
</pre></div>
</div>
<p>As defined above, the
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ is itself an
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__.</p>
<p>The “mutable” attribute specifies whether the variable value <em>can</em>
(TRUE) or <em>cannot</em> (FALSE) be changed. (Note that the values TRUE and
FALSE are JSON Boolean values.) Mutability is determined by Program
Analysis, and Model Analysis can use this information in sensitivity
anlysis (if the constant value of a non-mutable variable can be
determined, then the variable does not need to be varied in sensitivity
analysis).</p>
<blockquote>
<div><p>TODO: Possibly make explicit specification of “mutable” optional,
with default value TRUE, so only need to explicitly specify when
FALSE. Does this cause trouble for parsing?</p>
</div></blockquote>
<p>Some languages (including Fortran and Python) provide mechanisms for
making variable declarations private (such as Python’s name mangling, by
prepending an underscore to a variable name).</p>
<blockquote>
<div><p>FOR NOW: Our hypothesis is that simply prepending another underscore
(following python <a class="reference external" href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references">name
mangling</a>)
will make the “private” variable <code class="docutils literal notranslate"><span class="pre">`&lt;base_name&gt;</span></code> &lt;#base-name&gt;`__
unique from other variable names. Also, Program Analysis will
“preserve” the semantics of privacy by ensuring there are no
outer-scope references to a private variable, and this will carry
through in explicit references (or lack thereof, in this case)
captured in the GrFN spec (in particular, in the
<code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__s
of the “body” of container and loop_plate function specs).</p>
</div></blockquote>
</section>
<section id="variable-value-domain">
<h2>Variable Value Domain<a class="headerlink" href="#variable-value-domain" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_domain_type</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “domain” attribute of a
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__ specifies what values
the variable can be assigned to. To start, we will keep things simple
and restrict ourselves to four types that can be specified as strings:</p>
<ul class="simple">
<li><p>“real” (i.e. a floating-point number)</p></li>
<li><p>“integer”</p></li>
<li><p>“boolean”</p></li>
<li><p>“string”</p></li>
</ul>
<p>(The idea of the variable domain is intended to be close to the idea of
the “support” of a random variable, although should also correspond to
standard data types.)</p>
<blockquote>
<div><p>FUTURE: Extend to accommodate arrays.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE:</p>
<ul class="simple">
<li><p>Accommodate other structures: Unions, composite data structures,
classes.</p></li>
<li><p>Extend the domain specification to represent whether there are
bounds on the values (e.g., positive integers, or real values in
(0,10], etc.). When we move to doing this, the value of “domain”
will itself become a new JSON attrval type.</p></li>
</ul>
</div></blockquote>
<p>Python is a strongly-typed language, but is also a dynamically typed
language. However, that’s not to say that there is no type specification
in Python. Python 3 now provides nascent support for explicit typing via
<a class="reference external" href="https://docs.Python.org/3/library/typing.html">type hints</a>.</p>
<blockquote>
<div><p>FUTURE: Explore whether/how type hints get represented in the AST.
This will matter when we get to adding more explicit variable domain
semantics in later model analysis.</p>
</div></blockquote>
<p>For our purposes in the near term, we do want to capture what type and
value-domain information is available; there are two main sources of
this information (parentheses note the analysis process that may
extract/infer/preserve this information):</p>
<ol class="arabic simple">
<li><p><strong>Source Declarations</strong>: (Program Analysis) Fortran statically
specifies types in declarations. We can preserve type information in
Program Analysis-generated Python code by using type hints or by
adding to generated docstrings.</p></li>
<li><p><strong>Docstrings</strong>: (Text Reading) Source code docstrings and comments
may provide information about types and value ranges that can be
inferred by Text Reading.</p></li>
</ol>
</section>
<section id="variable-spec-examples">
<h2>&lt;variable_spec&gt; examples<a class="headerlink" href="#variable-spec-examples" title="Permalink to this headline"></a></h2>
<p>Here are three examples of <code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code> objects:</p>
<ul>
<li><p>Example of a “standard” variable MAX_RAIN within the CROP_YIELD
function of the CROP namespace:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::CROP_YIELD::MAX_RAIN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">FALSE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Example of loop index variable DAY in the context of the second
instance of a loop in the function CROP_YIELD (in the CROP
namespace):</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::CROP_YIELD.loop$2::DAY&quot;</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">TRUE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Example of variable introduced (inferred) when analyzing a
conditional statement that is within the named function UPDATE_EST of
the CROP namespace:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::UPDATE_EST::IF_1&quot;</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">TRUE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Next we have the <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>.</p>
<p>All <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s include a
<code class="docutils literal notranslate"><span class="pre">`&lt;function_name&gt;</span></code> &lt;#function-naming-convention&gt;`__, following the
<a class="reference external" href="#function-naming-convention">function naming convention described
above</a>.</p>
<p>There are five types of functions; three types can be expressed using
the same attributes in their JSON attribute-value list
(<code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_spec&gt;</span></code> &lt;#function-assign-specification&gt;`__), while
the others
(<code class="docutils literal notranslate"><span class="pre">`&lt;function_container_spec&gt;</span></code> &lt;#function-container-specification&gt;`__,
<code class="docutils literal notranslate"><span class="pre">`&lt;function_loop_plate_spec&gt;</span></code> &lt;#function-loop-plate-specification&gt;`__)
require different attributes. So this means there are three
specializations of the &lt;function_spec&gt;, one of which
(<code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_spec&gt;</span></code> &lt;#function-assign-specification&gt;`__) will
be used for three function types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_spec</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>
    <span class="o">&lt;</span><span class="n">function_assign_spec</span><span class="o">&gt;</span>         <span class="c1"># covers &quot;assign&quot;, &quot;condition&quot;, &quot;decision&quot;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_container_spec</span><span class="o">&gt;</span>    <span class="c1"># type &quot;container&quot;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_loop_plate_spec</span><span class="o">&gt;</span>   <span class="c1"># type &quot;loop_plate&quot;</span>
</pre></div>
</div>
<p>All three specs will have a “type” attribute with a string value that
will unambiguously identify which type of function is being specified.
The five possible types are:</p>
<ul class="simple">
<li><p>“<a class="reference external" href="#function-assign-specification">assign</a>”</p>
<ul>
<li><p>“<a class="reference external" href="#function-assign-specification">condition</a>” (a special case
of Assign)</p></li>
<li><p>“<a class="reference external" href="#function-assign-specification">decision</a>” (a special case of
Assign)</p></li>
</ul>
</li>
<li><p>“<a class="reference external" href="#function-container-specification">container</a>”</p></li>
<li><p>“<a class="reference external" href="#function-loop-plate-specification">loop_plate</a>”</p></li>
</ul>
<p>All <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s will also have a “name” attribute with a
unique <code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__ (across
<code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s), as described above under the <a class="reference external" href="#function-naming-convention">Function Naming
Convention</a> section; as described in
that section, the function <code class="docutils literal notranslate"><span class="pre">`&lt;base\_name&gt;</span></code> &lt;#base-name&gt;`__ will
include the function type name, but having the explicit type attribute
makes JSON parsing easier.</p>
</section>
<section id="function-assign-specification">
<h2>Function Assign Specification<a class="headerlink" href="#function-assign-specification" title="Permalink to this headline"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code> denotes the setting of the value of a
variable. The values are assigned to the “target” variable (denoted by a
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_reference&gt;</span></code> &lt;#variable-reference&gt;`__ or
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__) and the value is
determined by the “body” of the assignment, which itself may either be a
literal value (specified by
<code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_body_literal_spec&gt;</span></code> &lt;#function-assign-body-literal&gt;`__)
or a lambda function (specified by
<code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_body_lambda_spec&gt;</span></code> &lt;#function-assign-body-lambda&gt;`__).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;assign&quot;</span> <span class="o">|</span> <span class="s2">&quot;condition&quot;</span> <span class="o">|</span> <span class="s2">&quot;decision&quot;</span>
        <span class="c1"># note that the value of the &quot;type&quot; is a literal/terminal</span>
        <span class="c1"># value of the grammar</span>
    <span class="s2">&quot;sources&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;target&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_assign_body_literal_spec</span><span class="o">&gt;</span>
             <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_assign_body_lambda_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>There are three types of assign functions, distinguished by the value of
the attribute “type”.</p>
<ul class="simple">
<li><p><strong>“assign”</strong>: This represents the general case of assignment of a
variable to some value.</p></li>
<li><p><strong>“condition”</strong>: In the special case where Program Analysis is
analyzing a conditional (i.e., “if”) statement, then Program Analysis
will infer a new boolean target variable, and the computation of the
condition itself will be represented by a function assigning the
inferred boolean variable value. Semantically, this is nothing more
than an assignment of a boolean variable, but conceptually it will be
useful to distinguish assignments used for conditions from other
assignments.</p></li>
<li><p><strong>“decision”</strong>: Also as part of analyzing a conditional, any
variables whose values are updated as a result of the condition
outcome must have their values updated. These will be updated by
“decision” assignment functions, whose target is the variable being
updated, and the computations will involve the state of the
conditional variable, the previous state of the variable being
updated, and possibly other variable values. Again, semantically this
is nothing more than an assignment, but is useful to distinguish from
other assignments.</p></li>
</ul>
<p>The identifier conventions for assign, condition and decision functions
is described above in the section on <a class="reference external" href="#function-naming-convention">Function Naming
Convention</a>.</p>
<p>For “sources” and “target”: When there is no need to refer to the
variable by its relative index, then
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ (itself an
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__) is sufficient, and
index will be assumed to be 0 (if at all relevant).</p>
<p>In other cases, the variables will be referenced using the
<code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code>, to indicate the return value of the
function. There may also be cases where the sources can be a function,
either built-in or user-defined. These two will be referenced using
<code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code> defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>
   <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span> <span class="p">]</span>
   <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;variable&quot;</span> <span class="o">|</span> <span class="s2">&quot;function&quot;</span>
</pre></div>
</div>
<section id="function-assign-body-literal">
<h3>Function assign body Literal<a class="headerlink" href="#function-assign-body-literal" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_literal_spec&gt;</span></code> asserts the assignment of a
<code class="docutils literal notranslate"><span class="pre">&lt;literal_value&gt;</span></code> to the target variable. The <code class="docutils literal notranslate"><span class="pre">&lt;literal_value&gt;</span></code> has
a data type (corresponding to one of our four domain types), and the
value itself will be represented generically in a string (the string
will be parsed to extract the actual value according to its data type).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_body_literal_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;literal&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">literal_value</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">literal_value</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;dtype&quot;</span> <span class="p">:</span> <span class="s2">&quot;real&quot;</span> <span class="o">|</span> <span class="s2">&quot;integer&quot;</span> <span class="o">|</span> <span class="s2">&quot;boolean&quot;</span> <span class="o">|</span> <span class="s2">&quot;string&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="function-assign-body-lambda">
<h3>Function assign body Lambda<a class="headerlink" href="#function-assign-body-lambda" title="Permalink to this headline"></a></h3>
<p>When more computation is done to determine the value that is being
assigned to the variable in the
<code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_spec&gt;</span></code> &lt;#function-assign-specification&gt;`__, then
<code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_lambda_spec&gt;</span></code> is used.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_body_lambda_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;lambda&quot;</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;reference&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">lambda_function_reference</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>FUTURE: Eventually, we can expand this part of the grammar to
accommodate a restricted set of arithmetic operations involved in
computing the final value (this is now of interest in the World
Modelers program and we’re interested in supporting this in Delphi).</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code> references the source code function
in the <code class="docutils literal notranslate"><span class="pre">lambdas.py</span></code> file that does the computation, in the translated
Python generated by program analysis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">lambda_function_reference</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>NOTE: The <code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code>, which refers to the
post-analysis lambdas function created by Program Analysis is <em>NOT</em>
to be confused with a
<code class="docutils literal notranslate"><span class="pre">`&lt;source_code_reference&gt;</span></code> &lt;#grounding-and-source-code-reference&gt;`__,
which refers to the original source code that was analyzed (i.e., the
original Fortran source code).</p>
</div></blockquote>
<p>Any variables that are required as arguments to the lambda function must
correspond to the “source” list of variables
(<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ references) in
the <code class="docutils literal notranslate"><span class="pre">`&lt;function_assign_spec&gt;</span></code> &lt;#function-assign-specification&gt;`__.</p>
<p>As noted above, due to the more semantically rich identifier
specification and <code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__
representation, it is not straightforward to use the
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__ as the python symbol in
the translated Python generated by program analysis. Instead, function
and variable identifiers will be represented in the generated Python
using their <a class="reference external" href="#identifier-gensym">gensym</a>. For debugging and
visualization purposes, the generated Python code may be displayed with
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__s (or some version
that is closer to legal Python naming, although in general it does not
appear to be possible to create “safe” Python names directly from
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code> &lt;#identifier-string&gt;`__s).</p>
</section>
</section>
<section id="function-container-specification">
<h2>Function Container Specification<a class="headerlink" href="#function-container-specification" title="Permalink to this headline"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">&lt;function_container_spec&gt;</span></code> represents the grouping of a set of
variables and how they are updated by functions. Generally the “function
container” corresponds to functions (or subroutines) defined in source
code. A “function container” is also defined for the “top” level of a
source code file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_container_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;container&quot;</span>
    <span class="s2">&quot;DOCS&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;output&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>There will be a container function for each source code function. For
this reason, we need an “input” variable list (of 0 or more variables)
as well as an “output” variable. In Python, a function only returns a
value if there is an explicit return expression. Otherwise it returns
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The “body” is specified by a list of
<code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__</p>
<p>Case 1: subroutine</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo1_subroutine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">foo2_subroutine</span><span class="p">():</span>
    <span class="n">Integer</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">foo1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">foo1</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>now z = 5 and w = 5</p>
<p>Case 2: fortran function with simple return</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">&lt;-</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">foo2</span><span class="p">():</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
</pre></div>
</div>
<p>Case 3: fortran function with return expression</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>becomes…</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
  <span class="n">foo_return1</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>

<span class="k">return</span> <span class="n">foo_return1</span>
</pre></div>
</div>
<p>Case 4: conditional return statements</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="c1">#fortran function</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
</section>
<section id="function-reference-specification">
<h2>Function Reference Specification<a class="headerlink" href="#function-reference-specification" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;function&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;output&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code> defines the “wiring” of functions,
specifying associations of variables to function inputs (arguments) and
the function output variable (FOR NOW: assuming all functions set zero
or one variable state).</p>
</section>
<section id="function-loop-plate-specification">
<h2>Function Loop Plate Specification<a class="headerlink" href="#function-loop-plate-specification" title="Permalink to this headline"></a></h2>
<p>The concept behind a “loop plate” is a generalization of the
<a class="reference external" href="https://en.wikipedia.org/wiki/Graphical_model">probabilistic graphical
model</a> convention for
<a class="reference external" href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a>,
extended to represent dynamic processes (a specification of a sequence
of state changes).</p>
<blockquote>
<div><p>TODO: Provide more background on the “loop plate” concept.</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_loop_plate</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;loop_plate&quot;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index_variable&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index_iteration_range&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">index_range</span><span class="o">&gt;</span>
    <span class="s2">&quot;condition&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">loop_condition</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “input” list of
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_name&gt;</span></code> &lt;#variable-naming-convention&gt;`__ objects should
list all variables that are set in the scope outside of the loop_plate.</p>
<p>The current loop_plate specification is aimed at handling for-loops.
(assumes “index_variable” and “index_iteration_range” are specified)</p>
<blockquote>
<div><p>FUTURE: Generalize to do-while loop by just relying on the
“condition” <code class="docutils literal notranslate"><span class="pre">&lt;loop_condition&gt;</span></code> to determine when loop completes. We
can then remove “index_variable” and “index_iteration_range”. There
will still need to be a mechanism for identifying index_variable(s).</p>
</div></blockquote>
<p>The “index_variable” is the named variable that stores the iteration
state of the loop; the naming convention of this variable is described
above, in the Variable naming convention section. The only new element
introduced is the <code class="docutils literal notranslate"><span class="pre">&lt;index_range&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">index_range</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">:</span><span class="o">:=</span>
    <span class="s2">&quot;start&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;end&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This definition permits loop iteration bounds to be specified either as
literal integers, or as the values of variables.</p>
</section>
</section>
<section id="change-log">
<h1>Change Log<a class="headerlink" href="#change-log" title="Permalink to this headline"></a></h1>
<p>Inspired by <a class="reference external" href="https://keepachangelog.com">Keep a Changelog</a></p>
<p>This project does not (yet) adhere to <a class="reference external" href="https://semver.org/spec/v2.0.0.html">Semantic
Versioning</a></p>
<section id="added">
<h2>Added<a class="headerlink" href="#added" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>GrFN_spec Index with links for quick reference navigation.</p></li>
<li><p>Changelog, inspired by <a class="reference external" href="https://keepachangelog.com">Keep a
Changelog</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">`&lt;grounding_metadata_spec&gt;</span></code> &lt;#grounding-metadata-spec&gt;`__ in
“grounding” field of
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_spec&gt;</span></code> &lt;#identifier-specification&gt;`__. Includes
source, type (definition, units, constraints) and value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;system_def&gt;</span></code> for defining the GrFN representation of a system
(collection of source files and multiple modules).</p></li>
</ul>
</section>
<section id="changed">
<h2>Changed<a class="headerlink" href="#changed" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Reorganized and rewrote portions of Introduction.</p></li>
<li><p>Modified
<code class="docutils literal notranslate"><span class="pre">`&lt;function_reference_spec&gt;</span></code> &lt;#function-reference-specification&gt;`__
so that it now has an “exit_condition” to represent while loops, and
subsumes for/iteration loops.</p></li>
<li><p>Modified <code class="docutils literal notranslate"><span class="pre">`&lt;varaible_spec&gt;</span></code> &lt;#variable-specification&gt;`__ adding
variable value “domain” constraints.</p></li>
</ul>
</section>
<section id="added-1">
<span id="id2"></span><h2>Added<a class="headerlink" href="#added-1" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Added “mutable” attribute to
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__.</p></li>
<li><p>Added “variables” attribute to top-level
<code class="docutils literal notranslate"><span class="pre">`&lt;grfn_spec&gt;</span></code> &lt;#top-level-grfn-specification&gt;`__, which contains
the list of all <code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code>s. This change also means that
<code class="docutils literal notranslate"><span class="pre">`&lt;function_spec&gt;</span></code> &lt;#function-specification&gt;`__s no longer house
<code class="docutils literal notranslate"><span class="pre">`&lt;variable_spec&gt;</span></code> &lt;#variable-specification&gt;`__s, but instead
just the <code class="docutils literal notranslate"><span class="pre">`&lt;variable_names&gt;</span></code> &lt;#variable-naming-convention&gt;`__
(which themselves are
<code class="docutils literal notranslate"><span class="pre">`&lt;identifier_string&gt;</span></code>s &lt;#identifier-string&gt;`__).</p></li>
<li><p>Added links to help topic navigation.</p></li>
</ul>
</section>
<section id="changed-1">
<span id="id3"></span><h2>Changed<a class="headerlink" href="#changed-1" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Clarified distinction between
<code class="docutils literal notranslate"><span class="pre">`&lt;source_code_reference&gt;</span></code> &lt;#grounding-and-source-code-reference&gt;`__s
(linking identifiers to where they are used in the analyzed source
code) and
<code class="docutils literal notranslate"><span class="pre">`&lt;lambda_function_reference&gt;</span></code> &lt;#function-assign-body-lambda&gt;`__s
(which denote functions in the Program Analysis-generated lambdas
file source code); previously these two concepts were ambiguous.</p></li>
</ul>
</section>
<section id="removed">
<h2>Removed<a class="headerlink" href="#removed" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Removed <code class="docutils literal notranslate"><span class="pre">`&lt;identifier_spec&gt;</span></code> &lt;#identifier-specification&gt;`__
“aliases” attribute. To be handled later as part of pointer/reference
analysis.</p></li>
</ul>
</section>
<section id="added-2">
<span id="id4"></span><h2>Added<a class="headerlink" href="#added-2" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Addition of identifiers: <code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code> (for identifiers in
generated code)</p></li>
</ul>
</section>
<section id="changed-2">
<span id="id5"></span><h2>Changed<a class="headerlink" href="#changed-2" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Revision of Introduction</p></li>
<li><p>Updates to naming conventions for variables and functions</p></li>
<li><p>General cleanup of discussion throughout</p></li>
</ul>
<ul class="simple">
<li><p>Unreleased: [development GrFN OpenAPI] <a class="reference external" href="https://github.com/ml4ai/delphi/blob/grfn/docs/grfn_spec.md">devlopment GrFN
documentation</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m9_milestone_report/GrFN_specification_v0.1.m9.md">0.1.m9</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m5_final_phase1_report/GrFN_specification_v0.1.m5.md">0.1.m5</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m3_report_prototype_system/GrFN_specification_v0.1.m3.md">0.1.m3</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m1_architecture_report/GrFN_specification_v0.1.md">0.1.m1</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="generated/delphi.GrFN.networks.ForwardInfluenceBlanket.run.html" class="btn btn-neutral float-left" title="delphi.GrFN.networks.ForwardInfluenceBlanket.run" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="delphi_database.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Adarsh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>