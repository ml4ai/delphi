C     Fortranification of Paul's DiscreteSIR.py 
      
      program DiscreteSIR
      implicit none
      
      call simulate()
      
      stop
      end program DiscreteSIR

C  ******************************************************************************
C  *                                                                            *
C  *   A function for computing the updated amounts of infected and recovered   *
C  *                                                                            *
C  ******************************************************************************
      double precision function randbn(n, p)
      double precision n, p, q, s, a, r, x, u
      double precision pyrand
      integer i

      q = 1.0 - p
      s = p/q
      a = (n+1)*s
      r = exp(n*log(q))
      x = 0
      u = pyrand(.false.)
      do while (.true.)
C         write(*, 14) u,  r
 14      format(">>> u = ", F8.6, "; r = ", F8.6)
         if (u < r) then
            randbn = x
            return
         else
            u = u - r
            x = x + 1
            r = r * (a/x) - s
         end if
      end do
      end function randbn

C  ******************************************************************************
C  *                                                                            *
C  *      Actual model code here, this should be interchangeable with SEIR      *
C  *                                                                            *
C  ******************************************************************************
      subroutine sir(u, params)
      double precision, dimension(0:3) :: u
      double precision, dimension(0:4) :: params
      double precision S, I, R, Y, beta, gamma, iota, N, delta_t
      double precision lambda, ifrac, rfrac, infection, recovery
      double precision randbn

      S = u(0)
      I = u(1)
      R = u(2)
      Y = u(3)
      
      beta = params(0)
      gamma = params(1)
      iota = params(2)
      N = params(3)
      delta_t = params(4)      

      lambda = beta * (I + iota) / N
      ifrac = 1.0 - exp(-lambda * delta_t)
      rfrac = 1.0 - exp(-gamma * delta_t)
      infection = randbn(S, ifrac)
      recovery = randbn(I, rfrac)

C     Set the return values
      u(0) = S - infection
      u(1) = I + infection - recovery
      u(2) = R + recovery
      u(3) = Y + infection

      end subroutine sir

C  ******************************************************************************
C  *                                                                            *
C  * Driver functions for the simulation, should be top level container in GrFN *
C  *                                                                            *
C  ******************************************************************************
      subroutine simulate()
      integer, parameter :: tf = 200
      integer, parameter :: tl = tf/0.1
      integer j
      double precision, dimension(0:tl) :: t, S, I, R, Y
      double precision, dimension(0:3) :: u0, u
      double precision, dimension(0:4) :: params, returns
      double precision tmp, pyrand

      tmp = pyrand(.true.)    ! initialize

      params = (/0.1, 0.05, 0.01, 1000.0, 0.1/)

      S = 0.0
      I = 0.0
      R = 0.0
      Y = 0.0

      u0 = (/999.0, 1.0, 0.0, 0.0/)
      S(0) = u0(0)
      I(0) = u0(1)
      R(0) = u0(2)
      Y(0) = u0(3)

      u = u0
C      do j = 1, tl
      do j = 1, 250
         call sir(u, params)
         S(j) = u(0)
         I(j) = u(1)
         R(j) = u(2)
         Y(j) = u(3)
      end do

C      do j = 1, tl
      do j = 1, 250
         write (*, 10) S(j)
      end do
 10   format(F8.2)
      
      end subroutine simulate

C  ******************************************************************************
C  *                                                                            *
C  *               Pretend to be Python's ramdon-number generator               *
C  *                                                                            *
C  ******************************************************************************
      double precision function pyrand(do_init)
      integer :: i, j
      double precision retval
      logical do_init

      ! pyrand_array stores the first N random numbers generated by Python
      integer, parameter :: N = 10000
      double precision, dimension(N) :: pyrand_array

      save

      if (do_init .eqv. .TRUE.) then        ! initialize
         open (2, file = 'PYTHON-RANDOM_SEQ')
         do j = 1, 1000
            read (2, 10) pyrand_array(j)
 10         format(F20.18)
         end do
         close(2)
         i = 0
         retval = 0.0
      else
         retval = pyrand_array(i)
      end if

      i = i + 1
      pyrand = retval

      end function pyrand
