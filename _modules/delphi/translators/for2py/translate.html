<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>delphi.translators.for2py.translate &mdash; delphi  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> delphi
            <img src="../../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_openapi.html">GrFN OpenAPI Specification</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">delphi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
          <li><a href="../for2py.html">delphi.translators.for2py</a> &raquo;</li>
      <li>delphi.translators.for2py.translate</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for delphi.translators.for2py.translate</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This script converts the XML version of AST of the Fortran</span>
<span class="sd">file into a JSON representation of the AST along with other</span>
<span class="sd">non-source code information. The output is a pickled file</span>
<span class="sd">which contains this information in a parsable data structure.</span>

<span class="sd">Example:</span>
<span class="sd">    This script is executed by the autoTranslate script as one</span>
<span class="sd">    of the steps in converted a Fortran source file to Python</span>
<span class="sd">    file. For standalone execution:::</span>

<span class="sd">        python translate.py -f &lt;ast_file&gt; -g &lt;pickle_file&gt; -i &lt;f_src_file&gt;</span>

<span class="sd">    where f_src_file is the Fortran source file for ast_file.</span>

<span class="sd">ast_file: The XML representation of the AST of the Fortran file. This is</span>
<span class="sd">produced by the OpenFortranParser.</span>

<span class="sd">pickle_file: The file which will contain the pickled version of JSON AST and</span>
<span class="sd">supporting information. &quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.get_comments</span> <span class="kn">import</span> <span class="n">get_comments</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.loop_handle</span> <span class="kn">import</span> <span class="n">RefactorConstructs</span>


<div class="viewcode-block" id="ParseState"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.ParseState">[docs]</a><span class="k">class</span> <span class="nc">ParseState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class defines the state of the XML tree parsing</span>
<span class="sd">    at any given root. For any level of the tree, it stores</span>
<span class="sd">    the subroutine under which it resides along with the</span>
<span class="sd">    subroutines arguments.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subroutine</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span> <span class="o">=</span> <span class="n">subroutine</span> <span class="k">if</span> <span class="n">subroutine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;args&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="ParseState.copy"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.ParseState.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subroutine</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ParseState</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subroutine</span> <span class="k">if</span> <span class="n">subroutine</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">subroutine</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="XML_to_JSON_translator"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator">[docs]</a><span class="k">class</span> <span class="nc">XML_to_JSON_translator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">libFns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cexp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cmplx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;acos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;asin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sqrt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span><span class="p">,</span>
            <span class="s2">&quot;len&quot;</span><span class="p">,</span>
            <span class="s2">&quot;adjustl&quot;</span><span class="p">,</span>
            <span class="s2">&quot;adjustr&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;access-spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;argument&quot;</span><span class="p">,</span>
            <span class="s2">&quot;assignment&quot;</span><span class="p">,</span>
            <span class="s2">&quot;call&quot;</span><span class="p">,</span>
            <span class="s2">&quot;close&quot;</span><span class="p">,</span>
            <span class="s2">&quot;component-decl&quot;</span><span class="p">,</span>
            <span class="s2">&quot;declaration&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dimensions&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exit&quot;</span><span class="p">,</span>
            <span class="s2">&quot;explicit-shape-spec-list__begin&quot;</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">,</span>
            <span class="s2">&quot;format-item&quot;</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">,</span>
            <span class="s2">&quot;if&quot;</span><span class="p">,</span>
            <span class="s2">&quot;index-variable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;io-control-spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword-argument&quot;</span><span class="p">,</span>
            <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loop&quot;</span><span class="p">,</span>
            <span class="s2">&quot;module&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;open&quot;</span><span class="p">,</span>
            <span class="s2">&quot;operation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;program&quot;</span><span class="p">,</span>
            <span class="s2">&quot;range&quot;</span><span class="p">,</span>
            <span class="s2">&quot;read&quot;</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">,</span>
            <span class="s2">&quot;stop&quot;</span><span class="p">,</span>
            <span class="s2">&quot;subroutine&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">,</span>
            <span class="s2">&quot;use&quot;</span><span class="p">,</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">,</span>
            <span class="s2">&quot;write&quot;</span><span class="p">,</span>
            <span class="s2">&quot;save-stmt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;saved-entity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;constants&quot;</span><span class="p">,</span>
            <span class="s2">&quot;interface&quot;</span><span class="p">,</span>
            <span class="s2">&quot;names&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;argument&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_argument</span><span class="p">,</span>
            <span class="s2">&quot;assignment&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_assignment</span><span class="p">,</span>
            <span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_call</span><span class="p">,</span>
            <span class="s2">&quot;close&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;declaration&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_declaration</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_dimension</span><span class="p">,</span>
            <span class="s2">&quot;exit&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;format-item&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_format_item</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_format</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_function</span><span class="p">,</span>
            <span class="s2">&quot;if&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_if</span><span class="p">,</span>
            <span class="s2">&quot;index-variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_index_variable</span><span class="p">,</span>
            <span class="s2">&quot;io-controls&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_io_control</span><span class="p">,</span>
            <span class="s2">&quot;keyword-argument&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_keyword_argument</span><span class="p">,</span>
            <span class="s2">&quot;literal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_literal</span><span class="p">,</span>
            <span class="s2">&quot;loop&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_loop</span><span class="p">,</span>
            <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_name</span><span class="p">,</span>
            <span class="s2">&quot;open&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;operation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_operation</span><span class="p">,</span>
            <span class="s2">&quot;program&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_range</span><span class="p">,</span>
            <span class="s2">&quot;read&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;stop&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_terminal</span><span class="p">,</span>
            <span class="s2">&quot;subroutine&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subroutine_or_program_module</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
            <span class="s2">&quot;use&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_use</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_variables</span><span class="p">,</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_variable</span><span class="p">,</span>
            <span class="s2">&quot;constants&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_constants</span><span class="p">,</span>
            <span class="s2">&quot;constant&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_constant</span><span class="p">,</span>
            <span class="s2">&quot;write&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_direct_map</span><span class="p">,</span>
            <span class="s2">&quot;derived-types&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_derived_types</span><span class="p">,</span>
            <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_length</span><span class="p">,</span>
            <span class="s2">&quot;save-stmt&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">,</span>
            <span class="s2">&quot;cycle&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_continue</span><span class="p">,</span>
            <span class="s2">&quot;select&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_select</span><span class="p">,</span>
            <span class="s2">&quot;case&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_case</span><span class="p">,</span>
            <span class="s2">&quot;value-range&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_value_range</span><span class="p">,</span>
            <span class="s2">&quot;interface&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_interface</span><span class="p">,</span>
            <span class="s2">&quot;argument-types&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_argument_types</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># unhandled xml tags in the current input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Dictionary to map all the variables defined in each function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Dictionary to map the arguments to their functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># String that holds the current function under context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Flag that specifies whether a SAVE statement has been encountered</span>
        <span class="c1"># in the subroutine/function or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Variable to hold the node of the SAVE statement to process at the</span>
        <span class="c1"># end of the subroutine/function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This list holds the nodes of the file handles that needs to be</span>
        <span class="c1"># SAVEd in the python translated code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Dictionary to hold the different loop constructs present with a loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_constructs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">break_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_list</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="XML_to_JSON_translator.process_subroutine_or_program_module"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_subroutine_or_program_module">[docs]</a>    <span class="k">def</span> <span class="nf">process_subroutine_or_program_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function should be the very first function to be called &quot;&quot;&quot;</span>
        <span class="n">subroutine</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">sub_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">subroutine</span><span class="p">)</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sub_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;members&quot;</span><span class="p">:</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sub_state</span><span class="p">)</span>

        <span class="c1"># Check if this subroutine had a save statement and if so, process</span>
        <span class="c1"># the saved node to add it to the ast</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span> <span class="s2">&quot;scope&quot;</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="s2">&quot;var_list&quot;</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">}]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_call">[docs]</a>    <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;call&gt; tag and its subelement &lt;name&gt;. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;call&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                <span class="n">call</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">call</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">call</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">call</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_argument"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_argument">[docs]</a>    <span class="k">def</span> <span class="nf">process_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;argument&gt; tag. It simply create a new AST</span>
<span class="sd">        list and copy the values (tag and attributes) to it.  &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;argument&quot;</span><span class="p">,</span> <span class="s2">&quot;The root must be &lt;argument&gt;&quot;</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span>
                <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_list</span>
        <span class="p">):</span>
            <span class="n">is_derived_type</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_derived_type</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>

        <span class="n">array_status</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span>
        <span class="c1"># If the root does not have any children, this argument tag is a</span>
        <span class="c1"># function argument variable. Otherwise, this argument is a named</span>
        <span class="c1"># argument to a function (E.g.: index(back = &quot;.true.&quot;))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;arg&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">,</span>
                 <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">array_status</span><span class="p">,</span>
                 <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                 <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">is_derived_type</span>
                 <span class="p">}</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Store each argument respective to the function it is defined in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                 <span class="n">var_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;arg&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">,</span> <span class="s2">&quot;is_array&quot;</span><span class="p">:</span>
                    <span class="n">array_status</span><span class="p">,</span> <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">is_derived_type</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_declaration"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_declaration">[docs]</a>    <span class="k">def</span> <span class="nf">process_declaration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;declaration&gt; tag and its sub-elements by</span>
<span class="sd">        recursively calling the appropriate functions for the target tag. &quot;&quot;&quot;</span>

        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">declared_variable</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;declaration&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;declaration&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span>\
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>

        <span class="c1"># Check if this is a parameter declaration under which case,</span>
        <span class="c1"># the declaration would be turned into an assignment operation</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;parameter&quot;</span><span class="p">:</span>
            <span class="n">parameter_assignment</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">parameter_assignment</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parameter_assignment</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_data_statements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>  <span class="c1"># Get the variable type</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
                    <span class="n">declared_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the current node is for declaring a derived type,</span>
                    <span class="c1"># every step from type declaration to variable (including</span>
                    <span class="c1"># array) declaration will be done in the</span>
                    <span class="c1"># &quot;process_derived_types&quot; function and return the completed</span>
                    <span class="c1"># AST list object back.  Thus, simply insert the received</span>
                    <span class="c1"># AST list object into the declared_variable object. No</span>
                    <span class="c1"># other work is done in the current function.</span>
                    <span class="n">declared_variable</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">declared_variable</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span>
                <span class="n">num_of_dimensions</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">num_of_dimensions</span><span class="p">,</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="c1"># Since we always want to access the last element of the list</span>
                <span class="c1"># that was added most recently (that is a currently handling</span>
                <span class="c1"># variable), add [-1] index to access it.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">declared_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="c1"># Declare variables based on the counts to handle the case</span>
                <span class="c1"># where a multiple variables declared under a single type</span>
                <span class="c1"># for index in range(int(node.attrib[&quot;count&quot;])):</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">combined</span> <span class="o">=</span> <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">combined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                        <span class="n">declared_variable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                            <span class="ow">and</span> <span class="n">declared_variable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">args</span>
                        <span class="p">):</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                                    <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">declared_variable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">][</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                                    <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">declared_variable</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;save-stmt&quot;</span>
                    <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;interface&quot;</span>
                    <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;names&quot;</span>
            <span class="p">):</span>
                <span class="n">declared_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># Create an exclusion list of all variables which are arguments</span>
        <span class="c1"># to the function/subroutine in context and to</span>
        <span class="c1"># function/subroutine names themselves</span>
        <span class="n">exclusion_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">):</span>
            <span class="n">exclusion_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]</span>
        <span class="n">exclusion_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">]))</span>

        <span class="c1"># Map each variable declaration to this parent</span>
        <span class="c1"># function/subroutine to keep a track of local variables</span>
        <span class="k">if</span> <span class="n">declared_variable</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">declared_variable</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">declared_variable</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span> <span class="ow">and</span>
                        <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_derived_type&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
                     <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span>
                                                  <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">declared_variable</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">declared_variable</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_type"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_type">[docs]</a>    <span class="k">def</span> <span class="nf">process_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;type&gt; declaration.</span>

<span class="sd">        There may be two different cases of &lt;type&gt;.</span>
<span class="sd">            (1) Simple variable type declaration</span>
<span class="sd">            (2) Derived type declaration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;type&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">derived_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">text</span>
        <span class="p">):</span>  <span class="c1"># Check if the &lt;type&gt; has sub-elements, which is the case of (2)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                    <span class="n">derived_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;character&quot;</span><span class="p">:</span>
                        <span class="n">string_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                            <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">string_length</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                                <span class="s2">&quot;is_derived_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                            <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">],</span>
                        <span class="p">}</span>
                        <span class="k">return</span> <span class="p">[</span><span class="n">declared_type</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_derived_type</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="s2">&quot;is_derived_type&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                            <span class="n">is_derived_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                                <span class="s2">&quot;is_derived_type&quot;</span>
                            <span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                        <span class="n">keyword2</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
                        <span class="k">if</span> <span class="s2">&quot;keyword2&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                            <span class="n">keyword2</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">]</span>
                        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">is_derived_type</span><span class="p">,</span>
                            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">keyword2</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="n">declared_type</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="k">return</span> <span class="p">[</span><span class="n">declared_type</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;derived-types&quot;</span><span class="p">:</span>
                    <span class="n">derived_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">derived_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;character&quot;</span><span class="p">:</span>
                <span class="c1"># Check if this is a string</span>
                <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;string_length&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_derived_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                    <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Else, this represents an empty element, which is the case</span>
                <span class="c1"># of (1)</span>
                <span class="n">declared_type</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_derived_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                    <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;keyword2&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">declared_type</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_length"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_length">[docs]</a>    <span class="k">def</span> <span class="nf">process_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;length&gt; tag.  &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;length&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
                <span class="n">length</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type-param-value&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                 <span class="s2">&quot;hasAsterisk&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="n">length</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">length</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_variables"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_variables">[docs]</a>    <span class="k">def</span> <span class="nf">process_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;variables&gt; element, which its duty is to</span>
<span class="sd">        call &lt;variable&gt; tag processor. &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;variables&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">variables</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will get called from the process_variables function, and</span>
<span class="sd">        it will construct the variable AST list, then return it back to the</span>
<span class="sd">        called function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;variable&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># First check if the variables are actually function names</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">is_array</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="n">variable</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">,</span> <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">is_array</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">is_array</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span>

            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;initial-value&quot;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span>
                        <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span>
                            <span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_constants"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_constants">[docs]</a>    <span class="k">def</span> <span class="nf">process_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;constants&gt; element, which its duty is to</span>
<span class="sd">        call &lt;constant&gt; tag processor&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;constants&quot;</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;constants&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">constants</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">constants</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_constant"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_constant">[docs]</a>    <span class="k">def</span> <span class="nf">process_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will get called from the process_constants function, and</span>
<span class="sd">        it will construct the constant AST list, then return it back to the</span>
<span class="sd">        called function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
                <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;constant&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">assign</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;assignment&quot;</span><span class="p">}</span>

        <span class="c1"># Populate the target field of the parameter assignment</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>  <span class="c1"># Default for a normal variable</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">],</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
            <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>  <span class="c1"># Default value of 1</span>
            <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>  <span class="c1"># Default of false</span>
            <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>  <span class="c1"># Default of false</span>
            <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">assign</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_derived_types"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_derived_types">[docs]</a>    <span class="k">def</span> <span class="nf">process_derived_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;derived-types&gt; tag nested in the &lt;type&gt; tag.</span>
<span class="sd">        Depends on the nested sub-elements of the tag, it will recursively call</span>
<span class="sd">        other tag processors.</span>

<span class="sd">        (1) Main type declaration</span>
<span class="sd">        (2) Single variable declaration (with initial values)</span>
<span class="sd">        (3) Array declaration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;derived-types&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;derived-type&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">derived_types</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;derived-types&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">declared_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handled_tags</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>  <span class="c1"># Get the variable type</span>
                <span class="n">declared_type</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="p">}</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                    <span class="n">dim_info</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;dimension&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="n">dim</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span>
                    <span class="p">}</span>
                    <span class="n">dimensions</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_info</span><span class="p">)</span>
                <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="c1"># Declare variables based on the counts to handle the case</span>
                <span class="c1"># where a multiple vars declared under a single type</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])):</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="n">declared_type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">combined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                    <span class="n">derived_types</span><span class="p">[</span><span class="s2">&quot;derived-types&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">derived_types</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_loop"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_loop">[docs]</a>    <span class="k">def</span> <span class="nf">process_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;loop type=&quot;&quot;&gt; tag.  The type attribute</span>
<span class="sd">        indicates the current loop is either &quot;do&quot; or &quot;do-while&quot; loop. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;loop&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;do&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">do</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;do&quot;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                    <span class="n">do</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                    <span class="n">do</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="kc">False</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unrecognized tag in the process_loop for &#39;do&#39; type.&quot;</span> \
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">do</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;do-while&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">do_while</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;do-while&quot;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                    <span class="n">do_while</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                    <span class="n">do_while</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">do_while</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_index_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_index_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_index_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;index-variable&gt; tag. This tag represents</span>
<span class="sd">        index ranges of loops or arrays. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;index-variable&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;index-variable&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;lower-bound&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;low&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;upper-bound&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;high&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;step&quot;</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ind</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_if"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_if">[docs]</a>    <span class="k">def</span> <span class="nf">process_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;if&gt; tag. Else and else if are nested under</span>
<span class="sd">        this tag. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;if&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ifs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curIf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                    <span class="n">curIf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;if&quot;</span><span class="p">}</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="n">ifs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curIf</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;else-if&quot;</span><span class="p">:</span>
                    <span class="n">newIf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;if&quot;</span><span class="p">}</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;else&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newIf</span><span class="p">]</span>
                    <span class="n">curIf</span> <span class="o">=</span> <span class="n">newIf</span>
                    <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;else&quot;</span>
            <span class="p">):</span>
                <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;else&quot;</span><span class="p">:</span>
                <span class="n">curIf</span><span class="p">[</span><span class="s2">&quot;else&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ifs</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;operation&gt; tag. The nested elements should</span>
<span class="sd">        either be &quot;operand&quot; or &quot;operator&quot;. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operation&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;operation&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;op&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operand&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;left&quot;</span> <span class="ow">in</span> <span class="n">op</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;operator&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;operator&quot;</span> <span class="ow">in</span> <span class="n">op</span><span class="p">:</span>
                    <span class="n">newOp</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;op&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;operator&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">op</span><span class="p">],</span>
                    <span class="p">}</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">newOp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">op</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;operator&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_literal"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_literal">[docs]</a>    <span class="k">def</span> <span class="nf">process_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;literal&gt; tag &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;literal&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;pause-stmt&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;pause&quot;</span><span class="p">,</span> <span class="s2">&quot;msg&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]}]</span>
            <span class="k">elif</span> <span class="n">info</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;stop&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">text</span><span class="p">}]</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_io_control"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_io_control">[docs]</a>    <span class="k">def</span> <span class="nf">process_io_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function checks for an asterisk in the argument of a</span>
<span class="sd">        read/write statement and stores it if found.  An asterisk in the first</span>
<span class="sd">        argument specifies a input through or output to console.  An asterisk</span>
<span class="sd">        in the second argument specifies a read/write without a format</span>
<span class="sd">        (implicit read/writes).  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;io-controls&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;io-controls&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">io_control</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasExpression&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="s2">&quot;hasExpression&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasExpression&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                <span class="p">),</span> <span class="s2">&quot;hasExpression is false. Something is wrong.&quot;</span>
                <span class="n">io_control</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasAsterisk&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                <span class="p">),</span> <span class="s2">&quot;hasAsterisk is false. Something is wrong.&quot;</span>
                <span class="n">io_control</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">}</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="n">io_control</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_name">[docs]</a>    <span class="k">def</span> <span class="nf">process_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;name&gt; tag. The name tag will be added to the</span>
<span class="sd">        new AST for the pyTranslate.py with &quot;ref&quot; tag.  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;name&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">libFns</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="c1"># and state.subroutine[&quot;tag&quot;] != &quot;function&quot;</span>
        <span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># numPartRef represents the number of references in the name.</span>
            <span class="c1"># Default = 1</span>
            <span class="n">numPartRef</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
            <span class="c1"># For example, numPartRef of x is 1 while numPartRef of</span>
            <span class="c1"># x.y is 2, etc.</span>
            <span class="k">if</span> <span class="s2">&quot;numPartRef&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">numPartRef</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;numPartRef&quot;</span><span class="p">]</span>

            <span class="n">is_array</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;is_array&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">is_array</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">numPartRef</span><span class="p">),</span>
                <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">],</span>
                <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="n">is_array</span><span class="p">,</span>
                <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            <span class="c1"># Check whether the passed element is for derived type reference</span>
            <span class="k">if</span> <span class="s2">&quot;is_derived_type_ref&quot;</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
            <span class="c1"># Handling derived type references</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPartRef</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                        <span class="n">nextRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">ref</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">nextRef</span><span class="p">})</span>

            <span class="c1"># Handling arrays</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;subscripts&quot;</span><span class="p">:</span>
                        <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;argument-types&quot;</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;is_interface_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
                    <span class="n">ref</span><span class="p">[</span><span class="s2">&quot;func_arg_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_argument_types"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_argument_types">[docs]</a>    <span class="k">def</span> <span class="nf">process_argument_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function handles &lt;argument-types&gt; tag that only appears</span>
<span class="sd">        under the interface function names. It will extract the argument</span>
<span class="sd">        types and add to the list, then return the list&quot;&quot;&quot;</span>
        <span class="n">argument_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">argument_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">argument_types</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_assignment"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">process_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;assignment&gt; tag that nested elements of</span>
<span class="sd">        &lt;target&gt; and &lt;value&gt;. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;assignment&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;assignment&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">assign</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;assignment&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
                <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="n">search_for_functions</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;op&quot;</span><span class="p">,</span>
                                                                       <span class="s2">&quot;call&quot;</span><span class="p">]:</span>
            <span class="n">search_for_functions</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">extra_tags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If the assignment is to the function/subroutine name,</span>
        <span class="c1"># then this is a return value. So, create a dummy variable and assign</span>
        <span class="c1"># the value to it. Then, return this dummy variable</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">state</span><span class="o">.</span><span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="c1"># Create the dummy variable name</span>
            <span class="n">dummy_variable</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">_return&#39;</span>
            <span class="c1"># We need to make sure that this dummy variable is not already</span>
            <span class="c1"># present in this module scope. If it is, throw and error for now</span>
            <span class="n">check_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">):</span>
                <span class="n">check_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">):</span>
                <span class="n">check_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dummy_variable</span> <span class="ow">in</span> <span class="n">check_list</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Return variable name is already present, &quot;</span> \
                              <span class="s2">&quot;choose a different name.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">[</span><span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]][</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;CHARACTER&quot;</span><span class="p">:</span>
                    <span class="n">is_string</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_string</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
                <span class="c1"># If the dummy variable is not present, then create a new</span>
                <span class="c1"># variable and then add it</span>
                <span class="n">variable_spec</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">return_type</span><span class="p">,</span>
                    <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="n">is_string</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">dummy_variable</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span>
                <span class="p">}</span>
                <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">dummy_variable</span><span class="p">,</span>
                    <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
                <span class="p">}</span>
                <span class="n">return_spec</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ret&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">dummy_variable</span><span class="p">,</span>
                    <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">search_for_functions</span><span class="p">:</span>
                    <span class="n">extra_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_function_call</span><span class="p">(</span><span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">extra_tags</span> <span class="o">+</span> <span class="p">[</span><span class="n">variable_spec</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">return_spec</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">search_for_functions</span><span class="p">:</span>
                <span class="n">extra_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_function_call</span><span class="p">(</span><span class="n">assign</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">extra_tags</span> <span class="o">+</span> <span class="p">[</span><span class="n">assign</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_function"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_function">[docs]</a>    <span class="k">def</span> <span class="nf">process_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;function&gt; tag.  &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;function&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with&quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">subroutine</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summaries</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;is_arg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">sub_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">subroutine</span><span class="p">)</span>
                <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sub_state</span><span class="p">)</span>

        <span class="c1"># Check if this subroutine had a save statement and if so, process</span>
        <span class="c1"># the saved node to add it to the ast</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
            <span class="n">subroutine</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span>
                <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span>
                <span class="s2">&quot;var_list&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span>
            <span class="p">}]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">asts</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subroutine</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_dimension"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">process_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;dimension&gt; tag. This is a tag that holds</span>
<span class="sd">        information about the array, such as the range and values. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dimension&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;dimension&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;range&quot;</span><span class="p">:</span>
                <span class="n">dimension</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
                <span class="n">dimension</span><span class="p">[</span><span class="s2">&quot;literal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                <span class="n">dimension_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dimension</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;dimension&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dimension</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_range"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_range">[docs]</a>    <span class="k">def</span> <span class="nf">process_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;range&gt; tag.  &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;range&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;range&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">ran</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;lower-bound&quot;</span><span class="p">:</span>
                <span class="n">ran</span><span class="p">[</span><span class="s2">&quot;low&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;upper-bound&quot;</span><span class="p">:</span>
                <span class="n">ran</span><span class="p">[</span><span class="s2">&quot;high&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ran</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_keyword_argument"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_keyword_argument">[docs]</a>    <span class="k">def</span> <span class="nf">process_keyword_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;keyword-argument&gt; tag. &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;keyword-argument&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;keyword-argument&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;argument-name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;arg_name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;argument-name&quot;</span><span class="p">]}]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_libRtn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_libRtn">[docs]</a>    <span class="k">def</span> <span class="nf">process_libRtn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;call&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_direct_map"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_direct_map">[docs]</a>    <span class="k">def</span> <span class="nf">process_direct_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Handles tags that are mapped directly from xml to IR with no</span>
<span class="sd">        additional processing other than recursive translation of any child</span>
<span class="sd">        nodes.&quot;&quot;&quot;</span>

        <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">val</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># If the node is a file OPEN node, save it so that it can later be</span>
        <span class="c1"># added to the SAVE node in the ast</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;open&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span> <span class="o">+=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_terminal"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">process_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Handles tags that terminate the computation of a</span>
<span class="sd">        program unit, namely, &quot;return&quot;, &quot;stop&quot;, and &quot;exit&quot; &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;exit&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">break_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_index</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop_constructs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;loop&quot;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;break_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">break_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_index</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop_constructs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;loop&quot;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">return_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_format"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_format">[docs]</a>    <span class="k">def</span> <span class="nf">process_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;format&gt; tag. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;format&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The root must be &lt;format&gt;. Current tag is </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> with &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="si">}</span><span class="s2"> attributes.&quot;</span>
        <span class="n">format_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span>
                <span class="n">format_spec</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;lbl&quot;</span><span class="p">]</span>
            <span class="n">format_spec</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">format_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_format_item"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_format_item">[docs]</a>    <span class="k">def</span> <span class="nf">process_format_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function handles &lt;format-item&gt; tag. &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;format-item&quot;</span><span class="p">,</span> <span class="s2">&quot;The root must be &lt;format-item&gt;&quot;</span>
        <span class="n">variable_spec</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char&quot;</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;descOrDigit&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_use"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_use">[docs]</a>    <span class="k">def</span> <span class="nf">process_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function adds the tag for use statements</span>
<span class="sd">            In case of &quot;USE .. ONLY ..&quot; statements, the symbols to be included</span>
<span class="sd">            are stored in the &quot;include&quot; field of the &quot;use&quot; block</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tag_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;use&quot;</span><span class="p">,</span> <span class="s2">&quot;arg&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;only&quot;</span><span class="p">:</span>
                <span class="n">tag_spec</span><span class="p">[</span><span class="s2">&quot;include&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                        <span class="n">tag_spec</span><span class="p">[</span><span class="s2">&quot;include&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tag_spec</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="XML_to_JSON_translator.process_private_variable"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_private_variable">[docs]</a>    <span class="k">def</span> <span class="nf">process_private_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; This function adds the tag for private symbols. Any</span>
<span class="sd">        variable/function being initialized as private is added in this tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;private&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()}]</span>

        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_save"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_save">[docs]</a>    <span class="k">def</span> <span class="nf">process_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function parses the XML tag for the Fortran save statement and</span>
<span class="sd">        adds the tag that holds the function under which SAVE has been</span>
<span class="sd">        defined along with the variables that are saved by this statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If is_save is False, the SAVE statement has been encountered for</span>
        <span class="c1"># the first time in the particular subroutine/function in context.</span>
        <span class="c1"># Here, change the flag value and save the SAVE node.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_save</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_node</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This block will be entered when a SAVE statement is present</span>
            <span class="c1"># and its corresponding ast node has to be added at the end of</span>
            <span class="c1"># the subroutine/function body. Here the saved SAVE node</span>
            <span class="c1"># is processed as root.</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;hasSavedEntityList&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span>
                            <span class="n">var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span><span class="p">:</span>
                <span class="n">var_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_filehandle</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;save&quot;</span><span class="p">,</span> <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">,</span> <span class="s2">&quot;var_list&quot;</span><span class="p">:</span>
                    <span class="n">var_list</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_continue"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_continue">[docs]</a>    <span class="k">def</span> <span class="nf">process_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function handles cycle (continue in Python)</span>
<span class="sd">           tag.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_constructs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;loop&quot;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cycle_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cycle_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle_index</span><span class="p">}]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_select"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_select">[docs]</a>    <span class="k">def</span> <span class="nf">process_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function handles select statements tag.&quot;&quot;&quot;</span>
        <span class="n">select_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;select&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="n">select_spec</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">select_spec</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">select_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_case"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_case">[docs]</a>    <span class="k">def</span> <span class="nf">process_case</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function handles the CASE statement in Fortran. This should</span>
<span class="sd">        be modeled as an if-else statement in languages like Python</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">case_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;case&quot;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;header&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;value-ranges&quot;</span><span class="p">:</span>
                        <span class="n">case_spec</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unhandled type </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2"> in case&quot;</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
                <span class="n">case_spec</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">case_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_value_range"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_value_range">[docs]</a>    <span class="k">def</span> <span class="nf">process_value_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function handles the range of values inside CASE statements&quot;&quot;&quot;</span>
        <span class="n">value_range_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;case_range&quot;</span><span class="p">,</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                <span class="n">value_range_spec</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">value_range_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.process_interface"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.process_interface">[docs]</a>    <span class="k">def</span> <span class="nf">process_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;This function definition is simply a place holder for INTERFACE</span>
<span class="sd">        just in case of any possible usage in the future. For now, it does</span>
<span class="sd">        nothing when translate.py encountrs interface tag in the rectified</span>
<span class="sd">        xml.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.handle_data_statements"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.handle_data_statements">[docs]</a>    <span class="k">def</span> <span class="nf">handle_data_statements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function handles the data statements that occurs in the</span>
<span class="sd">        declaration tag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The main list of assignment inside a single data statement</span>
        <span class="n">assignment_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmp_assign</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_var_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Iterate over each node in the data statement</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
            <span class="c1"># The &#39;variable&#39; tag must always come first, followed by the</span>
            <span class="c1"># `value` tag and then possible other `variable-value` pairs</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span>
                <span class="c1"># Transfer everything from the previous `variable-value`</span>
                <span class="c1"># assignment into the main list</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_assign</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tmp_assign</span><span class="p">:</span>
                        <span class="n">assignment_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="n">tmp_assign</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># Get the number of variables being assigned</span>
                <span class="n">current_var_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])</span>
                <span class="c1"># For every variable, create an assignment ast and fill it up</span>
                <span class="c1"># with the `tag` and `target` information</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">assign</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;assignment&quot;</span>
                    <span class="n">assign</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="n">tmp_assign</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assign</span><span class="p">)</span>
            <span class="c1"># The `values` tag will come after the `variables` tag and assign</span>
            <span class="c1"># values to the respective variables</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;values&quot;</span><span class="p">:</span>
                <span class="c1"># Get the number of values present</span>
                <span class="n">current_value_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])</span>
                <span class="c1"># If for every variable, there is a value assignment i.e.</span>
                <span class="c1"># one-to-one E.g. data x,y,z /1,2,3*2/ (z is an array)</span>
                <span class="c1"># TODO: Not handled -&gt; data x(1) /2/ where x is an array of</span>
                <span class="c1">#  dimension &gt; 1</span>
                <span class="k">if</span> <span class="n">current_value_count</span> <span class="o">==</span> <span class="n">current_var_count</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># Check if this value assignment is for an array</span>
                        <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                            <span class="c1"># Check if only one value is assigned or if it is</span>
                            <span class="c1"># a range of values using the &#39;*&#39; operator</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                        <span class="s2">&quot;subscripts&quot;</span><span class="p">):</span>
                                    <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                        <span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                        <span class="p">{</span>
                                            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
                                        <span class="p">}]</span>
                                    <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                        <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
                                <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># If a single array is assigned multiple same</span>
                                <span class="c1"># values using an &#39;*&#39; operator, create a</span>
                                <span class="c1"># do-while loop to assign each index</span>
                                <span class="n">variable_name</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
                                    <span class="k">if</span> <span class="n">var_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">variable_name</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_name</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                            <span class="n">dimension</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">var_name</span><span class="p">[</span>
                                                            <span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                            <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                            <span class="s2">&quot;value&quot;</span><span class="p">]))</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">dimension</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">var_name</span><span class="p">[</span>
                                                            <span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                            <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                            <span class="s2">&quot;value&quot;</span><span class="p">]),</span>
                                                         <span class="nb">int</span><span class="p">(</span><span class="n">var_name</span><span class="p">[</span>
                                                            <span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span>
                                                            <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                            <span class="s2">&quot;value&quot;</span><span class="p">]))</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">array_ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_1d_array_ast</span><span class="p">(</span>
                                        <span class="n">var</span><span class="p">,</span>
                                        <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                        <span class="n">state</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">array_ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_2d_array_ast</span><span class="p">(</span>
                                        <span class="n">var</span><span class="p">,</span>
                                        <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                        <span class="n">dimension</span><span class="p">,</span>
                                        <span class="n">state</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_ast</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_ast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">tmp_assign</span> <span class="o">=</span> <span class="n">tmp_assign</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span> \
                                                 <span class="o">+</span> <span class="n">array_ast</span> \
                                                 <span class="o">+</span> <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                                    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># For every respective variable, assign the `value`</span>
                            <span class="c1"># information into the AST</span>
                            <span class="n">tmp_assign</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the number of values is more than the number of</span>
                    <span class="c1"># variables, the variable assignment includes an array</span>
                    <span class="c1"># assignment of the form: DATA X /1,2,3,4/ where X has a</span>
                    <span class="c1"># dimension of 4</span>
                    <span class="n">value_index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">loop_limit</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">array_assign</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">tmp_assign</span><span class="p">:</span>
                        <span class="n">variable_name</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                        <span class="n">is_array</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;is_array&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">is_array</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">variable_name</span><span class="p">:</span>
                                    <span class="c1"># This is very hard-coded. What other</span>
                                    <span class="c1"># kinds of dimensions are present other</span>
                                    <span class="c1"># than in literal forms?</span>
                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                        <span class="n">dimension</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                             <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                             <span class="s2">&quot;value&quot;</span><span class="p">])]</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">dimension</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                             <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                             <span class="s2">&quot;value&quot;</span><span class="p">]),</span>
                                                     <span class="nb">int</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span>
                                                             <span class="s2">&quot;literal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                                                             <span class="s2">&quot;value&quot;</span><span class="p">])]</span>
                            <span class="n">arr_index</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">two_dim_arr</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">row_count</span> <span class="o">=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">column_count</span> <span class="o">=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">current_row</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">current_column</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">two_dim_arr</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">two_dim_arr</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">arr_index</span> <span class="o">&gt;=</span> <span class="n">row_count</span> <span class="o">*</span> <span class="n">column_count</span><span class="p">:</span>
                                        <span class="k">break</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">arr_index</span> <span class="o">&gt;=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                        <span class="k">break</span>
                                <span class="n">arr_target</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">two_dim_arr</span><span class="p">:</span>
                                    <span class="n">arr_target</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                        <span class="p">{</span>
                                            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_row</span><span class="p">)</span>
                                        <span class="p">},</span>
                                        <span class="p">{</span>
                                            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_column</span><span class="p">)</span>
                                        <span class="p">}</span>
                                    <span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">arr_target</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                        <span class="p">{</span>
                                            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">arr_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                        <span class="p">}]</span>
                                <span class="n">arr_target</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="s2">&quot;true&quot;</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">arr_target</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                        <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
                                    <span class="n">array_assign</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_target</span><span class="p">)</span>
                                    <span class="n">value_index</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">loop_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">loop_limit</span> <span class="o">=</span> \
                                            <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">]</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                                                    <span class="s2">&quot;value&quot;</span><span class="p">])</span>
                                    <span class="n">arr_target</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                        <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">state</span><span class="p">)</span>
                                    <span class="n">array_assign</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_target</span><span class="p">)</span>
                                    <span class="n">loop_limit</span> <span class="o">-=</span> <span class="mi">1</span>
                                    <span class="k">if</span> <span class="n">loop_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">value_index</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">if</span> <span class="n">two_dim_arr</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">current_row</span> <span class="o">==</span> <span class="n">row_count</span><span class="p">:</span>
                                        <span class="n">current_row</span> <span class="o">=</span> <span class="mi">1</span>
                                        <span class="n">current_column</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">arr_index</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
                                <span class="n">array_assign</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                                <span class="n">value_index</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">loop_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">loop_limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">]</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span>
                                                         <span class="s2">&quot;value&quot;</span><span class="p">])</span>
                                <span class="n">variable</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">value_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
                                <span class="n">array_assign</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                                <span class="n">loop_limit</span> <span class="o">-=</span> <span class="mi">1</span>
                                <span class="k">if</span> <span class="n">loop_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">value_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">tmp_assign</span> <span class="o">=</span> <span class="n">array_assign</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tmp_assign</span><span class="p">:</span>
            <span class="n">assignment_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assignment_list</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.create_1d_array_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.create_1d_array_ast">[docs]</a>    <span class="k">def</span> <span class="nf">create_1d_array_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">assign_ast</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates the do-while loop ast which assigns values to</span>
<span class="sd">        a one-dimensional array according to the data statement operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, we need a variable for the iteration. Check if an integer</span>
        <span class="c1"># variable &#39;iterator&#39; has already been defined. If yes, use it,</span>
        <span class="c1"># else define it</span>
        <span class="n">array_ast</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iterator_ast</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">iterator_ast</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
            <span class="n">array_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iterator_ast</span><span class="p">)</span>

        <span class="c1"># Now, define the do-while loop</span>
        <span class="n">do_ast</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">do_ast</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;do&quot;</span>
        <span class="n">do_ast</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;low&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
            <span class="p">}],</span>
            <span class="s2">&quot;high&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="p">}]</span>
            <span class="p">}</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subscripts&quot;</span><span class="p">):</span>
            <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;iterator&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
                <span class="p">}]</span>
            <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
        <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
        <span class="n">do_ast</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">assign_ast</span><span class="p">]</span>

        <span class="n">array_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_ast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array_ast</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.create_2d_array_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.create_2d_array_ast">[docs]</a>    <span class="k">def</span> <span class="nf">create_2d_array_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">assign_ast</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates the do-while loop ast which assigns values to a</span>
<span class="sd">        two-dimensional array according to the data statement operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, we need a variable for the iteration. Check if an integer</span>
        <span class="c1"># variable &#39;i_iterator&#39; has already been defined. If yes, use it,</span>
        <span class="c1"># else define it. Do the same for &#39;j_iterator&#39;</span>
        <span class="n">array_ast</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i_iterator_ast</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;i_iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">i_iterator_ast</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
            <span class="n">array_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_iterator_ast</span><span class="p">)</span>

        <span class="n">j_iterator_ast</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;j_iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">j_iterator_ast</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_module</span><span class="p">]:</span>
            <span class="n">array_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j_iterator_ast</span><span class="p">)</span>

        <span class="c1"># Now, define the inner do-while loop first</span>
        <span class="n">inner_do_ast</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">inner_do_ast</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;do&quot;</span>
        <span class="n">inner_do_ast</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;j_iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;low&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
            <span class="p">}],</span>
            <span class="s2">&quot;high&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">dimension</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">}]</span>
        <span class="p">}</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subscripts&quot;</span><span class="p">):</span>
            <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;i_iterator&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                    <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;j_iterator&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
                <span class="p">}</span>
            <span class="p">]</span>
            <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;hasSubscripts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
        <span class="n">assign_ast</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
        <span class="n">inner_do_ast</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">assign_ast</span><span class="p">]</span>

        <span class="c1"># Now the outer do-while loop</span>
        <span class="n">outer_do_ast</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">outer_do_ast</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;do&quot;</span>
        <span class="n">outer_do_ast</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;i_iterator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;low&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
            <span class="p">}],</span>
            <span class="s2">&quot;high&quot;</span><span class="p">:</span> <span class="p">[{</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">}]</span>
        <span class="p">}</span>
        <span class="p">]</span>
        <span class="n">outer_do_ast</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">inner_do_ast</span><span class="p">]</span>
        <span class="n">array_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outer_do_ast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array_ast</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.check_function_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.check_function_call">[docs]</a>    <span class="k">def</span> <span class="nf">check_function_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function checks whether there is a function call in the</span>
<span class="sd">            value of an assignment. If there is one, remove the function</span>
<span class="sd">            call into a separate assignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extra_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span>
                    <span class="n">extra_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_function_call</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span><span class="p">:</span>
                    <span class="n">extra_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initiate_function_replacement</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                                                                     <span class="s2">&quot;left&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span>
                    <span class="n">extra_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_function_call</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span><span class="p">:</span>
                    <span class="n">extra_tags</span> <span class="o">+=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">initiate_function_replacement</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span><span class="p">:</span>
            <span class="n">extra_tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initiate_function_replacement</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                                                                 <span class="s2">&quot;args&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">extra_tags</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.initiate_function_replacement"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.initiate_function_replacement">[docs]</a>    <span class="k">def</span> <span class="nf">initiate_function_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_tag</span><span class="p">):</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">function_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">function_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">:</span>
                <span class="n">function_arguments</span> <span class="o">=</span> <span class="n">function_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;args&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">function_arguments</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span><span class="p">:</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initiate_function_replacement</span><span class="p">([</span><span class="n">arg</span><span class="p">])</span>
                        <span class="n">tags</span> <span class="o">+=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">function_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;args&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">function_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;args&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_function_call</span><span class="p">(</span><span class="n">function_tag</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tags</span><span class="p">,</span> <span class="n">function_tag</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.replace_function_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.replace_function_call">[docs]</a>    <span class="k">def</span> <span class="nf">replace_function_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">function_name</span><span class="p">):</span>
        <span class="n">call_spec</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">[</span><span class="n">function_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()][</span><span class="s1">&#39;call_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">function_name_tail</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">[</span><span class="n">function_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;CHARACTER&quot;</span><span class="p">:</span>
            <span class="n">is_string</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_string</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
        <span class="n">call_var</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">return_type</span><span class="p">,</span>
            <span class="s2">&quot;is_derived_type&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;keyword2&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_string&quot;</span><span class="p">:</span> <span class="n">is_string</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">function_name_tail</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">}</span>
        <span class="n">target_var</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">function_name_tail</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;numPartRef&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hasSubscripts&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_array&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_interface_func&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span>
            <span class="s2">&quot;func_arg_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;is_derived_type_ref&quot;</span><span class="p">:</span> <span class="s2">&quot;false&quot;</span>
        <span class="p">}</span>
        <span class="n">assignment_tag</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="s2">&quot;assignment&quot;</span><span class="p">,</span>
            <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">target_var</span><span class="p">],</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">call_spec</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_var</span>
        <span class="n">extra_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">call_var</span><span class="p">,</span> <span class="n">assignment_tag</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">extra_tags</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.parseTree"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.parseTree">[docs]</a>    <span class="k">def</span> <span class="nf">parseTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ParseState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the XML ast tree recursively to generate a JSON AST</span>
<span class="sd">        which can be ingested by other scripts to generate Python</span>
<span class="sd">        scripts.</span>

<span class="sd">        Args:</span>
<span class="sd">            root: The current root of the tree.</span>
<span class="sd">            state: The current state of the tree defined by an object of the</span>
<span class="sd">                ParseState class.</span>

<span class="sd">        Returns:</span>
<span class="sd">                ast: A JSON ast that defines the structure of the Fortran file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_tag_handlers</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">](</span><span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">libRtns</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_libRtn</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">prog</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">prog</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prog</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.loadFunction"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.loadFunction">[docs]</a>    <span class="k">def</span> <span class="nf">loadFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a list with all the functions in the Fortran File</span>

<span class="sd">        Args:</span>
<span class="sd">            root: The root of the XML ast tree.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Does not return anything but populates two lists (self.functionList</span>
<span class="sd">        and self.subroutineList) that contains all the functions and</span>
<span class="sd">        subroutines in the Fortran File respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;declaration&quot;</span> <span class="ow">and</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                    <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                <span class="n">return_type</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">[</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">return_type</span><span class="p">,</span>
                    <span class="s1">&#39;call_count&#39;</span><span class="p">:</span> <span class="mi">0</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;subroutine&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.analyze"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.analyze">[docs]</a>    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">outputDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Parse through the ast once to identify and grab all the functions</span>
        <span class="c1"># present in the Fortran file.</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadFunction</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="c1"># Parse through the ast tree a second time to convert the XML ast</span>
        <span class="c1"># format to a format that can be used to generate Python statements.</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="n">ast</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">ParseState</span><span class="p">())</span>

        <span class="c1"># print(ast)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the entry point for the Fortran file.</span>
<span class="sd">        The entry point for a conventional Fortran file is always the PROGRAM</span>
<span class="sd">        section. This &#39;if&#39; statement checks for the presence of a PROGRAM</span>
<span class="sd">        segment.</span>

<span class="sd">        If not found, the entry point can be any of the functions or</span>
<span class="sd">        subroutines in the file. So, all the functions and subroutines of the</span>
<span class="sd">        program are listed and included as the possible entry point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;program&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;subroutine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subroutineList</span>

        <span class="c1"># Load the functions list and Fortran ast to a single data structure</span>
        <span class="c1"># which can be pickled and hence is portable across various scripts and</span>
        <span class="c1"># usages.</span>
        <span class="n">outputDict</span><span class="p">[</span><span class="s2">&quot;ast&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="n">outputDict</span><span class="p">[</span><span class="s2">&quot;functionList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functionList</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">outputDict</span></div>

<div class="viewcode-block" id="XML_to_JSON_translator.print_unhandled_tags"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.XML_to_JSON_translator.print_unhandled_tags">[docs]</a>    <span class="k">def</span> <span class="nf">print_unhandled_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: input contains the following unhandled tags:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unhandled_tags</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_trees"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.get_trees">[docs]</a><span class="k">def</span> <span class="nf">get_trees</span><span class="p">(</span><span class="n">files</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span></div>


<div class="viewcode-block" id="xml_to_py"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.xml_to_py">[docs]</a><span class="k">def</span> <span class="nf">xml_to_py</span><span class="p">(</span><span class="n">trees</span><span class="p">):</span>
    <span class="n">translator</span> <span class="o">=</span> <span class="n">XML_to_JSON_translator</span><span class="p">()</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="n">translator</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>

    <span class="c1"># Only go through with the handling of breaks and returns if they are</span>
    <span class="c1"># actually there</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">translator</span><span class="o">.</span><span class="n">loop_constructs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">refactor_breaks</span> <span class="o">=</span> <span class="n">RefactorConstructs</span><span class="p">()</span>
        <span class="n">output_dict</span> <span class="o">=</span> <span class="n">refactor_breaks</span><span class="o">.</span><span class="n">refactor</span><span class="p">(</span><span class="n">output_dict</span><span class="p">,</span>
                                               <span class="n">translator</span><span class="o">.</span><span class="n">loop_constructs</span><span class="p">)</span>

    <span class="c1"># print_unhandled_tags() was originally intended to alert us to program</span>
    <span class="c1"># constructs we were not handling.  It isn&#39;t clear we actually use this</span>
    <span class="c1"># so I&#39;m commenting out this call for now.  Eventually this code (and all </span>
    <span class="c1"># the code that keeps track of unhandled tags) should go away.</span>
    <span class="c1"># --SKD 06/2019</span>
    <span class="c1"># translator.print_unhandled_tags()</span>

    <span class="k">return</span> <span class="n">output_dict</span></div>


<div class="viewcode-block" id="parse_args"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.parse_args">[docs]</a><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Parse the arguments passed to the script.  Returns a tuple</span>
<span class="sd">        (fortran_file, pickle_file, args) where fortran_file is the</span>
<span class="sd">        file containing the input Fortran code, and pickle_file is</span>
<span class="sd">        the output pickle file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--gen&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Pickled version of routines for which dependency graphs should &quot;</span>
             <span class="s2">&quot;be generated&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--files&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A list of AST files in XML format to analyze&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;--input&quot;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Original Fortran Source code file.&quot;</span>
    <span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">fortran_file</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pickle_file</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fortran_file</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">,</span> <span class="n">args</span></div>


<div class="viewcode-block" id="gen_pickle_file"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.translate.gen_pickle_file">[docs]</a><span class="k">def</span> <span class="nf">gen_pickle_file</span><span class="p">(</span><span class="n">output_dictionary</span><span class="p">,</span> <span class="n">pickle_filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output_dictionary</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="p">(</span><span class="n">fortran_file</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">get_trees</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

    <span class="n">output_dict</span> <span class="o">=</span> <span class="n">xml_to_py</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">)</span>

    <span class="n">gen_pickle_file</span><span class="p">(</span><span class="n">output_dict</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Adarsh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>