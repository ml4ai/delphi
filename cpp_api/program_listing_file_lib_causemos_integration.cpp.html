<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File causemos_integration.cpp &mdash; delphi  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> delphi
            <img src="../_static/delphi_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grfn_spec.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grfn_openapi.html">GrFN OpenAPI Specification</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">delphi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Program Listing for File causemos_integration.cpp</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/cpp_api/program_listing_file_lib_causemos_integration.cpp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-causemos-integration-cpp">
<span id="program-listing-file-lib-causemos-integration-cpp"></span><h1>Program Listing for File causemos_integration.cpp<a class="headerlink" href="#program-listing-for-file-causemos-integration-cpp" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_lib_causemos_integration.cpp.html#file-lib-causemos-integration-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">lib/causemos_integration.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// CauseMos integration methods</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;AnalysisGraph.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;utils.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fmt/format.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;range/v3/all.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits.h&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">delphi</span><span class="o">::</span><span class="nn">utils</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">fmt</span><span class="o">::</span><span class="nn">literals</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">============================================================================</span>
<span class="cm">Private: Integration with Uncharted&#39;s CauseMos interface</span>
<span class="cm">============================================================================</span>
<span class="cm">*/</span><span class="w"></span>

<span class="w">            </span><span class="cm">/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm">                         create-model (private)</span>
<span class="cm">            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">AnalysisGraph::extract_concept_indicator_mapping_and_observations_from_json</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">json_indicators</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ConceptIndicatorData</span><span class="w"> </span><span class="o">&amp;</span><span class="n">concept_indicator_data</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ConceptIndicatorEpochs</span><span class="w"> </span><span class="o">&amp;</span><span class="n">concept_indicator_epochs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_verts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">num_vertices</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_end_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_verts</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">v</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// At the moment we are only attaching one indicator per node</span>
<span class="w">        </span><span class="c1">// when Analysis graph is called through CauseMos</span>
<span class="w">        </span><span class="n">string</span><span class="w"> </span><span class="n">indicator_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Qualitative measure of {}&quot;</span><span class="n">_format</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">string</span><span class="w"> </span><span class="n">indicator_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Delphi&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">json_indicators</span><span class="p">[</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// In this case we do not have any observation data to train the model</span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">set_indicator</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_source</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">n</span><span class="p">.</span><span class="n">get_indicator</span><span class="p">(</span><span class="n">indicator_name</span><span class="p">).</span><span class="n">set_mean</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// TODO: At the moment the json file specifies one indicator per</span>
<span class="w">        </span><span class="c1">// concept. At a later time if we update the json file to specify</span>
<span class="w">        </span><span class="c1">// multiple indicators per concept, this is one place we have to</span>
<span class="w">        </span><span class="c1">// update. Instead of a single indicator, we might get a list of</span>
<span class="w">        </span><span class="c1">// indicators here. Rest of the code would have to be updated</span>
<span class="w">        </span><span class="c1">// according to whatever the updated json file format we come up with.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">indicator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json_indicators</span><span class="p">[</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">indicator</span><span class="p">[</span><span class="s">&quot;source&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">indicator_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indicator</span><span class="p">[</span><span class="s">&quot;source&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indicator</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// This case there could be observations. However we are discarding</span>
<span class="w">            </span><span class="c1">// them. Why?</span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">set_indicator</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_source</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">n</span><span class="p">.</span><span class="n">get_indicator</span><span class="p">(</span><span class="n">indicator_name</span><span class="p">).</span><span class="n">set_mean</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">indicator_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indicator</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ind_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">set_indicator</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_name</span><span class="p">,</span><span class="w"> </span><span class="n">indicator_source</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ind_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// This is a duplicate indicator, and will not be added again.</span>
<span class="w">            </span><span class="c1">// TODO: Decide how to handle this situation and inform the user at</span>
<span class="w">            </span><span class="c1">// the CauseMos HMI end.</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// [ epoch --→ observation ]</span>
<span class="w">        </span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">indicator_data</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Accumulate which epochs data points are available for</span>
<span class="w">        </span><span class="c1">// The idea is to use this to assess the frequency of the data.</span>
<span class="w">        </span><span class="n">set</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">epochs</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data_point</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">indicator</span><span class="p">[</span><span class="s">&quot;values&quot;</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_point</span><span class="p">[</span><span class="s">&quot;value&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// This is a missing data point</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">observation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_point</span><span class="p">[</span><span class="s">&quot;value&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_point</span><span class="p">[</span><span class="s">&quot;timestamp&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="k">continue</span><span class="p">;}</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Note: HMI sends epochs as unix epoch * 1000</span>
<span class="w">            </span><span class="n">epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_point</span><span class="p">[</span><span class="s">&quot;timestamp&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Keep track of multiple observations for each epoch</span>
<span class="w">            </span><span class="n">indicator_data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="w"> </span><span class="n">observation</span><span class="p">));</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Record the epochs where observations are available for this</span>
<span class="w">            </span><span class="c1">// indicator. This data is used to assess the observation</span>
<span class="w">            </span><span class="c1">// frequency.</span>
<span class="w">            </span><span class="n">epochs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">epoch</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Find the start epoch of observations. When observation</span>
<span class="w">            </span><span class="c1">// sequences are not aligned:</span>
<span class="w">            </span><span class="c1">// start epoch =&gt; earliest observation among all the</span>
<span class="w">            </span><span class="c1">// observation sequences.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epoch</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Find the end epoch of observations. When observation</span>
<span class="w">            </span><span class="c1">// sequences are not aligned:</span>
<span class="w">            </span><span class="c1">// end epoch =&gt; latest observation among all the observation</span>
<span class="w">            </span><span class="c1">// sequences.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_end_epoch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_end_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epoch</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Add this indicator observations to the concept. The data structure</span>
<span class="w">        </span><span class="c1">// has provision to assign multiple indicator observation sequences for</span>
<span class="w">        </span><span class="c1">// a single concept.</span>
<span class="w">        </span><span class="n">concept_indicator_data</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">indicator_data</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// To assess the frequency of the data</span>
<span class="w">        </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">epochs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">epochs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">AnalysisGraph::epoch_to_timestep</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">train_start_epoch</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">long</span><span class="w"> </span><span class="n">modeling_frequency</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">epoch</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">train_start_epoch</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">modeling_frequency</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">infer_modeling_period</span><span class="p">(</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">ConceptIndicatorEpochs</span><span class="w"> </span><span class="o">&amp;</span><span class="n">concept_indicator_epochs</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">long</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shortest_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">long</span><span class="w"> </span><span class="o">&amp;</span><span class="n">longest_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">long</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frequent_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">highest_frequency</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">epochs_all</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ind_epochs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">epochs_all</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">(</span><span class="n">epochs_all</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">epochs_all</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gaps</span><span class="p">(</span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">adjacent_difference</span><span class="p">(</span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">gaps</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Compute number of epochs between data points</span>
<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gap_frequencies</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">itr</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">gap</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">gaps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">gap</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Check whether two adjacent data points with the same gap of</span>
<span class="w">        </span><span class="c1">// epochs in between is already found.</span>
<span class="w">        </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap_frequencies</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">gaps</span><span class="p">[</span><span class="n">gap</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">gap_frequencies</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// There were previous adjacent pairs of data points with</span>
<span class="w">            </span><span class="c1">// gap epochs in between. Now we have found one more</span>
<span class="w">            </span><span class="c1">// so increase the number of data points at this frequency.</span>
<span class="w">            </span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// This is the first data point that is gap epochs</span>
<span class="w">            </span><span class="c1">// away from its previous data point. Start recording this new</span>
<span class="w">            </span><span class="c1">// frequency.</span>
<span class="w">            </span><span class="n">gap_frequencies</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">gaps</span><span class="p">[</span><span class="n">gap</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Find the smallest gap and most frequent gap</span>
<span class="w">    </span><span class="n">shortest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">longest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">frequent_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">highest_frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Epochs statistics for individual indicator time series for debugging purposes.</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">gap</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gap_frequencies</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_gap</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">gap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">shortest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">longest_gap</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">gap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">longest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">highest_frequency</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">freq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// In case of multiple gaps having the same highest frequency,</span>
<span class="w">            </span><span class="c1">// note down the shortest highest frequency gap</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frequent_gap</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">gap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">frequent_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">highest_frequency</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">freq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">highest_frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">freq</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">frequent_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">modeling_period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frequent_gap</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">observation_timesteps</span><span class="p">(</span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">transform</span><span class="p">(</span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">observation_timesteps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">             </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                 </span><span class="c1">//return this-&gt;epoch_to_timestep(epoch, this-&gt;train_start_epoch,</span>
<span class="w">                 </span><span class="c1">//                               this-&gt;modeling_period);</span>
<span class="w">                 </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">epoch_to_timestep</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">modeling_period</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observation_timestep_gaps</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observation_timestep_gaps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">observation_timesteps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">adjacent_difference</span><span class="p">(</span><span class="n">observation_timesteps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                        </span><span class="n">observation_timesteps</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observation_timestep_gaps</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">infer_concept_period</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ConceptIndicatorEpochs</span><span class="w"> </span><span class="o">&amp;</span><span class="n">concept_indicator_epochs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">milliseconds_per_day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">min_days_global</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">start_day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">modeling_period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">concept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">concept_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="n">concept_id</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ind_epochs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">concept_id</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ind_days</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">transform</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_days</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">              </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">round</span><span class="p">(</span><span class="n">epoch</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">milliseconds_per_day</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">year_month_dates</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">transform</span><span class="p">(</span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_epochs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">year_month_dates</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">              </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="n">epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gaps_in_months</span><span class="p">(</span><span class="n">year_month_dates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">year_month_dates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">months</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delphi</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">months_between</span><span class="p">(</span><span class="n">year_month_dates</span><span class="p">[</span><span class="n">ts</span><span class="p">],</span><span class="w"> </span><span class="n">year_month_dates</span><span class="p">[</span><span class="n">ts</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">gaps_in_months</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">months</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">months</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shortest_monthly_gap_ind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">months</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="c1">//    vector&lt;long&gt; gaps(ind_epochs.size());</span>
<span class="c1">//    adjacent_difference(ind_epochs.begin(), ind_epochs.end(), gaps.begin());</span>
<span class="c1">//</span>
<span class="c1">//    vector&lt;int&gt; days_between(gaps.size() - 1);</span>
<span class="c1">//    transform(gaps.begin() + 1, gaps.end(), days_between.begin(),</span>
<span class="c1">//              [&amp;](long gap) {</span>
<span class="c1">//                return round(gap / milliseconds_per_day);</span>
<span class="c1">//              });</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">days_between</span><span class="p">(</span><span class="n">ind_days</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">adjacent_difference</span><span class="p">(</span><span class="n">ind_days</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ind_days</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">days_between</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span><span class="w"></span>
<span class="c1">//    for (int days : days_between) {</span>
<span class="c1">//      if (days &lt; min_days) {</span>
<span class="c1">//        min_days = days;</span>
<span class="c1">//      }</span>
<span class="c1">//    }</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">days_between</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">days_between</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">days</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_days</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">min_days</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">days</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ind_days</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">start_day</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">start_day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ind_days</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_days_global</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">min_days_global</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_days</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min_days</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Daily</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">365</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min_days</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Weekly</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">52</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">28</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Monthly</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">59</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">62</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 2 Months</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">89</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">92</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 3 Months</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">120</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 4 Months</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">181</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">min_days</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">184</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 6 Months</span>
<span class="w">      </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    else if (365 &lt;= min_days &amp;&amp; min_days &lt;= 366) {</span>
<span class="cm">      // Yearly</span>
<span class="cm">    }</span>
<span class="cm">    else if (730 &lt;= min_days &amp;&amp; min_days &lt;= 731) {</span>
<span class="cm">      // 2 Years</span>
<span class="cm">    } else if (1095 &lt;= min_days &amp;&amp; min_days &lt;= 1096) {</span>
<span class="cm">      // 3 Years</span>
<span class="cm">    } else if (1460 &lt;= min_days &amp;&amp; min_days &lt;= 1461) {</span>
<span class="cm">      // 4 Years</span>
<span class="cm">    } else if (1825 &lt;= min_days &amp;&amp; min_days &lt;= 1827) {</span>
<span class="cm">      // 5 Years</span>
<span class="cm">    }</span>
<span class="cm">    */</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">concept_id</span><span class="p">].</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">period</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">modeling_period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lcm</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">modeling_period</span><span class="p">,</span><span class="w"> </span><span class="n">period</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">yyyy_mm_dd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">year_month_dates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">yyyy_mm_dd</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">yyyy_mm_dd</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">yyyy_mm_dd</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;), &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">void</span><span class="w"></span>
<span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">set_observed_state_sequence_from_json_dict</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">json_indicators</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_verts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">num_vertices</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This is a multimap to keep provision to have multiple observations per</span>
<span class="w">    </span><span class="c1">// time point per indicator.</span>
<span class="w">    </span><span class="c1">// Access (concept is a vertex in the CAG)</span>
<span class="w">    </span><span class="c1">// [ concept ][ indicator ][ epoch --→ observation ]</span>
<span class="w">    </span><span class="n">ConceptIndicatorData</span><span class="w"> </span><span class="nf">concept_indicator_data</span><span class="p">(</span><span class="n">num_verts</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Keeps the sequence of epochs for which data points are available</span>
<span class="w">    </span><span class="c1">// Data points are sorted according to epochs</span>
<span class="w">    </span><span class="c1">// Access:</span>
<span class="w">    </span><span class="c1">// [ concept ][ indicator ][epoch]</span>
<span class="w">    </span><span class="n">ConceptIndicatorEpochs</span><span class="w"> </span><span class="nf">concept_indicator_epochs</span><span class="p">(</span><span class="n">num_verts</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">extract_concept_indicator_mapping_and_observations_from_json</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">json_indicators</span><span class="p">,</span><span class="w"> </span><span class="n">concept_indicator_data</span><span class="p">,</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Decide the data frequency.</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">shortest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">longest_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">frequent_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">highest_frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_timesteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">monthly_to_epoch</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_end_epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Convert epochs to months making train_start_epoch = 0</span>
<span class="w">        </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">train_start_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">train_end_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_end_epoch</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_verts</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">obs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">obs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">obs</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kt">long</span><span class="w"> </span><span class="n">epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">obs</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obs_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="n">epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delphi</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">months_between</span><span class="p">(</span><span class="n">train_start_date</span><span class="p">,</span><span class="w"> </span><span class="n">obs_date</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">obs</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>

<span class="w">                </span><span class="n">monthly_to_epoch</span><span class="p">[</span><span class="n">month</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">epoch</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// TODO: There are cases this period estimation goes wrong. Need revision.</span>
<span class="w">                </span><span class="c1">// e.g. observation months: 1, 3, 5, 8, 10, 12</span>
<span class="w">                </span><span class="c1">// The good solution is to get the gcd of all the observation gaps for a indicator</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obs</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">obs</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                              </span><span class="n">concept_indicator_epochs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">obs</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gap</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shortest_monthly_gap_ind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gap</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// Monthly</span>
<span class="w">              </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// 2 Months</span>
<span class="w">              </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// 3 Months</span>
<span class="w">              </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// 4 Months</span>
<span class="w">              </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_monthly_gap_ind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// 6 Months</span>
<span class="w">              </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">period</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="c1">//        cout &lt;&lt; &quot;Inferring periods\n&quot;;</span>
<span class="c1">//        this-&gt;infer_concept_period(concept_indicator_epochs);</span>

<span class="w">        </span><span class="c1">// Some training data has been provided</span>
<span class="w">        </span><span class="n">epochs_sorted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">infer_modeling_period</span><span class="p">(</span><span class="n">concept_indicator_epochs</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">shortest_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">longest_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">frequent_gap</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">highest_frequency</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_timesteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epochs_sorted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Access (concept is a vertex in the CAG)</span>
<span class="w">    </span><span class="c1">// [ timestep ][ concept ][ indicator ][ observation ]</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ObservedStateSequence</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_timesteps</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill in observed state sequence</span>
<span class="w">    </span><span class="c1">// NOTE: This code is very similar to the implementations in</span>
<span class="w">    </span><span class="c1">// set_observed_state_sequence_from_data and get_observed_state_from_data</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_timesteps</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">num_verts</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_verts</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">v</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">[</span><span class="n">ts</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">indicators</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">indicators</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">[</span><span class="n">ts</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">epochs_in_ts</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">monthly_to_epoch</span><span class="p">[</span><span class="n">epochs_sorted</span><span class="p">[</span><span class="n">ts</span><span class="p">]])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">pair</span><span class="o">&lt;</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">                        </span><span class="n">obs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concept_indicator_data</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">equal_range</span><span class="p">(</span><span class="n">epochs_in_ts</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obs</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">obs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">[</span><span class="n">ts</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="w"></span>
<span class="w">                          </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">from_causemos_json_dict</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">json_data</span><span class="p">,</span><span class="w"></span>
<span class="w">                                            </span><span class="kt">double</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">,</span><span class="w"></span>
<span class="w">                                            </span><span class="kt">double</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="w"></span>
<span class="w">                                            </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">causemos_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// TODO: If model id is not present, we might want to not create the model</span>
<span class="w">  </span><span class="c1">// and send a failure response. At the moment we just create a blank model,</span>
<span class="w">  </span><span class="c1">// which could lead to future bugs that are hard to debug.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">()){</span><span class="k">return</span><span class="p">;}</span><span class="w"></span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">statements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;statements&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">statements</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s">&quot;belief&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="n">or</span><span class="w"></span>
<span class="w">        </span><span class="n">stmt</span><span class="p">[</span><span class="s">&quot;belief&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">evidence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stmt</span><span class="p">[</span><span class="s">&quot;evidence&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">evidence</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">subj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stmt</span><span class="p">[</span><span class="s">&quot;subj&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stmt</span><span class="p">[</span><span class="s">&quot;obj&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subj</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">subj_score_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj</span><span class="p">[</span><span class="s">&quot;concept_score&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">obj_score_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">[</span><span class="s">&quot;concept_score&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subj_score_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">obj_score_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">subj_score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj_score_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">obj_score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj_score_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subj_score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="w"> </span><span class="n">or</span><span class="w"></span>
<span class="w">        </span><span class="n">obj_score</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">subj_concept_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj</span><span class="p">[</span><span class="s">&quot;concept&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">obj_concept_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">[</span><span class="s">&quot;concept&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subj_concept_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">obj_concept_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">subj_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj_concept_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">obj_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj_concept_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subj_name</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">obj_name</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Guard against self loops</span>
<span class="w">      </span><span class="c1">// Add the nodes to the graph if they are not in it already</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">add_node</span><span class="p">(</span><span class="n">subj_name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">add_node</span><span class="p">(</span><span class="n">obj_name</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Add the edge to the graph if it is not in it already</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">evid</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">evidence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">evid</span><span class="p">[</span><span class="s">&quot;evidence_context&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">evid_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evid</span><span class="p">[</span><span class="s">&quot;evidence_context&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">subj_polarity_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evid_context</span><span class="p">[</span><span class="s">&quot;subj_polarity&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">obj_polarity_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evid_context</span><span class="p">[</span><span class="s">&quot;obj_polarity&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="c1">// We set polarities to 1 (positive) by default if they are not specified.</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">subj_polarity_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">obj_polarity_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">subj_polarity_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">subj_polarity_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj_polarity_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">obj_polarity_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">obj_polarity_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj_polarity_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">subj_adjectives_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evid_context</span><span class="p">[</span><span class="s">&quot;subj_adjectives&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">obj_adjectives_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evid_context</span><span class="p">[</span><span class="s">&quot;obj_adjectives&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">subj_adjectives</span><span class="p">{</span><span class="s">&quot;None&quot;</span><span class="p">};</span><span class="w"></span>
<span class="w">      </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obj_adjectives</span><span class="p">{</span><span class="s">&quot;None&quot;</span><span class="p">};</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">subj_adjectives_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">()){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">subj_adjectives_json</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="n">subj_adjectives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subj_adjectives_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">obj_adjectives_json</span><span class="p">.</span><span class="n">is_null</span><span class="p">()){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">obj_adjectives_json</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="n">obj_adjectives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj_adjectives_json</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">causal_fragment</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">CausalFragment</span><span class="p">({</span><span class="n">subj_adjectives</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">subj_polarity_val</span><span class="p">,</span><span class="w"> </span><span class="n">subj_name</span><span class="p">},</span><span class="w"></span>
<span class="w">                         </span><span class="p">{</span><span class="n">obj_adjectives</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">obj_polarity_val</span><span class="p">,</span><span class="w"> </span><span class="n">obj_name</span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">add_edge</span><span class="p">(</span><span class="n">causal_fragment</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;conceptIndicators&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// No indicator data provided.</span>
<span class="w">    </span><span class="c1">// TODO: What is the best action here?</span>
<span class="w">    </span><span class="c1">//throw runtime_error(&quot;No indicator information provided&quot;);</span>
<span class="w">    </span><span class="c1">// Maybe this is acceptable since there is another call: edit-indicators,</span>
<span class="w">    </span><span class="c1">// which is not yet implemented. An analyst can create a CAG structure</span>
<span class="w">    </span><span class="c1">// without any indicators and then later attach indicators one by one.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">set_observed_state_sequence_from_json_dict</span><span class="p">(</span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;conceptIndicators&quot;</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="cm">/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm">                      create-experiment (private)</span>
<span class="cm">            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The HMI uses milliseconds. So they multiply time-stamps by 1000.</span>
<span class="w">    </span><span class="c1">// Before converting them back to year and month, we have to divide</span>
<span class="w">    </span><span class="c1">// by 1000.</span>
<span class="w">    </span><span class="n">timestamp</span><span class="w"> </span><span class="o">/=</span><span class="w">  </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Convert the time-step to year and month.</span>
<span class="w">    </span><span class="c1">// We are converting it according to GMT.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tm</span><span class="w"> </span><span class="o">*</span><span class="n">ptm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timestamp</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1900</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ptm</span><span class="o">-&gt;</span><span class="n">tm_year</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ptm</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptm</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;* * * * *   WARNING: Observation timestamp {0}-{1}-{2} does not adhere to the protocol!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">extract_projection_constraints</span><span class="p">(</span><span class="w"></span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection_constraints</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">skip_steps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">constraint</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">projection_constraints</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">constraint</span><span class="p">[</span><span class="s">&quot;concept&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="k">continue</span><span class="p">;}</span><span class="w"></span>
<span class="w">        </span><span class="n">string</span><span class="w"> </span><span class="n">concept_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constraint</span><span class="p">[</span><span class="s">&quot;concept&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">constraint</span><span class="p">[</span><span class="s">&quot;values&quot;</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// We need both the step and the value to proceed. Thus checking</span>
<span class="w">            </span><span class="c1">// again to reduce bookkeeping.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s">&quot;step&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="k">continue</span><span class="p">;}</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s">&quot;value&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="k">continue</span><span class="p">;}</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">step</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="s">&quot;step&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">ind_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="s">&quot;value&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">            </span><span class="c1">// NOTE: Delphi is capable of attaching multiple indicators to a</span>
<span class="w">            </span><span class="c1">//       single concept. Since we are constraining the latent state,</span>
<span class="w">            </span><span class="c1">//       we can constrain (or intervene) based on only one of those</span>
<span class="w">            </span><span class="c1">//       indicators. By passing an empty indicator name, we choose</span>
<span class="w">            </span><span class="c1">//       to constrain the first indicator attached to a concept</span>
<span class="w">            </span><span class="c1">//       which should be present irrespective of whether this</span>
<span class="w">            </span><span class="c1">//       concept has one or more indicators attached to it.</span>
<span class="w">            </span><span class="c1">//</span>
<span class="w">            </span><span class="c1">// Requested prediction stat epoch is earlier than the training</span>
<span class="w">            </span><span class="c1">// start epoch. The first requested prediction epoch after the</span>
<span class="w">            </span><span class="c1">// training start epoch is skip_steps after the requested prediction</span>
<span class="w">            </span><span class="c1">// start epoch and the constraints within those skiped epochs</span>
<span class="w">            </span><span class="c1">// cannot be applied and hence are been ignored.</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">step</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">skip_steps</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">step</span><span class="o">-</span><span class="n">skip_steps</span><span class="p">,</span><span class="w"> </span><span class="n">concept_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ind_value</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">FormattedProjectionResult</span><span class="w"></span>
<span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">run_causemos_projection_experiment_from_json_dict</span><span class="p">(</span><span class="w"></span>
<span class="w">                                              </span><span class="k">const</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">json_data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;experimentParam&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">BadCausemosInputException</span><span class="p">(</span><span class="s">&quot;Experiment parameters null&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">projection_parameters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json_data</span><span class="p">[</span><span class="s">&quot;experimentParam&quot;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;startTime&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">BadCausemosInputException</span><span class="p">(</span><span class="s">&quot;Projection start time null&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">proj_start_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;startTime&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;endTime&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">BadCausemosInputException</span><span class="p">(</span><span class="s">&quot;Projection end time null&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">proj_end_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;endTime&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;numTimesteps&quot;</span><span class="p">].</span><span class="n">is_null</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">BadCausemosInputException</span><span class="p">(</span><span class="s">&quot;Projection number of time steps null&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_timesteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;numTimesteps&quot;</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">proj_start_epoch</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">proj_end_epoch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">BadCausemosInputException</span><span class="p">(</span><span class="s">&quot;Projection end epoch is before projection start epoch&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">skip_steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">observed_state_sequence</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// No training data has been provided</span>
<span class="w">      </span><span class="c1">// &quot;Train&quot; (more like derive) a model based on prior distributions</span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">NOTE:</span><span class="se">\n\t\&quot;</span><span class="s">Training</span><span class="se">\&quot;</span><span class="s"> a model, without any training observations, using only prior distributions!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_start_timestep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">delta_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_timesteps</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      this-&gt;pred_start_timestep = this-&gt;epoch_to_timestep(</span>
<span class="cm">          proj_start_epoch, this-&gt;train_start_epoch, this-&gt;modeling_period);</span>
<span class="cm">      double pred_end_timestep = this-&gt;epoch_to_timestep(</span>
<span class="cm">          proj_end_epoch, this-&gt;train_start_epoch, this-&gt;modeling_period);</span>
<span class="cm">      this-&gt;delta_t = (pred_end_timestep - this-&gt;pred_start_timestep) /</span>
<span class="cm">                      (this-&gt;pred_timesteps - 1.0);</span>
<span class="cm">      */</span><span class="w"></span>
<span class="w">      </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">train_start_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">train_start_epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pred_start_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="n">proj_start_epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_start_timestep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delphi</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">months_between</span><span class="p">(</span><span class="n">train_start_date</span><span class="p">,</span><span class="w"> </span><span class="n">pred_start_date</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">delta_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pred_end_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timestamp_to_year_month_date</span><span class="p">(</span><span class="n">proj_end_epoch</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">//int num_pred_months = delphi::utils::months_between(pred_start_date, pred_end_date);</span>
<span class="w">      </span><span class="c1">//cout &lt;&lt; &quot;(&quot; &lt;&lt; get&lt;0&gt;(pred_end_date) &lt;&lt; &quot;-&quot; &lt;&lt; get&lt;1&gt;(pred_end_date) &lt;&lt; &quot;-&quot; &lt;&lt; get&lt;2&gt;(pred_end_date) &lt;&lt; &quot;), &quot;;</span>
<span class="w">      </span><span class="c1">//cout &lt;&lt; &quot;(&quot; &lt;&lt; get&lt;0&gt;(pred_start_date) &lt;&lt; &quot;-&quot; &lt;&lt; get&lt;1&gt;(pred_start_date) &lt;&lt; &quot;-&quot; &lt;&lt; get&lt;2&gt;(pred_start_date) &lt;&lt; &quot;), &quot;;</span>

<span class="w">      </span><span class="c1">// To help clamping we predict one additional timestep</span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_timesteps</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_start_timestep</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">delta_t</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Prevent predicting for timesteps earlier than training start time</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_start_timestep</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">NOTE:</span><span class="se">\n\t\&quot;</span><span class="s">Predicting</span><span class="se">\&quot;</span><span class="s"> in the past</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">        skip_steps = ceil(abs(this-&gt;pred_start_timestep) / this-&gt;delta_t);</span>
<span class="cm">        this-&gt;pred_start_timestep += skip_steps;</span>
<span class="cm">        this-&gt;pred_timesteps -= skip_steps;</span>
<span class="cm">        */</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      if (this-&gt;pred_start_timestep &gt; pred_end_timestep) {</span>
<span class="cm">        throw BadCausemosInputException(</span>
<span class="cm">            &quot;Projection end epoch is before projection start epoch&quot;);</span>
<span class="cm">      }</span>
<span class="cm">       */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">extract_projection_constraints</span><span class="p">(</span><span class="n">projection_parameters</span><span class="p">[</span><span class="s">&quot;constraints&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">skip_steps</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">generate_latent_state_sequences</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_start_timestep</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">generate_observed_state_sequences</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">format_projection_result</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">FormattedProjectionResult</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">format_projection_result</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Access</span>
<span class="w">  </span><span class="c1">// [ vertex_name ][ timestep ][ sample ]</span>
<span class="w">  </span><span class="n">FormattedProjectionResult</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// To facilitate clamping derivative we start predicting one timestep before</span>
<span class="w">  </span><span class="c1">// the requested prediction start timestep. We are removing that timestep when</span>
<span class="w">  </span><span class="c1">// returning the results.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">vert_name</span><span class="p">,</span><span class="w"> </span><span class="n">vert_id</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name_to_vertex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">[</span><span class="n">vert_name</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_timesteps</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pred_timesteps</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ts</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">samp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">samp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span><span class="w"> </span><span class="n">samp</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="p">[</span><span class="n">vert_name</span><span class="p">][</span><span class="n">ts</span><span class="p">][</span><span class="n">samp</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">predicted_observed_state_sequences</span><span class="p">[</span><span class="n">samp</span><span class="p">][</span><span class="n">ts</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">vert_id</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">vert_name</span><span class="p">][</span><span class="n">ts</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">sample_transition_matrix_collection_from_prior</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">transition_matrix_collection</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">transition_matrix_collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span><span class="w"> </span><span class="n">sample</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">edges</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">set_theta</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">kde</span><span class="p">.</span><span class="n">resample</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rand_num_generator</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">uni_dist</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">norm_dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create this-&gt;A_original based on the sampled β and remember it</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">set_transition_matrix_from_betas</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">transition_matrix_collection</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">A_original</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">============================================================================</span>
<span class="cm">Public: Integration with Uncharted&#39;s CauseMos interface</span>
<span class="cm">============================================================================</span>
<span class="cm">*/</span><span class="w"></span>

<span class="w">            </span><span class="cm">/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm">                          create-model (public)</span>
<span class="cm">            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/</span><span class="w"></span>

<span class="n">AnalysisGraph</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">from_causemos_json_string</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">json_string</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                       </span><span class="kt">double</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                       </span><span class="kt">double</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                       </span><span class="kt">int</span><span class="w"> </span><span class="n">kde_kernels</span><span class="w"></span>
<span class="w">                                                       </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">AnalysisGraph</span><span class="w"> </span><span class="n">G</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">G</span><span class="p">.</span><span class="n">n_kde_kernels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kde_kernels</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">json_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">json_string</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">G</span><span class="p">.</span><span class="n">from_causemos_json_dict</span><span class="p">(</span><span class="n">json_data</span><span class="p">,</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">,</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">G</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">AnalysisGraph</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">from_causemos_json_file</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                     </span><span class="kt">double</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                     </span><span class="kt">double</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                     </span><span class="kt">int</span><span class="w"> </span><span class="n">kde_kernels</span><span class="w"></span>
<span class="w">                                                     </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">AnalysisGraph</span><span class="w"> </span><span class="n">G</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">G</span><span class="p">.</span><span class="n">n_kde_kernels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kde_kernels</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">json_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_json</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">G</span><span class="p">.</span><span class="n">from_causemos_json_dict</span><span class="p">(</span><span class="n">json_data</span><span class="p">,</span><span class="w"> </span><span class="n">belief_score_cutoff</span><span class="p">,</span><span class="w"> </span><span class="n">grounding_score_cutoff</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">G</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">string</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">generate_create_model_response</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="p">,</span><span class="w"> </span><span class="n">ranges</span><span class="o">::</span><span class="n">max</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">json</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;status&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">trained</span><span class="o">?</span><span class="w"> </span><span class="s">&quot;ready&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;training&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;relations&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;conceptIndicators&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">edges</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">        vector&lt;double&gt; weights;</span>
<span class="cm">        if (this-&gt;trained) {</span>
<span class="cm">            weights = vector&lt;double&gt;(this-&gt;graph[e].sampled_thetas.size());</span>
<span class="cm">            transform(this-&gt;graph[e].sampled_thetas.begin(),</span>
<span class="cm">                      this-&gt;graph[e].sampled_thetas.end(),</span>
<span class="cm">                      weights.begin(),</span>
<span class="cm">                      [&amp;](double theta) {</span>
<span class="cm">                        return (double)tan(theta);</span>
<span class="cm">                      });</span>
<span class="cm">        } else {</span>
<span class="cm">            weights = vector&lt;double&gt;{0.5};</span>
<span class="cm">        }</span>
<span class="cm">         */</span><span class="w"></span>

<span class="w">        </span><span class="n">json</span><span class="w"> </span><span class="n">edge_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;source&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">(</span><span class="n">e</span><span class="p">).</span><span class="n">name</span><span class="p">},</span><span class="w"></span>
<span class="w">                          </span><span class="p">{</span><span class="s">&quot;target&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">(</span><span class="n">e</span><span class="p">).</span><span class="n">name</span><span class="p">},</span><span class="w"></span>
<span class="w">                          </span><span class="p">{</span><span class="s">&quot;weights&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">trained</span><span class="w"></span>
<span class="w">                                          </span><span class="o">?</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">sampled_thetas</span><span class="w"></span>
<span class="w">                                          </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">0.5</span><span class="p">}}};</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;relations&quot;</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge_json</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_verts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">num_vertices</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_verts</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">v</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;conceptIndicators&quot;</span><span class="p">][</span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;initialValue&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">},</span><span class="w"></span>
<span class="w">                                          </span><span class="p">{</span><span class="s">&quot;scalingFactor&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">},</span><span class="w"></span>
<span class="w">                                          </span><span class="p">{</span><span class="s">&quot;scalingBias&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">}};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">j</span><span class="p">.</span><span class="n">dump</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="cm">/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm">                       create-experiment (public)</span>
<span class="cm">            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/</span><span class="w"></span>

<span class="n">FormattedProjectionResult</span><span class="w"></span>
<span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">run_causemos_projection_experiment_from_json_string</span><span class="p">(</span><span class="w"></span>
<span class="w">                                                           </span><span class="n">string</span><span class="w"> </span><span class="n">json_string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">fmt</span><span class="o">::</span><span class="nn">literals</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="p">;</span><span class="w"></span>


<span class="w">    </span><span class="c1">// During the create-model call we called construct_theta_pdfs() and</span>
<span class="w">    </span><span class="c1">// serialized them to json. When we recreate the model we load them. So to</span>
<span class="w">    </span><span class="c1">// prevent Delphi putting cycle to compute them again when we call</span>
<span class="w">    </span><span class="c1">// initialize_parameters() below, let us inform Delphi that this is a</span>
<span class="w">    </span><span class="c1">// CauseMos call.</span>
<span class="w">    </span><span class="c1">// NOTE: In hindsight, I might be able to prevent Delphi calling</span>
<span class="w">    </span><span class="c1">//       initialize_parameters() within train_model() when we train due to</span>
<span class="w">    </span><span class="c1">//       a CauseMos call. I need to revise it to see whether anything is</span>
<span class="w">    </span><span class="c1">//       called out of order.</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">causemos_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">json_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">json_string</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">run_causemos_projection_experiment_from_json_dict</span><span class="p">(</span><span class="n">json_data</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BadCausemosInputException</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Just a dummy empty prediction to signal that there is an error in</span>
<span class="w">        </span><span class="c1">// projection parameters.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FormattedProjectionResult</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">FormattedProjectionResult</span><span class="w"></span>
<span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">run_causemos_projection_experiment_from_json_file</span><span class="p">(</span><span class="w"></span>
<span class="w">                                                              </span><span class="n">string</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">fmt</span><span class="o">::</span><span class="nn">literals</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="p">;</span><span class="w"></span>


<span class="w">    </span><span class="c1">// During the create-model call we called construct_theta_pdfs() and</span>
<span class="w">    </span><span class="c1">// serialized them to json. When we recreate the model we load them. So to</span>
<span class="w">    </span><span class="c1">// prevent Delphi putting cycle to compute them again when we call</span>
<span class="w">    </span><span class="c1">// initialize_parameters() below, let us inform Delphi that this is a</span>
<span class="w">    </span><span class="c1">// CauseMos call.</span>
<span class="w">    </span><span class="c1">// NOTE: In hindsight, I might be able to prevent Delphi calling</span>
<span class="w">    </span><span class="c1">//       initialize_parameters() within train_model() when we train due to</span>
<span class="w">    </span><span class="c1">//       a CauseMos call. I need to revise it to see whether anything is</span>
<span class="w">    </span><span class="c1">//       called out of order.</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">causemos_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">json_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_json</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">run_causemos_projection_experiment_from_json_dict</span><span class="p">(</span><span class="n">json_data</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BadCausemosInputException</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Just a dummy empty prediction to signal that there is an error in</span>
<span class="w">        </span><span class="c1">// projection parameters.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FormattedProjectionResult</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="cm">/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm">                  edit-weights</span>
<span class="cm">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">AnalysisGraph</span><span class="o">::</span><span class="n">freeze_edge_weight</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">source_name</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">target_name</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="kt">double</span><span class="w"> </span><span class="n">scaled_weight</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="kt">int</span><span class="w"> </span><span class="n">polarity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scaled_weight</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">scaled_weight</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">source_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">target_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">source_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name_to_vertex</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">source_name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">out_of_range</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Source concept does not exist</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">target_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name_to_vertex</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">target_name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">out_of_range</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Target concept does not exist</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">pair</span><span class="o">&lt;</span><span class="n">EdgeDescriptor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">edg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">edge</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span><span class="w"> </span><span class="n">target_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                         </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">edg</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// There is no edge from source concept to target concept</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scaled_weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">polarity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">theta</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">edg</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">set_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">[</span><span class="n">edg</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">freeze</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Adarsh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>