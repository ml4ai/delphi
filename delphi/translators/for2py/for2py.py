"""
    This program is for replacement of autoTranslate bash script.
    Instead of creating and using each file for next operation
    like in autoTranslate bash scropt, it creates python object
    and passes it to the next function. Thus, it works as calling
    a multiple functions in a single program. This new autoTranslate.py
    does not invoke main functions in each program.

    In simplicity, it's a sinlg program that integrated the functionalities
    of test_program_analysis.py and autoTranslate.

    Author: Terrence J. Lim
"""

import os
import sys
import ast
import argparse
import pickle
import ntpath as np
import subprocess as sp
import xml.etree.ElementTree as ET

from delphi.translators.for2py import (
    preprocessor,
    translate,
    get_comments,
    pyTranslate,
    genPGM,
    mod_index_generator,
    rectify,
)

OUTPUT_DIR = "tmp"

def generate_ofp_xml(preprocessed_fortran_file, ofp_file):
    """
        This function executes Java command to run open
        fortran parser to generate initial AST XML from
        the preprocessed fortran file.

        This will create an output .xml file while it
        returns xml string back to the caller.
    """

    print ("Generating AST XML...")

    # Excute Java command to generate XML
    # string from fortran file
    ofp_xml = sp.run(
        [
            "java",
            "fortran.ofp.FrontEnd",
            "--class",
            "fortran.ofp.XMLPrinter",
            "--verbosity",
            "0",
            preprocessed_fortran_file,
        ],
        stdout=sp.PIPE,
    ).stdout

    # Indent and construct XML for file output
    ast = ET.XML(ofp_xml)
    indent(ast)
    tree = ET.ElementTree(ast)

    try:
        with open (ofp_file, "w") as f:
            pass
    except IOError:
        assert False, f"Failed to write to {ofp_file}."

    tree.write(ofp_file)

    return ofp_xml

def generate_rectified_xml(ofp_xml: str, rectified_file):
    """
        This function rectifies XMl that was generated by
        OFP. Then, it will generate an output file, but
        also returns rectified element tree object back
        to the caller.
    """

    print ("Generating rectified XML...")

    rectified_xml = rectify.buildNewASTfromXMLString(ofp_xml)
    rectified_tree = ET.ElementTree(rectified_xml)

    try:
        with open (rectified_file, "w") as f:
            pass
    except IOError:
        assert False, f"Failed to write to {rectified_file}."

    rectified_tree.write(rectified_file)

    return rectified_xml

def generate_outputDict(rectified_tree, preprocessed_fortran_file, pickle_file):
    """
        This function generates a dictionary of ast and
        generates a pickle file.
    """

    print ("Generating pickle file...")

    outputDict = translate.xml_to_py(
                    [rectified_tree],
                    preprocessed_fortran_file
    )

    try:
        with open (pickle_file, "wb") as f:
            pickle.dump(outputDict, f)
    except IOError:
        assert False, f"Failed to write to {pickle_file}."

    return outputDict

def generate_python_src(outputDict, python_file, output_file):
    """
        This function generates python source file from
        generated python source list. This function will
        return this list back to the caller for GrFN
        generation.
    """
    
    print ("Generating python source file...")

    pySrc = pyTranslate.create_python_source_list(outputDict)[0][0]

    try:
        f = open(python_file, "w")
    except IOError:
        assert False, f"Unable to write to {python_file}."
    
    outputList = []
    for item in pySrc:
        outputList.append(python_file)
        f.write(item[0])

    try:
        with open(output_file, "w") as f:
            for fileName in outputList:
                f.write(fileName + " ")
    except IOError:
        assert False, f"Unable to write to {outFile}."

    return pySrc

def generate_grfn(
                    python_src, python_file,
                    lambdas_file, json_file,
                    mode_mapper_dict
):
    """
        This function generates GrFN dictionary object and file.
    """

    print ("Generating GrFN files...")

    asts = [ast.parse(python_src)]
    grfn_dict = genPGM.create_pgm_dict(lambdas_file, asts, python_file, mode_mapper_dict, save_file=True)
    for identifier in grfn_dict['identifiers']:
        del identifier['gensyms']

    return grfn_dict

def parse_args():
    """
        This function is for a safe command line
        input. It should receive the fortran file
        name and returns it back to the caller.
    """
    parser = argparse.ArgumentParser()

    parser.add_argument (
            "-f",
            "--file",
            nargs="+",
            help="An input fortran file"
    )

    args = parser.parse_args(sys.argv[1:])

    fortran = args.file[0]

    return fortran

def set_classpath():
    """
        This function temporarily sets the CLASSPATH
        to where OFP .jar files are stored.
    """
    output = str(sp.check_output([
                    'bash', 
                    '-c', 
                    'echo ${CLASSPATH}:$(pwd)/$(dirname ${BASH_SOURCE[0]})/bin/*'
    ]))

    # subprocess returns a fixed size of unnecessary
    # strings at the head & tail of the returning output,
    # so slice the string to get only the classpath string
    classpath = output[1:len(output)-3]
    os.environ['CLASSPATH'] = classpath

def indent(elem, level=0):
    """
        This function indents each level of XML.
        Source: https://stackoverflow.com/questions/3095434/inserting-newlines
                -in-xml-file-generated-via-xml-etree-elementstree-in-python
    """
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

def main():
    set_classpath()

    # If "tmp" directory does not exist already,
    # simply create one.
    if not os.path.isdir(OUTPUT_DIR):
        os.mkdir(OUTPUT_DIR)

    original_fortran_file_path = parse_args()
    original_fortran_file = np.basename(parse_args())
    base = os.path.splitext(original_fortran_file)[0]

    # Output files
    preprocessed_fortran_file = OUTPUT_DIR + "/" + base + "_preprocessed.f"
    ofp_file = OUTPUT_DIR + "/" + base + ".xml"
    rectified_xml_file = OUTPUT_DIR + "/" + "rectified_" + base + ".xml"
    pickle_file = OUTPUT_DIR + "/" + base + "_pickle"
    python_file = OUTPUT_DIR + "/" + base + ".py"
    output_file = OUTPUT_DIR + "/" + base + "_outputList.txt"
    json_file = OUTPUT_DIR + "/" + base + ".json"
    lambdas_file = OUTPUT_DIR + "/" + base + "_lambdas.py"

    # Open and read original fortran file
    with open(original_fortran_file_path, "r") as f:
        inputLines = f.readlines()

    # Preprocess the read in fortran file
    print ("\nGenerating preprocessed fortran file...")
    with open(preprocessed_fortran_file, "w") as f:
        f.write(preprocessor.process(inputLines))

    # Generate OFP XML from preprocessed fortran
    ofp_xml = generate_ofp_xml(preprocessed_fortran_file, ofp_file)

    # Rectify and generate a new xml from OFP XML
    rectified_tree = generate_rectified_xml(ofp_xml, rectified_xml_file)

    # Generate separate list of modules file
    mode_mapper_tree = rectified_tree
    generator = mod_index_generator.moduleGenerator()
    mode_mapper_dict = generator.analyze(mode_mapper_tree)

    # Creates a pickle file
    outputDict = generate_outputDict(
                    rectified_tree,
                    preprocessed_fortran_file,
                    pickle_file
    )

    # Create a python source file
    python_src = generate_python_src(outputDict, python_file, output_file)

    # Generate GrFN file
    grfn_dict = generate_grfn(
                    python_src,
                    python_file,
                    lambdas_file,
                    json_file,
                    mode_mapper_dict
    )

main()
