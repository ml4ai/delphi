<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>delphi.translators.for2py.genPGM &mdash; delphi  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> delphi
            <img src="../../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../config.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_openapi.html">GrFN OpenAPI Specification</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">delphi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
          <li><a href="../for2py.html">delphi.translators.for2py</a> &raquo;</li>
      <li>delphi.translators.for2py.genPGM</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for delphi.translators.for2py.genPGM</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3.6</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.genCode</span> <span class="kn">import</span> <span class="n">genCode</span><span class="p">,</span> <span class="n">PrintState</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.mod_index_generator</span> <span class="kn">import</span> <span class="n">get_index</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.get_comments</span> <span class="kn">import</span> <span class="n">get_comments</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py</span> <span class="kn">import</span> <span class="n">For2PyError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">os.path</span>


<span class="c1"># noinspection PyDefaultArgument</span>
<div class="viewcode-block" id="GrFNState"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNState">[docs]</a><span class="k">class</span> <span class="nc">GrFNState</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lambda_strings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">last_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">next_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">last_definition_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">array_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">array_assign_name</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">string_assign_name</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_strings</span> <span class="o">=</span> <span class="n">lambda_strings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_definitions</span> <span class="o">=</span> <span class="n">last_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_definitions</span> <span class="o">=</span> <span class="n">next_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_definition_default</span> <span class="o">=</span> <span class="n">last_definition_default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_types</span> <span class="o">=</span> <span class="n">variable_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_types</span> <span class="o">=</span> <span class="n">array_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="n">array_assign_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string_assign_name</span> <span class="o">=</span> <span class="n">string_assign_name</span>

<div class="viewcode-block" id="GrFNState.copy"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNState.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lambda_strings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">last_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">next_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">last_definition_default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">array_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">array_assign_name</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">string_assign_name</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">GrFNState</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_strings</span> <span class="k">if</span> <span class="n">lambda_strings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lambda_strings</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_definitions</span>
            <span class="k">if</span> <span class="n">last_definitions</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">last_definitions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_definitions</span>
            <span class="k">if</span> <span class="n">next_definitions</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">next_definitions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_definition_default</span>
            <span class="k">if</span> <span class="n">last_definition_default</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">last_definition_default</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_name</span> <span class="k">if</span> <span class="n">function_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">function_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_types</span> <span class="k">if</span> <span class="n">variable_types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">variable_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="k">if</span> <span class="n">scope_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scope_path</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="k">if</span> <span class="n">arrays</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">arrays</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_types</span> <span class="k">if</span> <span class="n">array_types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">array_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_assign_name</span>
            <span class="k">if</span> <span class="n">array_assign_name</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">array_assign_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string_assign_name</span>
            <span class="k">if</span> <span class="n">string_assign_name</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">string_assign_name</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="c1"># noinspection PyDefaultArgument,PyTypeChecker</span>
<div class="viewcode-block" id="GrFNGenerator"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator">[docs]</a><span class="k">class</span> <span class="nc">GrFNGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotated_assigned</span><span class="o">=</span><span class="p">[],</span> <span class="n">function_definitions</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span> <span class="o">=</span> <span class="n">annotated_assigned</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_definitions</span> <span class="o">=</span> <span class="n">function_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_input</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Holds all declared arrays {symbol:domain}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Holds declared array types {symbol:type}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Holds a list of multi-dimensional array symbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Holds all the string assignments along with their length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elif_condition_number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handling_f_args</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_array_arg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># {symbol:index}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated_arrays</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># {symbol: [_list_of_domains_]}</span>
        <span class="c1"># This mapping is required as there may be</span>
        <span class="c1"># a multiple array passes to the function</span>
        <span class="c1"># argument and we do not want to replace one</span>
        <span class="c1"># with another. We need to update all function</span>
        <span class="c1"># argument domains for arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Holds list of modules that program references</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module_variable_types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Holds the list of declared subprograms in modules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module_subprograms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Holds module names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of generated lambda function def. names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generated_lambda_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of user-defined (derived) types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of derived type grfns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_grfn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of attributes declared under user-defined types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># List of variables (objects) declared with user-defined type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Currently handling derived type object name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Currently handling derived type object&#39;s accessing attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_d_object_array_assign</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module_summary</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gensym_tag_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;container&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_def_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Array&quot;</span><span class="p">:</span> <span class="s2">&quot;Array&quot;</span><span class="p">,</span>
            <span class="s2">&quot;character&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;String&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># The binops dictionary holds operators for all the arithmetic and</span>
        <span class="c1"># comparative functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># The annotate_map dictionary is used to map Python ast data types</span>
        <span class="c1"># into data types for the lambdas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="s2">&quot;Real&quot;</span><span class="p">,</span>
            <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Real&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
            <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span>
            <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;array&quot;</span><span class="p">:</span> <span class="s2">&quot;[]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
            <span class="s2">&quot;file_handle&quot;</span><span class="p">:</span> <span class="s2">&quot;fh&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Array&quot;</span><span class="p">:</span> <span class="s2">&quot;Array&quot;</span><span class="p">,</span>
            <span class="s2">&quot;String&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Arithmetic operator dictionary</span>
        <span class="c1"># TODO: Complete the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arithmetic_ops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Add&quot;</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Sub&quot;</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Div&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Mult&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
            <span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
            <span class="s2">&quot;/&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
            <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># The unnecessary_types tuple holds the ast types to ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnecessary_types</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span>
            <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># List of helper library types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">library_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Array&quot;</span><span class="p">,</span> <span class="s2">&quot;String&quot;</span><span class="p">]</span>

        <span class="c1"># Regular expression to match python statements that need to be</span>
        <span class="c1"># bypassed in the GrFN and lambda files. Currently contains I/O</span>
        <span class="c1"># statements.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bypass_io</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^format_\d+$|^format_\d+_obj$|^file_\d+$&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;|^write_list_\d+$|^write_line$|^format_\d+_obj&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;.*|^Format$|^list_output_formats$|&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^write_list_stream$|^file_\d+\.write$|&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^output_fmt$&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">re_bypass_io</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bypass_io</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;ast.FunctionDef&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_function_definition</span><span class="p">,</span>
            <span class="s2">&quot;ast.arguments&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_arguments</span><span class="p">,</span>
            <span class="s2">&quot;ast.arg&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_arg</span><span class="p">,</span>
            <span class="s2">&quot;ast.Load&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_load</span><span class="p">,</span>
            <span class="s2">&quot;ast.Store&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_store</span><span class="p">,</span>
            <span class="s2">&quot;ast.Index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_index</span><span class="p">,</span>
            <span class="s2">&quot;ast.Num&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_num</span><span class="p">,</span>
            <span class="s2">&quot;ast.List&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_list_ast</span><span class="p">,</span>
            <span class="s2">&quot;ast.Str&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_str</span><span class="p">,</span>
            <span class="s2">&quot;ast.For&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_for</span><span class="p">,</span>
            <span class="s2">&quot;ast.If&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_if</span><span class="p">,</span>
            <span class="s2">&quot;ast.UnaryOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_unary_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.BinOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_binary_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.BoolOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_boolean_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.Expr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_expression</span><span class="p">,</span>
            <span class="s2">&quot;ast.Compare&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_compare</span><span class="p">,</span>
            <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subscript</span><span class="p">,</span>
            <span class="s2">&quot;ast.Name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_name</span><span class="p">,</span>
            <span class="s2">&quot;ast.AnnAssign&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_annotated_assign</span><span class="p">,</span>
            <span class="s2">&quot;ast.Assign&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_assign</span><span class="p">,</span>
            <span class="s2">&quot;ast.Tuple&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tuple</span><span class="p">,</span>
            <span class="s2">&quot;ast.Call&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_call</span><span class="p">,</span>
            <span class="s2">&quot;ast.Module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_module</span><span class="p">,</span>
            <span class="s2">&quot;ast.Attribute&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_attribute</span><span class="p">,</span>
            <span class="s2">&quot;ast.AST&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_ast</span><span class="p">,</span>
            <span class="s2">&quot;ast.NameConstant&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_nameconstant</span><span class="p">,</span>
            <span class="s2">&quot;ast.Return&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_return_value</span><span class="p">,</span>
            <span class="s2">&quot;ast.While&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_while</span><span class="p">,</span>
            <span class="s2">&quot;ast.Break&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_break</span><span class="p">,</span>
            <span class="s2">&quot;ast.ClassDef&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_class_def</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="GrFNGenerator.gen_grfn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.gen_grfn">[docs]</a>    <span class="k">def</span> <span class="nf">gen_grfn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function generates the GrFN structure by parsing through the</span>
<span class="sd">            python AST</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Look for code that is not inside any function.</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">function_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span>
        <span class="p">):</span>
            <span class="c1"># If the node is of instance ast.Call, it is the starting point</span>
            <span class="c1"># of the system.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                <span class="n">start_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_container_id_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;@global&quot;</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">start_function_name</span><span class="p">}]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">node_name</span> <span class="o">!=</span> <span class="s2">&quot;ast.Import&quot;</span> <span class="ow">and</span> <span class="n">node_name</span> <span class="o">!=</span> <span class="s2">&quot;ast.ImportFrom&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span><span class="p">[</span><span class="n">node_name</span><span class="p">](</span>
                        <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_list</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unnecessary_types</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_unnecessary_types</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_name</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span><span class="p">[</span><span class="n">node_name</span><span class="p">](</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_nomatch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_list"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_list">[docs]</a>    <span class="k">def</span> <span class="nf">process_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         If there are one or more ast nodes inside the `body` of a node,</span>
<span class="sd">         they appear as a list. Process each node in the list and chain them</span>
<span class="sd">         together into a single list of GrFN dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span> <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_function_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_function_definition">[docs]</a>    <span class="k">def</span> <span class="nf">process_function_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes the function definition i.e. functionDef</span>
<span class="sd">            instance. It appends GrFN dictionaries to the `functions` key in</span>
<span class="sd">            the main GrFN JSON. These dictionaries consist of the</span>
<span class="sd">            function_assign_grfn of the function body and the</span>
<span class="sd">            function_container_grfn of the function. Every call to this</span>
<span class="sd">            function adds these along with the identifier_spec_grfn to the</span>
<span class="sd">            main GrFN JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">return_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">local_last_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_next_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_variable_types</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If the scope_path is empty, add @global to the list to denote that</span>
        <span class="c1"># this is the outermost scope</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;@global&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">:</span>
            <span class="c1"># This is still a work-in-progress function since a complete</span>
            <span class="c1"># representation of SAVEd variables has not been decided for GrFN.</span>
            <span class="c1"># Currently, if the decorator function is static_vars (for</span>
            <span class="c1"># SAVEd variables), their types are loaded in the variable_types</span>
            <span class="c1"># dictionary.</span>
            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="n">local_last_definitions</span><span class="p">,</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="n">local_next_definitions</span><span class="p">,</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_decorators</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">,</span> <span class="n">function_state</span><span class="p">)</span>

        <span class="c1"># Check if the function contains arguments or not. This determines</span>
        <span class="c1"># whether the function is the outermost scope (does not contain</span>
        <span class="c1"># arguments) or it is not (contains arguments). For non-outermost</span>
        <span class="c1"># scopes, indexing starts from -1 (because all arguments will have</span>
        <span class="c1"># an index of -1). For outermost scopes, indexing starts from</span>
        <span class="c1"># normally from 0.</span>
        <span class="c1"># TODO: What do you do when a non-outermost scope function does not</span>
        <span class="c1">#  have arguments. Current assumption is that the function without</span>
        <span class="c1">#  arguments is the outermost function i.e. call to the `start`</span>
        <span class="c1">#  function. But there can be functions without arguments which are not</span>
        <span class="c1">#  the `start` functions but instead some inner functions.</span>

        <span class="c1"># The following is a test to make sure that there is only one</span>
        <span class="c1"># function without arguments and that is the outermost function. All</span>
        <span class="c1"># of the models that we currently handle have this structure and</span>
        <span class="c1"># we&#39;ll have to think about how to handle cases that have more than</span>
        <span class="c1"># one non-argument function.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;There is more than one function &quot;</span>
                <span class="s2">&quot;without arguments in this system. &quot;</span>
                <span class="s2">&quot;This is not currently handled.&quot;</span>
            <span class="p">)</span>

            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="n">local_last_definitions</span><span class="p">,</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="n">local_next_definitions</span><span class="p">,</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
                <span class="n">last_definition_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="p">{},</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="p">{},</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
                <span class="n">last_definition_default</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Get the list of arguments from the function definition</span>
        <span class="n">argument_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">function_state</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>
        <span class="c1"># Keep a map of the arguments for each function. This will be used in</span>
        <span class="c1"># `process_for` to identify arguments which are function arguments</span>
        <span class="c1"># from those that are not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;updated_list&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;updated_indices&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;argument_list&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="s2">&quot;argument_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">argument_list</span>
        <span class="c1"># Update the current scope so that for every identifier inside the</span>
        <span class="c1"># body, the scope information is updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Create the variable definition for the arguments</span>
        <span class="n">argument_variable_grfn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handling_f_args</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
            <span class="n">argument_variable_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">argument</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">function_state</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handling_f_args</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Generate the `variable_identifier_name` for each container argument.</span>
        <span class="c1"># TODO Currently only variables are handled as container arguments.</span>
        <span class="c1">#  Create test cases of other containers as container arguments and</span>
        <span class="c1">#  extend this functionality.</span>
        <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">function_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">argument_list</span>
        <span class="p">]</span>

        <span class="c1"># Enter the body of the function and recursively generate the GrFN of</span>
        <span class="c1"># the function body</span>
        <span class="n">body_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">function_state</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>

        <span class="c1"># Get the `return_value` from the body. We want to append it separately.</span>
        <span class="c1"># TODO There can be multiple return values. `return_value` should be</span>
        <span class="c1">#  a list and you should append to it.</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">body_grfn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">body</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">function</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;return&quot;</span>
                <span class="p">):</span>
                    <span class="n">return_value</span> <span class="o">=</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                    <span class="c1"># Remove the return_value function body from the main</span>
                    <span class="c1"># body as we don&#39;t need that anymore</span>
                    <span class="n">body</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

        <span class="c1"># TODO The return value cannot always be a `variable`. It can be</span>
        <span class="c1">#  literals as well. Add that functionality here.</span>
        <span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">return_value</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;::</span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                            <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">return_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get the function_reference_spec, function_assign_spec and</span>
        <span class="c1"># identifier_spec for the function</span>
        <span class="p">(</span>
            <span class="n">function_variable_grfn</span><span class="p">,</span>
            <span class="n">function_assign_grfn</span><span class="p">,</span>
            <span class="n">body_container_grfn</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_variables_and_functions</span><span class="p">(</span><span class="n">body_grfn</span><span class="p">)</span>
        <span class="c1"># Combine the variable grfn of the arguments with that of the</span>
        <span class="c1"># container body</span>
        <span class="n">container_variables</span> <span class="o">=</span> <span class="n">argument_variable_grfn</span> <span class="o">+</span> <span class="n">function_variable_grfn</span>
        <span class="c1"># Find the list of updated identifiers</span>
        <span class="k">if</span> <span class="n">argument_list</span><span class="p">:</span>
            <span class="n">updated_identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_updated</span><span class="p">(</span>
                <span class="n">argument_variable_grfn</span><span class="p">,</span>
                <span class="n">function_variable_grfn</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_array_arg</span><span class="p">,</span>
                <span class="n">function_state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_array_arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">function_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">updated_arrays</span><span class="p">[</span>
                        <span class="n">array</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">function_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">array</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">updated_identifiers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">][</span>
            <span class="s2">&quot;updated_list&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">updated_identifiers</span>

        <span class="c1"># Get a list of all argument names</span>
        <span class="n">argument_name_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
            <span class="n">argument_name_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Now, find the indices of updated arguments</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">updated_identifiers</span><span class="p">:</span>
            <span class="n">updated_argument</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">argument_index</span> <span class="o">=</span> <span class="n">argument_name_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">updated_argument</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="s2">&quot;updated_indices&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">argument_index</span>
            <span class="p">)</span>

        <span class="c1"># Create a gensym for the function container</span>
        <span class="n">container_gensym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gensym</span><span class="p">(</span><span class="s2">&quot;container&quot;</span><span class="p">)</span>

        <span class="n">container_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_container_id_name</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">container_id_name</span>
        <span class="c1"># Add the function name to the list that stores all the functions</span>
        <span class="c1"># defined in the program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_definitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">container_id_name</span><span class="p">)</span>

        <span class="n">function_container_grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span>
            <span class="s2">&quot;source_refs&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;gensym&quot;</span><span class="p">:</span> <span class="n">container_gensym</span><span class="p">,</span>
            <span class="s2">&quot;repeat&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="n">argument_list</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="n">updated_identifiers</span><span class="p">,</span>
            <span class="s2">&quot;return_value&quot;</span><span class="p">:</span> <span class="n">return_list</span><span class="p">,</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">function_assign_grfn</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">function_container_grfn</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">function_container_grfn</span>
        <span class="p">]</span> <span class="o">+</span> <span class="n">body_container_grfn</span>

        <span class="c1"># function_assign_grfn.append(function_container_grfn)</span>
        <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="n">function_container_grfn</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="n">container_variables</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_arguments"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_arguments">[docs]</a>    <span class="k">def</span> <span class="nf">process_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns a list of arguments defined in a function</span>
<span class="sd">            definition. `node.args` is a list of `arg` nodes which are</span>
<span class="sd">            iteratively processed to get the argument name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_arg"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_arg">[docs]</a>    <span class="k">def</span> <span class="nf">process_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes a function argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Variables are declared as List() objects in the intermediate Python</span>
        <span class="c1"># representation in order to mimic the pass-by-reference property of</span>
        <span class="c1"># Fortran. So, arguments have `annotations` which hold the type() of</span>
        <span class="c1"># A the variable i.e. x[Int], y[Float], etc.</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
        <span class="p">),</span> <span class="s2">&quot;Found argument without annotation. This should not happen.&quot;</span>
        <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_type</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated_arrays</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated_arrays</span><span class="p">[</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">arg</span>
                    <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                    <span class="s2">&quot;Call source is not ast.FunctionDef. &quot;</span>
                    <span class="s2">&quot;Handle this by setting state.last_definitions[&quot;</span>
                    <span class="s2">&quot;node.arg] = 0 in place of the assert False. &quot;</span>
                    <span class="s2">&quot;But this case should not occur in general.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;The argument variable was already defined &quot;</span>
                <span class="s2">&quot;resulting in state.last_definitions containing an &quot;</span>
                <span class="s2">&quot;entry to this argument. Resolve this by setting &quot;</span>
                <span class="s2">&quot;state.last_definitions[node.arg] += 1. But this &quot;</span>
                <span class="s2">&quot;case should not occur in general.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_index"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_index">[docs]</a>    <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the Index node of the ast. The Index node</span>
<span class="sd">            is a `slice` value which appears when a `[]` indexing occurs.</span>
<span class="sd">            For example: x[Real], a[0], etc. So, the `value` of the index can</span>
<span class="sd">            either be an ast.Name (x[Real]) or an ast.Num (a[0]), or any</span>
<span class="sd">            other ast type. So, we forward the `value` to its respective ast</span>
<span class="sd">            handler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_num"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_num">[docs]</a>    <span class="k">def</span> <span class="nf">process_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Num of the ast tree. This node only</span>
<span class="sd">            contains a numeric value in its body. For example: Num(n=0),</span>
<span class="sd">            Num(n=17.27), etc. So, we return the numeric value in a</span>
<span class="sd">            &lt;function_assign_body_literal_spec&gt; form.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_type</span><span class="p">:</span>
            <span class="c1"># TODO Change this format. Since the spec has changed,</span>
            <span class="c1">#  this format is no longer required. Go for a simpler format.</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">}]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unidentified data type of variable: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_list_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_list_ast">[docs]</a>    <span class="k">def</span> <span class="nf">process_list_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles ast.List which represents Python lists. The</span>
<span class="sd">            ast.List has an `elts` element which is a list of all the elements</span>
<span class="sd">            of the list. This is most notably encountered in annotated</span>
<span class="sd">            assignment of variables to [None] (Example: day: List[int] = [</span>
<span class="sd">            None]). This is handled by calling `gen_grfn` on every element of</span>
<span class="sd">            the list i.e. every element of `elts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Currently, this function is encountered only for annotated</span>
        <span class="c1"># assignments of the form, a: List[float] = [None], b: List[float] =</span>
        <span class="c1"># [100], c: List[float] = [(x[0]*y[0])], etc. If any further cases</span>
        <span class="c1"># arise, the following code might need to be rewritten and the</span>
        <span class="c1"># following return code will have to be added as well.</span>
        <span class="c1"># return elements if len(elements) == 1 else [{&quot;list&quot;: elements}]</span>
        <span class="n">element_grfn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">list_element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
            <span class="n">element_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;List&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">element_grfn</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_str"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_str">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_str</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Str of the ast tree. This node only</span>
<span class="sd">            contains a string value in its body. For example: Str(s=&#39;lorem&#39;),</span>
<span class="sd">            Str(s=&#39;Estimate: &#39;), etc. So, we return the string value in a</span>
<span class="sd">            &lt;function_assign_body_literal_spec&gt; form where the dtype is a</span>
<span class="sd">            string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: According to new specification, the following structure</span>
        <span class="c1">#  should be used: {&quot;type&quot;: &quot;literal, &quot;value&quot;: {&quot;dtype&quot;: &lt;type&gt;,</span>
        <span class="c1">#  &quot;value&quot;: &lt;value&gt;}}. Confirm with Clay.</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">s</span><span class="p">}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_for"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_for">[docs]</a>    <span class="k">def</span> <span class="nf">process_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.For node of the AST.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the scope</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;@global&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;loop&quot;</span><span class="p">)</span>

        <span class="c1"># Check: Currently For-Else on Python is not supported</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;For/Else in for not supported.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize intermediate variables</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">container_repeat</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">container_return_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">container_updated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_updated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_input</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_condition_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_condition_inputs_lambda</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_variables_grfn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_functions_grfn</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Increment the loop index universally across the program</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># First, get the `container_id_name` of the loop container</span>
        <span class="n">container_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_container_id_name</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;loop$</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Update the scope of the loop container so that everything inside</span>
        <span class="c1"># the body of the loop will have the below scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="si">}</span><span class="s2">.loop$</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">index_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="c1"># Check: Currently, only one variable is supported as a loop variable</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_variable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="s2">&quot;var&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_variable</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Only one index variable is supported.&quot;</span><span class="p">)</span>
        <span class="n">index_name</span> <span class="o">=</span> <span class="n">index_variable</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>

        <span class="c1"># Define a new empty state that will be used for mapping the state of</span>
        <span class="c1"># the operations within the for-loop container</span>
        <span class="n">loop_last_definition</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">loop_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">loop_last_definition</span><span class="p">,</span>
            <span class="n">next_definitions</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">last_definition_default</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># We want the loop_state to have state information about variables</span>
        <span class="c1"># defined one scope above its current parent scope. The below code</span>
        <span class="c1"># allows us to do that</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                    <span class="c1"># state.last_definitions[var] = \</span>
                    <span class="c1">#     self.parent_loop_state.last_definitions[var]</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">loop_iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="c1"># Check: Only the `range` function is supported as a loop iterator at</span>
        <span class="c1"># this moment</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">loop_iterator</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="ow">or</span> <span class="s2">&quot;call&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_iterator</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">loop_iterator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;range&quot;</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Can only iterate over a range.&quot;</span><span class="p">)</span>

        <span class="n">range_call</span> <span class="o">=</span> <span class="n">loop_iterator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
        <span class="n">loop_condition_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::0&quot;</span><span class="p">)</span>
        <span class="n">loop_condition_inputs_lambda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">range_call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                    <span class="p">)</span>
                    <span class="n">loop_condition_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                    <span class="p">)</span>
                    <span class="n">loop_condition_inputs_lambda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="c1"># TODO: Very specifically for arrays. Will probably break</span>
                    <span class="c1">#  for other calls</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_call_inputs</span><span class="p">(</span>
                        <span class="n">var</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">],</span>
                        <span class="n">function_input</span><span class="p">,</span>
                        <span class="n">container_argument</span><span class="p">,</span>
                        <span class="n">loop_condition_inputs</span><span class="p">,</span>
                        <span class="n">loop_condition_inputs_lambda</span><span class="p">,</span>
                        <span class="n">state</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="n">function_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">function_input</span><span class="p">)</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">container_argument</span>
        <span class="p">)</span>
        <span class="n">loop_condition_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">loop_condition_inputs</span>
        <span class="p">)</span>
        <span class="n">loop_condition_inputs_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">loop_condition_inputs_lambda</span>
        <span class="p">)</span>

        <span class="c1"># Save the current state of the system so that it can used by a</span>
        <span class="c1"># nested loop to get information about the variables declared in its</span>
        <span class="c1"># outermost scopes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span> <span class="o">=</span> <span class="n">state</span>

        <span class="c1"># Define some condition and break variables in the loop state</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>

        <span class="c1"># Now, create the `variable` spec, `function name` and `container</span>
        <span class="c1"># wiring` for the loop index, check condition and break decisions.</span>
        <span class="n">index_variable_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="n">index_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>
        <span class="n">index_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__assign__&quot;</span><span class="p">,</span> <span class="n">index_variable_grfn</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">index_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">index_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="n">loop_check_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>

        <span class="n">loop_state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">loop_check_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__condition__&quot;</span><span class="p">,</span> <span class="n">loop_check_variable</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">loop_condition_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">loop_check_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">loop_condition_inputs</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::IF_0::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="n">loop_break_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">loop_break_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__decision__&quot;</span><span class="p">,</span> <span class="n">loop_break_variable</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">loop_break_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">loop_break_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::IF_0::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::EXIT::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># Create the lambda function for the index variable initiations and</span>
        <span class="c1"># other loop checks. This has to be done through a custom lambda</span>
        <span class="c1"># function operation since the structure of genCode does not conform</span>
        <span class="c1"># with the way this lambda function will be created.</span>
        <span class="c1"># TODO Add code to support a step other than +1 as well</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Only two elements in range &quot;</span> <span class="sa">f</span><span class="s2">&quot;function supported as of now.&quot;</span>
        <span class="p">)</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="n">range_call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">loop_end</span> <span class="o">=</span> <span class="n">range_call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO Add a separate function to get the variables/literals of a</span>
        <span class="c1">#  more complex form. The one below is for the basic case.</span>
        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">loop_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">loop_start_name</span> <span class="o">=</span> <span class="n">loop_start</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">loop_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">loop_start</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="n">loop_start_name</span> <span class="o">=</span> <span class="n">loop_start</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error in getting loop start name&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">loop_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">loop_end_name</span> <span class="o">=</span> <span class="n">loop_end</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">loop_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">loop_end</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="n">loop_end_name</span> <span class="o">=</span> <span class="n">loop_end</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error in getting loop end name&quot;</span>
        <span class="c1"># First, lambda function for loop index initiation</span>
        <span class="n">index_initiation_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="n">loop_start_name</span><span class="p">,</span>
            <span class="n">index_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="p">[],</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_initiation_lambda</span><span class="p">)</span>

        <span class="c1"># Second, lambda function for IF_0_0 test</span>
        <span class="n">loop_test_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;0 &lt;= </span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">{</span><span class="n">loop_end_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">loop_continuation_test_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="n">loop_test_string</span><span class="p">,</span>
            <span class="n">loop_check_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">loop_condition_inputs_lambda</span><span class="p">,</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_continuation_test_lambda</span><span class="p">)</span>

        <span class="c1"># Third, lambda function for EXIT code</span>
        <span class="n">loop_exit_test_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="s2">&quot;IF_0_0&quot;</span><span class="p">,</span>
            <span class="n">loop_break_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="p">[</span><span class="s2">&quot;IF_0_0&quot;</span><span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_exit_test_lambda</span><span class="p">)</span>

        <span class="c1"># Parse through the body of the loop container</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">loop_state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="c1"># Separate the body grfn into `variables` and `functions` sub parts</span>
        <span class="p">(</span>
            <span class="n">body_variables_grfn</span><span class="p">,</span>
            <span class="n">body_functions_grfn</span><span class="p">,</span>
            <span class="n">body_container_grfn</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_variables_and_functions</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

        <span class="c1"># Get a list of all variables that were used as inputs within the</span>
        <span class="c1"># loop body (nested as well).</span>
        <span class="n">loop_body_inputs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get only the dictionaries</span>
        <span class="n">body_functions_grfn</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lambda&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">input_var</span><span class="p">,</span> <span class="n">input_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">input_index</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">input_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_body_inputs</span>
                    <span class="p">):</span>
                        <span class="n">loop_body_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;container&quot;</span><span class="p">:</span>
                <span class="c1"># The same code as above but separating it out just in case</span>
                <span class="c1"># some extra checks are added in the future</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">input_var</span><span class="p">,</span> <span class="n">input_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_index</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">loop_body_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var</span><span class="p">)</span>

        <span class="c1"># Remove any duplicates since variables can be used multiple times in</span>
        <span class="c1"># various assignments within the body</span>
        <span class="n">loop_body_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">loop_body_inputs</span><span class="p">)</span>
        <span class="c1"># If the index name is a part of the loop body, remove it since it is</span>
        <span class="c1"># not an input to the container</span>
        <span class="k">if</span> <span class="n">index_name</span> <span class="ow">in</span> <span class="n">loop_body_inputs</span><span class="p">:</span>
            <span class="n">loop_body_inputs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>

        <span class="c1"># TODO: Not doing this right now. Refine this code and do it then.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Now, we remove the variables which were defined inside the loop</span>
<span class="sd">        # body itself and not taken as an input from outside the loop body</span>
<span class="sd">        filtered_loop_body_inputs = []</span>
<span class="sd">        for input_var in loop_body_inputs:</span>
<span class="sd">            # We filter out those variables which have -1 index in `state` (</span>
<span class="sd">            # which means it did not have a defined value above the loop</span>
<span class="sd">            # body) and is not a function argument (since they have an index</span>
<span class="sd">            # of -1 as well but have a defined value)</span>
<span class="sd">            if not (state.last_definitions[input_var] == -1 and input_var</span>
<span class="sd">            not in</span>
<span class="sd">                    self.function_argument_map[main_function_name][</span>
<span class="sd">                        &quot;argument_list&quot;]</span>
<span class="sd">                    ):</span>
<span class="sd">                filtered_loop_body_inputs.append(input_var)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># for item in filtered_loop_body_inputs:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">loop_body_inputs</span><span class="p">:</span>
            <span class="c1"># TODO Hack for now, this should be filtered off from the code</span>
            <span class="c1">#  block above</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;IF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::-1&quot;</span><span class="p">)</span>

        <span class="n">function_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">function_input</span><span class="p">)</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">container_argument</span>
        <span class="p">)</span>

        <span class="c1"># Creating variable specs for the inputs to the containers.</span>
        <span class="n">start_definitions</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">container_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">container_input_state</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">container_definitions</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">container_argument</span><span class="p">:</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">argument</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
            <span class="n">container_input_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">argument_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">container_input_state</span>
            <span class="p">)</span>
            <span class="n">body_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argument_variable</span><span class="p">)</span>

        <span class="c1"># TODO: Think about removing (or retaining) variables which even</span>
        <span class="c1">#  though defined outside the loop, are defined again inside the loop</span>
        <span class="c1">#  and then used by an operation after it.</span>
        <span class="c1">#  E.g. x = 5</span>
        <span class="c1">#       for ___ :</span>
        <span class="c1">#           x = 2</span>
        <span class="c1">#           for ___:</span>
        <span class="c1">#               y = x + 2</span>
        <span class="c1">#  Here, loop$1 will have `x` as an input but will loop$0 have `x` as</span>
        <span class="c1">#  an input as well?</span>
        <span class="c1">#  Currently, such variables are included in the `input`/`argument`</span>
        <span class="c1">#  field.</span>

        <span class="c1"># Now, we list out all variables that have been updated/defined</span>
        <span class="c1"># inside the body of the loop</span>
        <span class="n">loop_body_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lambda&quot;</span><span class="p">:</span>
                <span class="c1"># TODO Currently, we only deal with a single output variable.</span>
                <span class="c1">#  Modify the line above to not look at only [0] but loop</span>
                <span class="c1">#  through the output to incorporate multiple outputs</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">output_var</span><span class="p">,</span> <span class="n">output_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                    <span class="s2">&quot;::&quot;</span>
                <span class="p">)</span>
                <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">output_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_index</span>
            <span class="k">elif</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;container&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;updated&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">output_var</span><span class="p">,</span> <span class="n">output_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">output_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_index</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">loop_body_outputs</span><span class="p">:</span>
            <span class="c1"># TODO the indexing variables in of function block and container</span>
            <span class="c1">#  block will be different. Figure about the differences and</span>
            <span class="c1">#  implement them.</span>
            <span class="c1"># TODO: Hack, this IF check should not even appear in</span>
            <span class="c1">#  loop_body_outputs</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;IF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="s2">&quot;EXIT&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">updated_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">updated_index</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">function_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">updated_index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_index</span>
                <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">item_id</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">item</span><span class="p">,</span> <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">container_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Create variable spec for updated variables in parent scope.</span>
                <span class="c1"># So, temporarily change the current scope to its previous form</span>
                <span class="n">tmp_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">updated_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>
                <span class="n">body_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_variable</span><span class="p">)</span>
                <span class="c1"># Changing it back to its current form</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="n">tmp_scope</span>

        <span class="c1"># TODO: For the `loop_body_outputs`, all variables that were</span>
        <span class="c1">#  defined/updated inside the loop body are included. Sometimes,</span>
        <span class="c1">#  some variables are defined inside the loop body, used within that</span>
        <span class="c1">#  body and then not used or re-assigned to another value outside the</span>
        <span class="c1">#  loop body. Do we include such variables in the updated list?</span>
        <span class="c1">#  Another heuristic to think about is whether to keep only those</span>
        <span class="c1">#  variables in the `updated` list which are in the `input` list.</span>

        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_variable_grfn</span><span class="p">)</span>
        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_check_variable</span><span class="p">)</span>
        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_variable</span><span class="p">)</span>

        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_function</span><span class="p">)</span>
        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_condition_function</span><span class="p">)</span>
        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_function</span><span class="p">)</span>

        <span class="n">loop_functions_grfn</span> <span class="o">+=</span> <span class="n">body_functions_grfn</span>

        <span class="c1"># Finally, add the index increment variable and function grfn to the</span>
        <span class="c1"># body grfn</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index_increment_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="n">index_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>
        <span class="n">index_increment_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__assign_&quot;</span><span class="p">,</span> <span class="n">index_increment_grfn</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">index_increment_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">index_increment_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::1&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># Finally, lambda function for loop index increment</span>
        <span class="n">index_increment_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2"> + 1&quot;</span><span class="p">,</span>
            <span class="n">index_increment_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="p">[</span><span class="n">index_name</span><span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_increment_lambda</span><span class="p">)</span>

        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_increment_grfn</span><span class="p">)</span>
        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_increment_function</span><span class="p">)</span>

        <span class="n">container_gensym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gensym</span><span class="p">(</span><span class="s2">&quot;container&quot;</span><span class="p">)</span>

        <span class="n">loop_container</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span>
            <span class="s2">&quot;source_refs&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;gensym&quot;</span><span class="p">:</span> <span class="n">container_gensym</span><span class="p">,</span>
            <span class="s2">&quot;repeat&quot;</span><span class="p">:</span> <span class="n">container_repeat</span><span class="p">,</span>
            <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="n">container_argument</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="n">container_updated</span><span class="p">,</span>
            <span class="s2">&quot;return_value&quot;</span><span class="p">:</span> <span class="n">container_return_value</span><span class="p">,</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">loop_functions_grfn</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">loop_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;container&quot;</span><span class="p">},</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">function_input</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">function_output</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="n">function_updated</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">loop_container</span> <span class="o">=</span> <span class="p">[</span><span class="n">loop_container</span><span class="p">]</span> <span class="o">+</span> <span class="n">body_container_grfn</span>
        <span class="n">loop_variables</span> <span class="o">=</span> <span class="n">body_variables_grfn</span> <span class="o">+</span> <span class="n">loop_variables_grfn</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="n">loop_container</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="n">loop_variables</span><span class="p">,</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">loop_function</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># Change the current scope back to its previous form.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_while"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_while">[docs]</a>    <span class="k">def</span> <span class="nf">process_while</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the while loop. The functionality will be</span>
<span class="sd">            very similar to that of the for loop described in `process_for`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the scope</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;@global&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;loop&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize intermediate variables</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">container_repeat</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">container_return_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">container_updated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_updated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_input</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_condition_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_condition_inputs_lambda</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_variables_grfn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loop_functions_grfn</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Increment the loop index universally across the program</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># First, get the `container_id_name` of the loop container</span>
        <span class="n">container_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_container_id_name</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;loop$</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Update the scope of the loop container so that everything inside</span>
        <span class="c1"># the body of the loop will have the below scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="si">}</span><span class="s2">.loop$</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_index</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">loop_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;while&quot;</span><span class="p">)</span>

        <span class="c1"># Define a new empty state that will be used for mapping the state of</span>
        <span class="c1"># the operations within the loop container</span>
        <span class="n">loop_last_definition</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">loop_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">loop_last_definition</span><span class="p">,</span>
            <span class="n">next_definitions</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">last_definition_default</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># We want the loop_state to have state information about variables</span>
        <span class="c1"># defined one scope above its current parent scope. The below code</span>
        <span class="c1"># allows us to do that</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                    <span class="c1"># state.last_definitions[var] = \</span>
                    <span class="c1">#     self.parent_loop_state.last_definitions[var]</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Now populate the IF and EXIT functions for the loop by identifying</span>
        <span class="c1"># the loop conditionals</span>
        <span class="c1"># TODO Add a test to check for loop validity in this area. Need to</span>
        <span class="c1">#  test with more types of while loops to finalize on a test condition</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">loop_test</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                    <span class="p">)</span>
                    <span class="n">loop_condition_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                    <span class="p">)</span>
                    <span class="n">loop_condition_inputs_lambda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="c1"># TODO: Very specifically for arrays. Will probably break</span>
                    <span class="c1">#  for other calls</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_call_inputs</span><span class="p">(</span>
                        <span class="n">var</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">],</span>
                        <span class="n">function_input</span><span class="p">,</span>
                        <span class="n">container_argument</span><span class="p">,</span>
                        <span class="n">loop_condition_inputs</span><span class="p">,</span>
                        <span class="n">loop_condition_inputs_lambda</span><span class="p">,</span>
                        <span class="n">state</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">function_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">function_input</span><span class="p">)</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">container_argument</span>
        <span class="p">)</span>
        <span class="n">loop_condition_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">loop_condition_inputs</span>
        <span class="p">)</span>
        <span class="n">loop_condition_inputs_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">loop_condition_inputs_lambda</span>
        <span class="p">)</span>

        <span class="c1"># Save the current state of the system so that it can used by a</span>
        <span class="c1"># nested loop to get information about the variables declared in its</span>
        <span class="c1"># outermost scopes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_loop_state</span> <span class="o">=</span> <span class="n">state</span>

        <span class="c1"># Define some condition and break variables in the loop state</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>

        <span class="c1"># Now, create the `variable` spec, `function name` and `container</span>
        <span class="c1"># wiring` for the check condition and break decisions.</span>

        <span class="n">loop_check_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;IF_0&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>

        <span class="n">loop_state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">loop_check_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__condition__&quot;</span><span class="p">,</span> <span class="n">loop_check_variable</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">loop_condition_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">loop_check_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">loop_condition_inputs</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::IF_0::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="n">loop_break_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loop_state</span>
        <span class="p">)</span>
        <span class="c1"># Increment the next definition of EXIT</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">loop_break_function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__decision__&quot;</span><span class="p">,</span> <span class="n">loop_break_variable</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">loop_break_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">loop_break_function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::IF_0::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;@variable::EXIT::0&quot;</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># Create the lambda function for the index variable initiations and</span>
        <span class="c1"># other loop checks. This has to be done through a custom lambda</span>
        <span class="c1"># function operation since the structure of genCode does not conform</span>
        <span class="c1"># with the way this lambda function will be created.</span>
        <span class="c1"># TODO Add a separate function to get the variables/literals of a</span>
        <span class="c1">#  more complex form. The one below is for the basic case.</span>

        <span class="c1"># Second, lambda function for IF_0_0 test</span>
        <span class="n">loop_continuation_test_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
            <span class="n">loop_check_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">loop_condition_inputs_lambda</span><span class="p">,</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_continuation_test_lambda</span><span class="p">)</span>

        <span class="c1"># Third, lambda function for EXIT code</span>
        <span class="n">loop_exit_test_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="s2">&quot;IF_0_0&quot;</span><span class="p">,</span>
            <span class="n">loop_break_function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="p">[</span><span class="s2">&quot;IF_0_0&quot;</span><span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">loop_state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_exit_test_lambda</span><span class="p">)</span>
        <span class="c1"># Parse through the body of the loop container</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">loop_state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="c1"># Separate the body grfn into `variables` and `functions` sub parts</span>
        <span class="p">(</span>
            <span class="n">body_variables_grfn</span><span class="p">,</span>
            <span class="n">body_functions_grfn</span><span class="p">,</span>
            <span class="n">body_container_grfn</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_variables_and_functions</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

        <span class="c1"># Get a list of all variables that were used as inputs within the</span>
        <span class="c1"># loop body (nested as well).</span>
        <span class="n">loop_body_inputs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get only the dictionaries</span>
        <span class="n">body_functions_grfn</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lambda&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">input_var</span><span class="p">,</span> <span class="n">input_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">input_index</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">input_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_body_inputs</span>
                    <span class="p">):</span>
                        <span class="n">loop_body_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;container&quot;</span><span class="p">:</span>
                <span class="c1"># The same code as above but separating it out just in case</span>
                <span class="c1"># some extra checks are added in the future</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">input_var</span><span class="p">,</span> <span class="n">input_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="c1"># TODO Hack for bypassing `boolean` types. Will be</span>
                    <span class="c1">#  removed once the `literal` as an input question is</span>
                    <span class="c1">#  answered.</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_index</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">input_var</span> <span class="o">!=</span> <span class="s2">&quot;boolean&quot;</span><span class="p">:</span>
                        <span class="n">loop_body_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var</span><span class="p">)</span>

        <span class="c1"># Remove any duplicates since variables can be used multiple times in</span>
        <span class="c1"># various assignments within the body</span>
        <span class="n">loop_body_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">loop_body_inputs</span><span class="p">)</span>

        <span class="c1"># TODO: Not doing this right now. Refine this code and do it then.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Now, we remove the variables which were defined inside the loop</span>
<span class="sd">        # body itself and not taken as an input from outside the loop body</span>
<span class="sd">        filtered_loop_body_inputs = []</span>
<span class="sd">        for input_var in loop_body_inputs:</span>
<span class="sd">            # We filter out those variables which have -1 index in `state` (</span>
<span class="sd">            # which means it did not have a defined value above the loop</span>
<span class="sd">            # body) and is not a function argument (since they have an index</span>
<span class="sd">            # of -1 as well but have a defined value)</span>
<span class="sd">            if not (state.last_definitions[input_var] == -1 and input_var not in</span>
<span class="sd">                    self.function_argument_map[main_function_name][</span>
<span class="sd">                        &quot;argument_list&quot;]</span>
<span class="sd">                    ):</span>
<span class="sd">                filtered_loop_body_inputs.append(input_var)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># for item in filtered_loop_body_inputs:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">loop_body_inputs</span><span class="p">:</span>
            <span class="c1"># TODO Hack for now, this should be filtered off from the code</span>
            <span class="c1">#  block above</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;IF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::-1&quot;</span><span class="p">)</span>

        <span class="n">function_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">function_input</span><span class="p">)</span>
        <span class="n">container_argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
            <span class="n">container_argument</span>
        <span class="p">)</span>

        <span class="c1"># Creating variable specs for the inputs to the containers.</span>
        <span class="n">start_definitions</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">container_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">container_input_state</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">container_definitions</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">container_argument</span><span class="p">:</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">argument</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
            <span class="n">container_input_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">argument_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">container_input_state</span>
            <span class="p">)</span>
            <span class="n">body_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argument_variable</span><span class="p">)</span>

        <span class="c1"># TODO: Think about removing (or retaining) variables which even</span>
        <span class="c1">#  though defined outside the loop, are defined again inside the loop</span>
        <span class="c1">#  and then used by an operation after it.</span>
        <span class="c1">#  E.g. x = 5</span>
        <span class="c1">#       for ___ :</span>
        <span class="c1">#           x = 2</span>
        <span class="c1">#           for ___:</span>
        <span class="c1">#               y = x + 2</span>
        <span class="c1">#  Here, loop$1 will have `x` as an input but will loop$0 have `x` as</span>
        <span class="c1">#  an input as well?</span>
        <span class="c1">#  Currently, such variables are included in the `input`/`argument`</span>
        <span class="c1">#  field.</span>

        <span class="c1"># Now, we list out all variables that have been updated/defined</span>
        <span class="c1"># inside the body of the loop</span>
        <span class="n">loop_body_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">body_functions_grfn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lambda&quot;</span><span class="p">:</span>
                <span class="c1"># TODO Currently, we only deal with a single output variable.</span>
                <span class="c1">#  Modify the line above to not look at only [0] but loop</span>
                <span class="c1">#  through the output to incorporate multiple outputs</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">output_var</span><span class="p">,</span> <span class="n">output_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                    <span class="s2">&quot;::&quot;</span>
                <span class="p">)</span>
                <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">output_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_index</span>
            <span class="k">elif</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;container&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;updated&quot;</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">output_var</span><span class="p">,</span> <span class="n">output_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                    <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">output_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_index</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">loop_body_outputs</span><span class="p">:</span>
            <span class="c1"># TODO the indexing variables in of function block and container</span>
            <span class="c1">#  block will be different. Figure about the differences and</span>
            <span class="c1">#  implement them.</span>
            <span class="c1"># TODO: Hack, this IF check should not even appear in</span>
            <span class="c1">#  loop_body_outputs</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;IF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="s2">&quot;EXIT&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;EXIT&quot;</span><span class="p">):</span>
                    <span class="n">updated_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">updated_index</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">function_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">updated_index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_index</span>
                <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">item_id</span> <span class="o">=</span> <span class="n">loop_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">item</span><span class="p">,</span> <span class="n">loop_body_outputs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">container_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Create variable spec for updated variables in parent scope.</span>
                <span class="c1"># So, temporarily change the current scope to its previous form</span>
                <span class="n">tmp_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">updated_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>
                <span class="n">body_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">updated_variable</span><span class="p">)</span>
                <span class="c1"># Changing it back to its current form</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="n">tmp_scope</span>

        <span class="c1"># TODO: For the `loop_body_outputs`, all variables that were</span>
        <span class="c1">#  defined/updated inside the loop body are included. Sometimes,</span>
        <span class="c1">#  some variables are defined inside the loop body, used within that</span>
        <span class="c1">#  body and then not used or re-assigned to another value outside the</span>
        <span class="c1">#  loop body. Do we include such variables in the updated list?</span>
        <span class="c1">#  Another heuristic to think about is whether to keep only those</span>
        <span class="c1">#  variables in the `updated` list which are in the `input` list.</span>

        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_check_variable</span><span class="p">)</span>
        <span class="n">loop_variables_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_variable</span><span class="p">)</span>

        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_condition_function</span><span class="p">)</span>
        <span class="n">loop_functions_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_function</span><span class="p">)</span>

        <span class="n">loop_functions_grfn</span> <span class="o">+=</span> <span class="n">body_functions_grfn</span>

        <span class="n">container_gensym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gensym</span><span class="p">(</span><span class="s2">&quot;container&quot;</span><span class="p">)</span>

        <span class="n">loop_container</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span>
            <span class="s2">&quot;source_refs&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;gensym&quot;</span><span class="p">:</span> <span class="n">container_gensym</span><span class="p">,</span>
            <span class="s2">&quot;repeat&quot;</span><span class="p">:</span> <span class="n">container_repeat</span><span class="p">,</span>
            <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="n">container_argument</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="n">container_updated</span><span class="p">,</span>
            <span class="s2">&quot;return_value&quot;</span><span class="p">:</span> <span class="n">container_return_value</span><span class="p">,</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">loop_functions_grfn</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">loop_function</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;container&quot;</span><span class="p">},</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">function_input</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">function_output</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="n">function_updated</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">loop_container</span> <span class="o">=</span> <span class="p">[</span><span class="n">loop_container</span><span class="p">]</span> <span class="o">+</span> <span class="n">body_container_grfn</span>
        <span class="n">loop_variables</span> <span class="o">=</span> <span class="n">body_variables_grfn</span> <span class="o">+</span> <span class="n">loop_variables_grfn</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="n">loop_container</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="n">loop_variables</span><span class="p">,</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">loop_function</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_if"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_if">[docs]</a>    <span class="k">def</span> <span class="nf">process_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.IF node of the AST. It goes through</span>
<span class="sd">            the IF body and generates the `decision` and `condition` type of</span>
<span class="sd">            the `&lt;function_assign_def&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;@global&quot;</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>

        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="c1"># Get the GrFN schema of the test condition of the `IF` command</span>
        <span class="n">condition_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
        <span class="n">condition_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">condition_sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># The index of the IF_x_x variable will start from 0</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># default_if_index = state.last_definition_default + 1</span>
            <span class="n">default_if_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid value of last_definition_default:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">call_source</span> <span class="o">!=</span> <span class="s2">&quot;if&quot;</span><span class="p">:</span>
            <span class="n">condition_number</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;#cond&quot;</span><span class="p">,</span> <span class="n">default_if_index</span>
            <span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">condition_number</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">condition_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;IF_</span><span class="si">{</span><span class="n">condition_number</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">condition_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                <span class="n">condition_name</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">condition_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_condition_number</span>
            <span class="n">condition_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;IF_</span><span class="si">{</span><span class="n">condition_number</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">condition_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                <span class="n">condition_name</span><span class="p">,</span>
                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">condition_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">condition_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">condition_index</span>
        <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
            <span class="p">[</span><span class="n">condition_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
        <span class="p">)</span>
        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
            <span class="s2">&quot;__condition__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="c1"># Getting the output variable</span>
        <span class="n">output_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*::(?P&lt;output&gt;.*?)::(?P&lt;index&gt;.*$)&quot;</span><span class="p">)</span>
        <span class="n">output_match</span> <span class="o">=</span> <span class="n">output_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">output_match</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">output_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
            <span class="n">output_variable</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">condition_output</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not match output variable for &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable_spec</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condition_variables</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
            <span class="p">],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">output_variable</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

        <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
            <span class="n">function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condition_variables</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
            <span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

        <span class="c1"># Tricky thing going on here. The last definitions of `state` are</span>
        <span class="c1"># copied into new variables viz. if_definitions and else_definitions</span>
        <span class="c1"># and then assigned to their respective states i.e. if_state and</span>
        <span class="c1"># else_state. This means that the two dictionaries will populate</span>
        <span class="c1"># independently respective to the contents of their bodies (if-body</span>
        <span class="c1"># and else-body) and also independently from the `state`. However,</span>
        <span class="c1"># the `next_definitions` has not been copied like that which means</span>
        <span class="c1"># the `next_definitions` of `state`, `if_state` and `else_state` are</span>
        <span class="c1"># tied together and get passed around as the same dictionary. This</span>
        <span class="c1"># helps in updating the index of variable across the if and else blocks.</span>
        <span class="n">start_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">if_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">else_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">if_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">if_definitions</span><span class="p">)</span>
        <span class="n">else_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">else_definitions</span><span class="p">)</span>
        <span class="n">if_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">if_state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
        <span class="c1"># Note that `else_grfn` will be empty if the else block contains</span>
        <span class="c1"># another `if-else` block</span>
        <span class="n">else_node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">else_node_name</span> <span class="o">!=</span> <span class="s2">&quot;ast.If&quot;</span><span class="p">:</span>
            <span class="n">else_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">else_state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">else_grfn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elif_condition_number</span> <span class="o">=</span> <span class="n">condition_number</span>

        <span class="c1"># Sometimes, some if-else body blocks only contain I/O operations,</span>
        <span class="c1"># the GrFN for which will be empty. Check for these and handle</span>
        <span class="c1"># accordingly</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;containers&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">else_grfn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elif_condition_number</span> <span class="o">=</span> <span class="n">condition_number</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;insert_break&quot;</span>
        <span class="p">):</span>
            <span class="c1"># Get next def of EXIT</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                <span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="n">else_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">loop_break_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">else_state</span>
            <span class="p">)</span>
            <span class="n">else_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_variable</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">if_grfn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">if_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">if_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">if_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;insert_break&quot;</span>
        <span class="p">):</span>
            <span class="c1"># Get next def of EXIT</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                <span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="n">if_state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">loop_break_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;EXIT&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">if_state</span>
            <span class="p">)</span>
            <span class="n">if_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_break_variable</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">if_grfn</span><span class="p">:</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">else_grfn</span><span class="p">:</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span>

        <span class="n">updated_definitions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">var</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">start_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">if_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">else_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">start_definitions</span>
            <span class="ow">or</span> <span class="n">if_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">else_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="c1"># For every updated variable in the `if-else` block, get a list of</span>
        <span class="c1"># all defined indices of that variable</span>
        <span class="n">defined_versions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">updated_definitions</span><span class="p">:</span>
            <span class="n">defined_versions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">version</span>
                <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">start_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="n">if_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="n">else_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>

        <span class="c1"># There might be cases where a variable is only defined within an `if`</span>
        <span class="c1"># or an `else` block and nowhere within the container. Example below:</span>
        <span class="c1"># while (x &lt; 5):</span>
        <span class="c1">#    a = 2</span>
        <span class="c1">#    if (a &gt; 4):</span>
        <span class="c1">#       a = 2</span>
        <span class="c1">#    else:</span>
        <span class="c1">#       x = 3</span>
        <span class="c1"># Here, `x` will only have one index in `defined_versions`. We add a</span>
        <span class="c1"># `-1&#39; to this defined version</span>
        <span class="k">for</span> <span class="n">updated_definitions</span> <span class="ow">in</span> <span class="n">defined_versions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">defined_versions</span><span class="p">[</span><span class="n">updated_definitions</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">defined_versions</span><span class="p">[</span><span class="n">updated_definitions</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="o">-</span><span class="mi">1</span>
                <span class="p">]</span> <span class="o">+</span> <span class="n">defined_versions</span><span class="p">[</span><span class="n">updated_definitions</span><span class="p">]</span>

        <span class="c1"># For every updated identifier, we need one __decision__ block. So</span>
        <span class="c1"># iterate over all updated identifiers.</span>
        <span class="k">for</span> <span class="n">updated_definition</span> <span class="ow">in</span> <span class="n">defined_versions</span><span class="p">:</span>
            <span class="n">versions</span> <span class="o">=</span> <span class="n">defined_versions</span><span class="p">[</span><span class="n">updated_definition</span><span class="p">]</span>
            <span class="c1"># For `__decision__` nodes, change the index of the inputs into 1</span>
            <span class="c1"># (for True) and 0 (for False) instead of the old indices.</span>
            <span class="c1"># So, a `decision` lambda function will have the false value</span>
            <span class="c1"># first, the true value second, and then the conditional</span>
            <span class="c1"># variable. The fixed version of the lambda will look like</span>
            <span class="c1"># this:</span>
            <span class="c1"># def SIR_Gillespie_SD__gillespie__loop_2__decision__n_S__1(</span>
            <span class="c1"># n_S_0, n_S_1, IF_1):</span>
            <span class="c1">#       return n_S_1 if IF_1 else n_S_0</span>
            <span class="c1"># In the code below, change &quot;index&quot;: 0 to &quot;index&quot;: versions[-1]</span>
            <span class="c1"># and &quot;index&quot;: 1 to &quot;index&quot;: versions[-2] to revert to the old form.</span>
            <span class="c1"># Edit: Now, we are changing this only for the lambda functions.</span>
            <span class="c1"># See the change a few lines below.</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span>
                    <span class="c1"># {&quot;variable&quot;: updated_definition, &quot;index&quot;: 0},</span>
                    <span class="c1"># {&quot;variable&quot;: updated_definition, &quot;index&quot;: 1},</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]},</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]},</span>
                    <span class="n">condition_output</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                    <span class="n">condition_output</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span>
                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                    <span class="n">updated_definition</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">}</span>
            <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="n">updated_definition</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
            <span class="p">)</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
                <span class="s2">&quot;__decision__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span>
                <span class="p">],</span>
                <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span> <span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">],</span>
                <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updated_definition</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
                    <span class="n">condition_output</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">else_node_name</span> <span class="o">==</span> <span class="s2">&quot;ast.If&quot;</span><span class="p">:</span>
            <span class="c1"># else_definitions = state.last_definitions.copy()</span>
            <span class="n">else_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">)</span>
            <span class="n">elseif_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">else_state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">elseif_grfn</span><span class="p">:</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_unary_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_unary_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_unary_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes unary operations in Python represented by</span>
<span class="sd">            ast.UnaryOp. This node has an `op` key which contains the</span>
<span class="sd">            operation (e.g. USub for -, UAdd for +, Not, Invert) and an</span>
<span class="sd">            `operand` key which contains the operand of the operation. This</span>
<span class="sd">            operand can in itself be any Python object (Number, Function</span>
<span class="sd">            call, Binary Operation, Unary Operation, etc. So, iteratively</span>
<span class="sd">            call the respective ast handler for the operand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;unaryop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_binary_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_binary_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_binary_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles binary operations i.e. ast.BinOp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If both the left and right operands are numbers (ast.Num), we can</span>
        <span class="c1"># simply perform the respective operation on these two numbers and</span>
        <span class="c1"># represent this computation in a GrFN spec.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binops</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binops</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)](</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data_type</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span>
                                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unidentified data type of: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Both operands are numbers but no operator &quot;</span>
                <span class="s2">&quot;available to handle their computation. Either add &quot;</span>
                <span class="s2">&quot;a handler if possible or remove this assert and &quot;</span>
                <span class="s2">&quot;allow the code below to handle such cases.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If the operands are anything other than numbers (ast.Str,</span>
        <span class="c1"># ast.BinOp, etc), call `gen_grfn` on each side so their respective</span>
        <span class="c1"># ast handlers will process them and return a [{grfn_spec}, ..] form</span>
        <span class="c1"># for each side. Add these two sides together to give a single [{</span>
        <span class="c1"># grfn_spec}, ...] form.</span>
        <span class="n">operation_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation_grfn</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_boolean_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_boolean_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_boolean_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function will process the ast.BoolOp node that handles</span>
<span class="sd">            boolean operations i.e. AND, OR, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: No example of this to test on. This looks like deprecated</span>
        <span class="c1">#  format. Will need to be rechecked.</span>
        <span class="n">grfn_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="p">{</span><span class="n">ast</span><span class="o">.</span><span class="n">And</span><span class="p">:</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Or</span><span class="p">:</span> <span class="s2">&quot;or&quot;</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">operation</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">grfn_list</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s2">&quot;boolean_operation&quot;</span><span class="p">:</span> <span class="n">operation</span><span class="p">[</span><span class="n">key</span><span class="p">]}])</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">grfn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;boolop&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">grfn_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_unnecessary_types"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_unnecessary_types">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_unnecessary_types</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles various ast tags which are unnecessary and</span>
<span class="sd">            need not be handled since we do not require to parse them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2">, which should be unnecessary&quot;</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_expression"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_expression">[docs]</a>    <span class="k">def</span> <span class="nf">process_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Expr node i.e. the expression node.</span>
<span class="sd">            This node appears on function calls such as when calling a</span>
<span class="sd">            function, calling print(), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;expr&quot;</span><span class="p">)</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unsupported expr: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="n">array_set</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">string_set</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">container_id_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">input_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">output_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">arr_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">call</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
            <span class="n">io_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">io_match</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="c1"># Bypassing calls to `print` for now. Need further discussion and</span>
            <span class="c1"># decisions to move forward with what we&#39;ll do with `print`</span>
            <span class="c1"># statements.</span>
            <span class="k">if</span> <span class="n">function_name</span> <span class="o">==</span> <span class="s2">&quot;print&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c1"># A handler for array and string &lt;.set_&gt;/&lt;.set_substr&gt; function</span>
            <span class="k">if</span> <span class="s2">&quot;.set_&quot;</span> <span class="ow">in</span> <span class="n">function_name</span><span class="p">:</span>
                <span class="n">split_function</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">is_derived_type_array_ref</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">split_function</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span>
                <span class="p">):</span>
                    <span class="n">d_object</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">call_var</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">is_derived_type_array_ref</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">call_var</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">split_function</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># This is an array</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;set_substr&quot;</span><span class="p">:</span>
                    <span class="n">array_set</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.set_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_function</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">input_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                            <span class="n">split_function</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">output_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                            <span class="n">split_function</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_derived_type_array_ref</span><span class="p">:</span>
                        <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
                        <span class="n">input_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                            <span class="n">function_name</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">output_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                            <span class="n">function_name</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span>
                            <span class="n">function_name</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">call_var</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">call_var</span><span class="p">]</span>

                    <span class="n">arr_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_array_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">str_arr_index</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">str_arr_for_varname</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">arr_index</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">function_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_array</span><span class="p">:</span>
                            <span class="n">str_arr_index</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                            <span class="n">str_arr_for_varname</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">str_arr_index</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">]&quot;</span>
                            <span class="n">str_arr_for_varname</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="c1"># arr_index = call[&quot;inputs&quot;][0][0][&quot;var&quot;][&quot;variable&quot;]</span>
                    <span class="c1"># Create a new variable spec for indexed array. Ex.</span>
                    <span class="c1"># arr(i) will be arr_i. This will be added as a new</span>
                    <span class="c1"># variable in GrFN.</span>
                    <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">function_name</span><span class="p">],</span> <span class="n">str_arr_for_varname</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                    <span class="p">)</span>
                    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">function_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_array</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">str_arr_index</span><span class="si">}</span><span class="s2">]&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}{</span><span class="n">str_arr_index</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="c1"># We want to have a new variable spec for the original</span>
                    <span class="c1"># array (arr(i), for example) and generate the function</span>
                    <span class="c1"># name with it.</span>
                    <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">function_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                    <span class="p">)</span>
                    <span class="n">assign_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
                        <span class="s2">&quot;__assign__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">arr_index</span>
                    <span class="p">)</span>
                    <span class="n">container_id_name</span> <span class="o">=</span> <span class="n">assign_function</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                    <span class="n">function_type</span> <span class="o">=</span> <span class="n">assign_function</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                <span class="c1"># This is a string</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">string_set</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">function_name</span> <span class="o">=</span> <span class="n">call_var</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span> <span class="o">=</span> <span class="n">function_name</span>
                    <span class="n">input_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                        <span class="n">function_name</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">function_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                    <span class="p">)</span>
                    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>
                    <span class="n">assign_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
                        <span class="s2">&quot;__assign__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
                    <span class="p">)</span>
                    <span class="n">container_id_name</span> <span class="o">=</span> <span class="n">assign_function</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                    <span class="n">function_type</span> <span class="o">=</span> <span class="n">assign_function</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">:</span>
                    <span class="n">container_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span>
                        <span class="n">function_name</span>
                    <span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_subprograms</span><span class="p">:</span>
                    <span class="n">container_id_name</span> <span class="o">=</span> <span class="n">function_name</span>
                <span class="n">function_type</span> <span class="o">=</span> <span class="s2">&quot;container&quot;</span>

            <span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_id_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">function_type</span><span class="p">},</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>

            <span class="c1"># Array itself needs to be added as an input, so check that it&#39;s</span>
            <span class="c1"># and array. If yes, then add it manually.</span>
            <span class="k">if</span> <span class="n">array_set</span><span class="p">:</span>
                <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">function</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">output_index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">]</span>

            <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">list_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                <span class="c1"># We handle inputs to strings differently, so break out of</span>
                <span class="c1"># this loop</span>
                <span class="k">if</span> <span class="n">string_set</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">generate_lambda_for_arr</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># TODO: Only variables are represented in function</span>
                    <span class="c1">#  arguments. But a function can have strings as</span>
                    <span class="c1">#  arguments as well. Do we add that?</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
                            <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="c1"># This is a case where a variable gets assigned to</span>
                        <span class="c1"># an array. For example, arr(i) = var.</span>
                        <span class="k">if</span> <span class="n">array_set</span><span class="p">:</span>
                            <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                            <span class="c1"># If list_index is 0, it means that the current</span>
                            <span class="c1"># loop is dealing with the array index (i in arr(</span>
                            <span class="c1"># i)), which we do not wish to generate a lambda</span>
                            <span class="c1"># function for. list_index &gt; 0 are the RHS values</span>
                            <span class="c1"># for array assignment.</span>
                            <span class="k">if</span> <span class="n">list_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">generate_lambda_for_arr</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">list_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># This is a case where either an expression or an array</span>
                    <span class="c1"># gets assigned to an array. For example, arr(i) =</span>
                    <span class="c1"># __expression__ or arr(i) = arr2(i).</span>
                    <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># Check if a function argument is a string value</span>
                        <span class="c1"># E.g: GET(&quot;test&quot;, &quot;this&quot;, x)</span>
                        <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                                <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;@literal::&quot;</span> <span class="sa">f</span><span class="s2">&quot;string::&quot;</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_array_setter</span><span class="p">(</span>
                                <span class="n">node</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="p">,</span> <span class="n">container_id_name</span><span class="p">,</span>
                                <span class="n">arr_index</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="c1"># This is a case where a literal gets assigned to an array.</span>
                    <span class="c1"># For example, arr(i) = 100.</span>
                    <span class="k">elif</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">array_set</span><span class="p">:</span>
                        <span class="n">generate_lambda_for_arr</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">generate_lambda_for_arr</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="p">:</span>
                        <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
                        <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                            <span class="n">node</span><span class="p">,</span>
                            <span class="n">container_id_name</span><span class="p">,</span>
                            <span class="kc">True</span><span class="p">,</span>
                            <span class="kc">True</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                            <span class="n">argument_list</span><span class="p">,</span>
                            <span class="n">state</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
                        <span class="c1"># If array type is &lt;float&gt; the argument holder</span>
                        <span class="c1"># has a different structure that it does not hold</span>
                        <span class="c1"># function info. like when an array is &#39;int&#39; type</span>
                        <span class="c1"># [{&#39;call&#39;: {&#39;function&#39;: &#39;_type_&#39;, &#39;inputs&#39;: [...]]</span>
                        <span class="c1"># which causes an error. Thus, the code below fixes</span>
                        <span class="c1"># by correctly structuring it.</span>
                        <span class="n">array_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">function_name</span><span class="p">][</span><span class="s2">&quot;elem_type&quot;</span><span class="p">]</span>
                        <span class="n">fixed_arg</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">array_type</span><span class="p">,</span> <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">arg</span><span class="p">]}}</span>
                        <span class="p">]</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_array_setter</span><span class="p">(</span>
                            <span class="n">node</span><span class="p">,</span>
                            <span class="n">function</span><span class="p">,</span>
                            <span class="n">fixed_arg</span><span class="p">,</span>
                            <span class="n">function_name</span><span class="p">,</span>
                            <span class="n">container_id_name</span><span class="p">,</span>
                            <span class="n">arr_index</span><span class="p">,</span>
                            <span class="n">state</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="p">(</span>
                            <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">),</span> <span class="s2">&quot;Only 1 input per argument supported right now.&quot;</span>

            <span class="c1"># Below is a separate loop just for filling in inputs for arrays</span>
            <span class="k">if</span> <span class="n">array_set</span><span class="p">:</span>
                <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">need_lambdas</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                            <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ip</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ip</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">ip</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
                                <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                            <span class="n">function_call</span> <span class="o">=</span> <span class="n">ip</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
                            <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                            <span class="n">need_lambdas</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="s2">&quot;.get_&quot;</span> <span class="ow">in</span> <span class="n">function_name</span><span class="p">:</span>
                                <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                    <span class="s2">&quot;.get_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                                <span class="p">)</span>
                                <span class="c1"># In some cases, the target array itself will</span>
                                <span class="c1"># be an input as well. Don&#39;t add such arrays</span>
                                <span class="c1"># again.</span>
                                <span class="k">if</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                                    <span class="n">function_name</span> <span class="ow">in</span> <span class="n">i</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>
                                <span class="p">]:</span>
                                    <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">::&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="p">)</span>
                                <span class="k">if</span> <span class="n">function_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
                                    <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">call_input</span> <span class="ow">in</span> <span class="n">function_call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                                <span class="c1"># TODO: This is of a recursive nature. Make</span>
                                <span class="c1">#  this a loop. Works for SIR for now.</span>
                                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">call_input</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                                        <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                            <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                                        <span class="k">if</span> <span class="p">(</span>
                                            <span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                                            <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span>
                                        <span class="p">):</span>
                                            <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                                <span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                                            <span class="p">)</span>

                <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span>
                    <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">argument_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">argument_list</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">need_lambdas</span>
                    <span class="ow">and</span> <span class="n">container_id_name</span>
                    <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_lambda_functions</span>
                <span class="p">):</span>
                    <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">,</span>
                        <span class="n">container_id_name</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="n">argument_list</span><span class="p">,</span>
                        <span class="n">state</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
                    <span class="n">need_lambdas</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Make an assign function for a string .set_ operation</span>
            <span class="k">if</span> <span class="n">string_set</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">source_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]))</span>

                <span class="c1"># If the function is `set_substr`, the target string will</span>
                <span class="c1"># also be an input.</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;set_substr&quot;</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span>
                                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span>
                                    <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="p">)</span>
                                <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">)</span>
                <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span>
                    <span class="n">assign_function</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">source_list</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>

                <span class="n">argument_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">source_list</span><span class="p">)</span>

                <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">container_id_name</span><span class="p">,</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="n">argument_list</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="c1"># This is sort of a hack for SIR to get the updated fields filled</span>
            <span class="c1"># in beforehand. For a generalized approach, look at</span>
            <span class="c1"># `process_module`.</span>
            <span class="k">if</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;container&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">functions</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">functions</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                        <span class="o">==</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                    <span class="p">):</span>

                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                            <span class="n">input_var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">input_var</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">input_var</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_array_arg</span>
                                <span class="ow">or</span> <span class="n">var</span>
                                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">functions</span><span class="p">][</span>
                                    <span class="s2">&quot;updated_list&quot;</span>
                                <span class="p">]</span>
                            <span class="p">):</span>
                                <span class="n">variable_name</span> <span class="o">=</span> <span class="n">input_var</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">function</span><span class="p">[</span><span class="s2">&quot;updated&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>

                                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">variable_name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="n">variable_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">variable_name</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="p">)</span>

                                <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">variable_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
                                <span class="p">)</span>
                                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>
            <span class="c1"># Keep a track of all functions whose `update` might need to be</span>
            <span class="c1"># later updated, along with their scope.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># self.update_functions.append(function_name)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_functions</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="p">,</span>
                    <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_compare"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_compare">[docs]</a>    <span class="k">def</span> <span class="nf">process_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles ast.Compare i.e. the comparator tag which</span>
<span class="sd">            appears on logical comparison i.e. ==, &lt;, &gt;, &lt;=, etc. This</span>
<span class="sd">            generally occurs within an `if` statement but can occur elsewhere</span>
<span class="sd">            as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_subscript"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_subscript">[docs]</a>    <span class="k">def</span> <span class="nf">process_subscript</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Subscript i.e. subscript tag of the</span>
<span class="sd">            ast. This tag appears on variable names that are indexed i.e.</span>
<span class="sd">            x[0], y[5], var[float], etc. Subscript nodes will have a `slice`</span>
<span class="sd">            tag which gives a information inside the [] of the call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The value inside the [] should be a number for now.</span>
        <span class="c1"># TODO: Remove this and handle further for implementations of arrays,</span>
        <span class="c1">#  reference of dictionary item, etc</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;can&#39;t handle arrays right now.&quot;</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;subscript&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;No variable name found for subscript node.&quot;</span>

        <span class="k">return</span> <span class="n">val</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_name">[docs]</a>    <span class="k">def</span> <span class="nf">process_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Name node of the AST. This node</span>
<span class="sd">            represents any variable in the code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Currently, bypassing any `i_g_n_o_r_e___m_e__` variables which are</span>
        <span class="c1"># used for comment extraction.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;i_g_n_o_r_e___m_e__.*&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="n">last_definition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;annassign&quot;</span>
            <span class="p">):</span>
                <span class="n">last_definition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_definition</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># TODO Change this structure. This is not required for the new</span>
            <span class="c1">#  spec. It made sense for the old spec but now it is not required.</span>
            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">last_definition</span><span class="p">}}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_annotated_assign"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_annotated_assign">[docs]</a>    <span class="k">def</span> <span class="nf">process_annotated_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles annotated assignment operations i.e.</span>
<span class="sd">            ast.AnnAssign. This tag appears when a variable has been assigned</span>
<span class="sd">            with an annotation e.g. x: int = 5, y: List[float] = [None], etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the sources and targets of the annotated assignment</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
        <span class="c1"># If the source i.e. assigned value is `None` (e.g. day: List[int] =</span>
        <span class="c1"># [None]), only update the data type of the targets and populate the</span>
        <span class="c1"># `annotated_assigned` map. No further processing will be done.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="ow">and</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span>
                    <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>

                <span class="c1"># Check if these variables are io variables. We don&#39;t maintain</span>
                <span class="c1"># states for io variables. So, don&#39;t add them on the</span>
                <span class="c1"># last_definitions and next_definitions dict.</span>
                <span class="n">io_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">io_match</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                <span class="c1"># When a variable is AnnAssigned with [None] it is being</span>
                <span class="c1"># declared but not defined. So, it should not be assigned an</span>
                <span class="c1"># index. Having the index as -2 indicates that this variable</span>
                <span class="c1"># has only been declared but never defined. The next</span>
                <span class="c1"># definition of this variable should start with an index of 0</span>
                <span class="c1"># though.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">io_match</span><span class="p">:</span>
                    <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="c1"># Only a single target appears in the current version. The `for` loop</span>
        <span class="c1"># seems unnecessary but will be required when multiple targets start</span>
        <span class="c1"># appearing (e.g. a = b = 5).</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">target_name</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
            <span class="c1"># Because we use the `last_definition_default` to be -1 for</span>
            <span class="c1"># functions with arguments, in these functions the annotated</span>
            <span class="c1"># assigns at the top of the function will get the -1 index which</span>
            <span class="c1"># is incorrect.</span>
            <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">target_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Preprocessing and removing certain Assigns which only pertain</span>
            <span class="c1"># to the Python code and do not relate to the FORTRAN code in any</span>
            <span class="c1"># way.</span>
            <span class="n">io_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">io_match</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">target_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_type</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">target_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
            <span class="c1"># Update the `next_definition` index of the target since it is</span>
            <span class="c1"># not being explicitly done by `process_name`.</span>
            <span class="c1"># TODO Change this functionality ground up by modifying</span>
            <span class="c1">#  `process_name` and `process_subscript` to make it simpler.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_name</span><span class="p">):</span>
                <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="n">target_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>
            <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="p">[</span><span class="n">target_name</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">state</span>
            <span class="p">)</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
                <span class="s2">&quot;__assign__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="c1"># If the source is a list inside of a list, remove the outer list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># TODO Somewhere around here, the Float32 class problem will have</span>
            <span class="c1">#  to be handled.</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                    <span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
            <span class="c1"># In the case of assignments of the form: &quot;ud: List[float]&quot;</span>
            <span class="c1"># an assignment function will be created with an empty input</span>
            <span class="c1"># list. Also, the function dictionary will be empty. We do</span>
            <span class="c1"># not want such assignments in the GrFN so check for an empty</span>
            <span class="c1"># &lt;fn&gt; dictionary and return [] if found</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_assign"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_assign">[docs]</a>    <span class="k">def</span> <span class="nf">process_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles an assignment operation (ast.Assign).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">io_source</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_function_call</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">maybe_d_type_object_assign</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d_type_object_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Get the GrFN element of the RHS side of the assignment which are</span>
        <span class="c1"># the variables involved in the assignment operations.</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>

        <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">node_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Attribute&quot;</span><span class="p">:</span>
            <span class="n">node_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">attrib_ast</span> <span class="o">=</span> <span class="n">node_value</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">attrib_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Name&quot;</span>
                <span class="ow">and</span> <span class="n">node_value</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span>
            <span class="p">):</span>
                <span class="n">maybe_d_type_object_assign</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">d_type_object_name</span> <span class="o">=</span> <span class="n">node_value</span><span class="o">.</span><span class="n">id</span>
                <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span><span class="p">[</span><span class="n">d_type_object_name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">attrib_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Attribute&quot;</span>
                <span class="ow">and</span> <span class="n">node_value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span>
            <span class="p">):</span>
                <span class="n">maybe_d_type_object_assign</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">d_type_object_name</span> <span class="o">=</span> <span class="n">node_value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
                <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span><span class="p">[</span><span class="n">d_type_object_name</span><span class="p">]</span>

        <span class="n">array_assignment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_d_type_obj_declaration</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Detect assigns which are string initializations of the</span>
        <span class="c1"># following form: String(10). String initialization of the form</span>
        <span class="c1"># String(10, &quot;abcdef&quot;) are valid assignments where the index of the</span>
        <span class="c1"># variables will be incremented but for the former case the index</span>
        <span class="c1"># will not be incremented and neither will its variable spec be</span>
        <span class="c1"># generated</span>
        <span class="n">is_string_assign</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_string_annotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">type_name</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                <span class="n">is_string_assign</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Check if it just an object initialization or initialization</span>
                <span class="c1"># with value assignment</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># This is just an object initialization e.g. String(10)</span>
                    <span class="n">is_string_annotation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;Array&quot;</span><span class="p">:</span>
                <span class="n">array_assignment</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">array_dimensions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span>

                <span class="c1"># If the array type is string, the structure of inputs will</span>
                <span class="c1"># be a bit different than when it is int of float</span>
                <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                        <span class="n">array_type</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">array_type</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_dimension</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">array_dimensions</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="p">:</span>
                <span class="n">is_d_type_obj_declaration</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                    <span class="n">variable_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                    <span class="k">if</span> <span class="n">variable_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_variable_types</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">program</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;public_objects&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">variable_name</span>
                                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;public_objects&quot;</span><span class="p">][</span><span class="n">program</span><span class="p">]</span>
                            <span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">module_variable_types</span><span class="p">[</span><span class="n">variable_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                    <span class="n">program</span><span class="p">,</span>
                                    <span class="n">type_name</span><span class="p">,</span>
                                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># This reduce function is useful when a single assignment operation</span>
        <span class="c1"># has multiple targets (E.g: a = b = 5). Currently, the translated</span>
        <span class="c1"># python code does not appear in this way and only a single target</span>
        <span class="c1"># will be present.</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="c1"># Again as above, only a single target appears in current version.</span>
        <span class="c1"># The `for` loop seems unnecessary but will be required when multiple</span>
        <span class="c1"># targets start appearing.</span>
        <span class="n">target_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">object_attr_num</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="c1"># Bypass any assigns that have multiple targets.</span>
            <span class="c1"># E.g. (i[0], x[0], j[0], y[0],) = ...</span>
            <span class="k">if</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">target_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="c1"># Fill some data structures if this is a string</span>
            <span class="c1"># assignment/initialization</span>
            <span class="k">if</span> <span class="n">is_string_assign</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
                <span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span> <span class="o">=</span> <span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">is_string_annotation</span><span class="p">:</span>
                    <span class="c1"># If this is just a string initialization,</span>
                    <span class="c1"># last_definition should not contain this string&#39;s index.</span>
                    <span class="c1"># This happens only during assignments.</span>
                    <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;annotation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;annotation_assign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;annotation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;annotation_assign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Pre-processing and removing certain Assigns which only pertain</span>
            <span class="c1"># to the Python code and do not relate to the FORTRAN code in any</span>
            <span class="c1"># way.</span>
            <span class="n">io_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">io_match</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c1"># If the target is a list of variables, the grfn notation for the</span>
            <span class="c1"># target will be a list of variable names i.e. &quot;[a, b, c]&quot;</span>
            <span class="c1"># TODO: This does not seem right. Discuss with Clay and Paul</span>
            <span class="c1">#  about what a proper notation for this would be</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;list&quot;</span><span class="p">):</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">targets</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>

            <span class="k">if</span> <span class="n">array_assignment</span><span class="p">:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="n">var_name</span>
                <span class="c1"># Just like the same reason as the variables</span>
                <span class="c1"># declared with annotation within function (not</span>
                <span class="c1"># function arguments) need to have index of zero.</span>
                <span class="c1"># Thus, these 3 lines of code fixes the index to</span>
                <span class="c1"># correct value from -1 to 0.</span>
                <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">is_mutable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">array_info</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="n">array_dimensions</span><span class="p">,</span>
                    <span class="s2">&quot;elem_type&quot;</span><span class="p">:</span> <span class="n">array_type</span><span class="p">,</span>
                    <span class="s2">&quot;mutable&quot;</span><span class="p">:</span> <span class="n">is_mutable</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_info</span>
                <span class="n">state</span><span class="o">.</span><span class="n">array_types</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_type</span>
                <span class="k">if</span> <span class="n">array_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">length</span><span class="p">,</span>
                        <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="s2">&quot;annotated_assign&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">maybe_d_type_object_assign</span>
                <span class="ow">and</span> <span class="n">object_type</span>
                <span class="ow">and</span> <span class="n">object_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span>
                <span class="ow">and</span> <span class="n">target_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span><span class="p">[</span><span class="n">object_type</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span> <span class="o">=</span> <span class="n">d_type_object_name</span>
                <span class="n">is_d_type_object_assignment</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># If targets holds more than 1 variable information and</span>
                <span class="c1"># it&#39;s greater than the object attribute number, then</span>
                <span class="c1"># the derived type object is referencing more than</span>
                <span class="c1"># 1 attribute (i.e. x.k.v).</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">object_attr_num</span><span class="p">:</span>
                    <span class="n">object_attr_num</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># Therefore, we do not want to go any further before</span>
                    <span class="c1"># collecting all the information of the attribute</span>
                    <span class="c1"># information, so we need to simply return back to the</span>
                    <span class="c1"># beginning of loop and restart the process</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_d_type_object_assignment</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                <span class="n">target_names</span><span class="p">,</span>
                <span class="n">d_type_object_name</span><span class="p">,</span>
                <span class="n">is_d_type_object_assignment</span><span class="p">,</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Do not add the variable spec if this is a string annotation</span>
            <span class="c1"># since this can collide with the variable spec of the first</span>
            <span class="c1"># string assignment.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string_annotation</span><span class="p">:</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>

            <span class="c1"># Since a Python class (derived type) object declaration has syntax</span>
            <span class="c1"># is __object_name__ = __class_name__, it&#39;s considered as an</span>
            <span class="c1"># assignment that will create __assign__ function GrFN,</span>
            <span class="c1"># which should not. Thus, simply return the [grfn] here to avoid</span>
            <span class="c1"># generating __assign__ function.</span>
            <span class="k">if</span> <span class="n">is_d_type_obj_declaration</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span>

            <span class="c1"># TODO Hack to not print lambda function for IO assigns. Need a</span>
            <span class="c1">#  proper method to handle IO moving on</span>
            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]):</span>
                        <span class="n">io_source</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                    <span class="c1"># Check if the source is a function call by comparing its</span>
                    <span class="c1"># value with the list of functions in our program (</span>
                    <span class="c1"># obtained from the mode mapper)</span>
                    <span class="k">for</span> <span class="n">program_functions</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;subprograms&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">function</span>
                            <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;subprograms&quot;</span><span class="p">][</span>
                                <span class="n">program_functions</span>
                            <span class="p">]</span>
                        <span class="p">):</span>
                            <span class="n">is_function_call</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">is_function_call</span><span class="p">:</span>
                <span class="n">container_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_container_id_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;@global&quot;</span><span class="p">],</span> <span class="n">function</span>
                <span class="p">)</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">container_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;container&quot;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_function_name</span><span class="p">(</span>
                    <span class="s2">&quot;__assign__&quot;</span><span class="p">,</span> <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="kc">None</span>
                <span class="p">)</span>
            <span class="c1"># If current assignment process is for a derived type object (i.e</span>
            <span class="c1"># x.k), then</span>
            <span class="k">if</span> <span class="n">is_d_type_object_assignment</span><span class="p">:</span>
                <span class="c1"># (1) we need to add derived type object as function input.</span>
                <span class="n">src</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">d_type_object_name</span><span class="p">,</span>
                            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span>
                                <span class="n">d_type_object_name</span>
                            <span class="p">],</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">]</span>
                <span class="n">sources</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

                <span class="c1"># (2) Generate the object name + attributes variable name</span>
                <span class="n">new_var_name</span> <span class="o">=</span> <span class="n">d_type_object_name</span>
                <span class="k">for</span> <span class="n">target_name</span> <span class="ow">in</span> <span class="n">target_names</span><span class="p">:</span>
                    <span class="n">new_var_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>

                <span class="c1"># (3) we need to modify thee target to be &quot;objectName_attribute&quot;</span>
                <span class="c1"># For example, variable: x_k and index: __index_of_x_y__.</span>
                <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">new_var_name</span><span class="p">,</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">new_var_name</span><span class="p">],</span>
                <span class="p">}</span>

            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">source_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">io_source</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_function_call</span><span class="p">:</span>
                <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">function_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="n">array_assignment</span><span class="p">,</span>
                    <span class="n">is_string_assign</span><span class="p">,</span>
                    <span class="n">is_d_type_object_assignment</span><span class="p">,</span>
                    <span class="n">source_list</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="c1"># We need to cleanup the object attribute tracking list.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_tuple"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_tuple">[docs]</a>    <span class="k">def</span> <span class="nf">process_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Tuple node of the AST. This handled</span>
<span class="sd">            in the same way `process_list_ast` is handled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;ctx&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">list_element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span>
            <span class="p">]</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">elements</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[{</span><span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">elements</span><span class="p">}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_call">[docs]</a>    <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Call node of the AST. This node</span>
<span class="sd">            denotes the call to a function. The body contains of the function</span>
<span class="sd">            name and its arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the call is in the form of &lt;module&gt;.&lt;function&gt; (E.g.</span>
        <span class="c1"># math.exp, math.cos, etc). The `module` part here is captured by the</span>
        <span class="c1"># attribute tag.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
            <span class="c1"># Check if there is a &lt;sys&gt; call. Bypass it if exists.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;sys&quot;</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">function_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span>
            <span class="c1"># The `function_node` can be a ast.Name (e.g. Format(format_10)</span>
            <span class="c1"># where `format_10` will be an ast.Name or it can have another</span>
            <span class="c1"># ast.Attribute (e.g. Format(main.file_10.readline())).</span>
            <span class="c1"># Currently, only these two nodes have been detected, so test for</span>
            <span class="c1"># these will be made.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_node</span><span class="o">.</span><span class="n">attr</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">function_name</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
                <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">function_node</span><span class="o">.</span><span class="n">attr</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_d_object_array_assign</span><span class="p">:</span>
                    <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_d_object_array_assign</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">function_name</span> <span class="o">+=</span> <span class="n">module</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">func_name</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid expression call </span><span class="si">{</span><span class="n">function_node</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>

        <span class="n">call</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">}}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">call</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_module"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_module">[docs]</a>    <span class="k">def</span> <span class="nf">process_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Module node in the AST. The module</span>
<span class="sd">            node is the starting point of the AST and its body consists of</span>
<span class="sd">            the entire ast of the python code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grfn_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="n">grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">grfn</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;@type&quot;</span> <span class="ow">in</span> <span class="n">grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grfn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grfn_list</span> <span class="o">+=</span> <span class="n">grfn</span>
        <span class="n">merged_grfn</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_merge_dictionary</span><span class="p">(</span><span class="n">grfn_list</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">merged_grfn</span>
        <span class="c1"># TODO Implement this. This needs to be done for generality</span>
        <span class="c1"># We fill in the `updated` field of function calls by looking at the</span>
        <span class="c1"># `updated` field of their container grfn</span>
        <span class="n">final_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_updated</span><span class="p">(</span><span class="n">merged_grfn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_grfn</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_nameconstant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="c1"># TODO Change this format according to the new spec</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;boolean&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">}]</span>

<div class="viewcode-block" id="GrFNGenerator.process_attribute"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">process_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Handle Attributes: This is a fix on `feature_save` branch to</span>
<span class="sd">            bypass the SAVE statement feature where a SAVEd variable is</span>
<span class="sd">            referenced as &lt;function_name&gt;.&lt;variable_name&gt;. So the code below</span>
<span class="sd">            only returns the &lt;variable_name&gt; which is stored under</span>
<span class="sd">            `node.attr`. The `node.id` stores the &lt;function_name&gt; which is</span>
<span class="sd">            being ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this node appears inside an ast.Call processing, then this is</span>
        <span class="c1"># the case where a function call has been saved in the case of IO</span>
        <span class="c1"># handling. E.g. format_10_obj.read_line(main.file_10.readline())).</span>
        <span class="c1"># Here, main.file_10.readline is</span>
        <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;call&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_d_object_array_assign</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span>
            <span class="k">return</span> <span class="n">module</span>
        <span class="c1"># When a computations float value is extracted using the Float32</span>
        <span class="c1"># class&#39;s _val method, an ast.Attribute will be present</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_val&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">node_value</span> <span class="o">!=</span> <span class="s2">&quot;ast.Attribute&quot;</span><span class="p">:</span>
                <span class="c1"># TODO: This section of the code should be the same as</span>
                <span class="c1">#  `process_name`. Verify this.</span>
                <span class="n">last_definition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># TODO Change the format according to the new spec</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">last_definition</span><span class="p">}}</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">attributes</span><span class="p">,</span>
                    <span class="n">last_definitions</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_derived_type_attributes</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="n">attribs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                    <span class="n">variable_info</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">attr</span><span class="p">,</span>
                            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">last_definitions</span><span class="p">[</span><span class="n">attr</span><span class="p">],</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="n">attribs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_info</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">attribs</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_return_value"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_return_value">[docs]</a>    <span class="k">def</span> <span class="nf">process_return_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function handles the return value from a function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;return_value&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">)</span>
        <span class="n">function_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">namespace</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="si">}</span><span class="s2">__return&quot;</span>
        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_multiple</span><span class="p">(</span>
            <span class="n">function_name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">],</span> <span class="s2">&quot;_&quot;</span>
        <span class="p">)</span>
        <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;return&quot;</span><span class="p">},</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">return_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_class_def"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_class_def">[docs]</a>    <span class="k">def</span> <span class="nf">process_class_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function handles user defined type (class) by populating</span>
<span class="sd">        types grfn attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;attributes&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">)</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;@type::</span><span class="si">{</span><span class="n">namespace</span><span class="si">}</span><span class="s2">::@global::</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_name</span>

        <span class="c1"># Keep a track of declared user-defined types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">body</span>
        <span class="c1"># Populate class member variables into attributes array.</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">attrib_is_array</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">attrib_ast</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">attrib_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.AnnAssign&quot;</span><span class="p">:</span>
                <span class="n">attrib_name</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">attr</span>
                <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">:</span>
                    <span class="n">attrib_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">[</span><span class="n">attrib</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attrib</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="p">:</span>
                    <span class="n">attrib_type</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span>
            <span class="k">elif</span> <span class="n">attrib_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Assign&quot;</span><span class="p">:</span>
                <span class="n">attrib_name</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attr</span>
                <span class="n">attrib_type</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">attrib_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span>
                    <span class="ow">or</span> <span class="n">attrib_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">library_types</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;User-defined type [</span><span class="si">{</span><span class="n">attrib_type</span><span class="si">}</span><span class="s2">] does not exist.&quot;</span>

                <span class="k">if</span> <span class="n">attrib_type</span> <span class="o">==</span> <span class="s2">&quot;Array&quot;</span><span class="p">:</span>
                    <span class="n">attrib_is_array</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">attrib_is_array</span><span class="p">:</span>
                <span class="n">elem_type</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                <span class="c1"># TODO: Currently, derived type array attributes are assumed</span>
                <span class="c1"># to be a single dimensional array with integer type. It maybe</span>
                <span class="c1"># appropriate to handle a multi-dimensional with variable used</span>
                <span class="c1"># as a dimension size.</span>
                <span class="n">dimension_info</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_literal</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">is_name</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">single_dimension</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">dimension_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
                    <span class="n">lower_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">single_dimension</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Retrieve upper bound of an array.</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">is_literal</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                        <span class="n">is_name</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Currently, ast type &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">] is not &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;supported.&quot;</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">is_literal</span><span class="p">:</span>
                        <span class="n">dimension</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">is_name</span><span class="p">:</span>
                        <span class="n">dimension</span> <span class="o">=</span> <span class="n">upper_bound</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

                    <span class="n">dimension_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                    <span class="n">lower_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span>
                    <span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                            <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
                        <span class="p">)</span>
                        <span class="n">is_literal</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span>
                    <span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                        <span class="n">is_name</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">is_literal</span><span class="p">:</span>
                        <span class="n">first_dimension</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">is_name</span><span class="p">:</span>
                        <span class="n">first_dimension</span> <span class="o">=</span> <span class="n">upper_bound</span>

                    <span class="n">dimension_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_dimension</span><span class="p">)</span>

                    <span class="n">lower_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">is_literal</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">dimension_info</span><span class="o">.</span><span class="n">elts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                        <span class="n">is_name</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">is_literal</span><span class="p">:</span>
                        <span class="n">second_dimension</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">is_name</span><span class="p">:</span>
                        <span class="n">second_dimension</span> <span class="o">=</span> <span class="n">upper_bound</span>

                    <span class="n">dimension_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">second_dimension</span><span class="p">)</span>

                <span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimension_list</span>

                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">attrib_name</span><span class="p">,</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">attrib_type</span><span class="p">,</span>
                        <span class="s2">&quot;elem_type&quot;</span><span class="p">:</span> <span class="n">elem_type</span><span class="p">,</span>
                        <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="n">dimensions</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># Here index is not needed for derived type attributes,</span>
                <span class="c1"># but simply adding it as a placeholder to make a constant</span>
                <span class="c1"># structure with other arrays.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">attrib_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;dimensions&quot;</span><span class="p">:</span> <span class="n">dimensions</span><span class="p">,</span>
                    <span class="s2">&quot;elem_type&quot;</span><span class="p">:</span> <span class="n">elem_type</span><span class="p">,</span>
                    <span class="s2">&quot;mutable&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">attrib_name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">attrib_type</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrib_name</span><span class="p">)</span>

            <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">attrib_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib_type</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_break"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_break">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_break</span><span class="p">(</span><span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Process the breaks in the file, adding an EXIT node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;insert_break&quot;</span><span class="p">],</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;containers&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_ast">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_ast</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No handler for AST.</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> in gen_grfn, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;fields: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">_fields</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_load"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_load">[docs]</a>    <span class="k">def</span> <span class="nf">process_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found ast.Load, which should not happen. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;From source: </span><span class="si">{</span><span class="n">call_source</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_store"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_store">[docs]</a>    <span class="k">def</span> <span class="nf">process_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found ast.Store, which should not happen. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;From source: </span><span class="si">{</span><span class="n">call_source</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_nomatch"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_nomatch">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_nomatch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No handler for </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> in gen_grfn, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;value: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_namespace</span><span class="p">(</span><span class="n">original_fortran_file</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns the namespace for every identifier in the</span>
<span class="sd">            system being analyzed.</span>
<span class="sd">            Currently, this function is very barebone and just returns the</span>
<span class="sd">            name of the system being evaluated. After more testing with</span>
<span class="sd">            modules and imports, the namespace will expand into more than</span>
<span class="sd">            just the system file name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">namespace_path_list</span> <span class="o">=</span> <span class="n">get_path</span><span class="p">(</span><span class="n">original_fortran_file</span><span class="p">,</span> <span class="s2">&quot;namespace&quot;</span><span class="p">)</span>
        <span class="n">namespace_path</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">namespace_path_list</span><span class="p">)</span>

        <span class="c1"># TODO Hack: Currently only the last element of the</span>
        <span class="c1">#  `namespace_path_list` is being returned as the `namespace_path` in</span>
        <span class="c1">#  order to make it consistent with the handwritten SIR-Demo GrFN</span>
        <span class="c1">#  JSON. Will need a more generic path for later instances.</span>
        <span class="n">namespace_path</span> <span class="o">=</span> <span class="n">namespace_path_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">namespace_path</span>

<div class="viewcode-block" id="GrFNGenerator.make_source_list_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_source_list_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_source_list_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_dictionary</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If the source is a list inside of a list, remove the outer list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_dictionary</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">source_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span>
        <span class="p">):</span>
            <span class="n">source_dictionary</span> <span class="o">=</span> <span class="n">source_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">source_dictionary</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="s2">&quot;f_index&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="s2">&quot;get_substr&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">string_var</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string_var</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                        <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span>
            <span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source_list</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_source</span>
        <span class="p">]</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="k">return</span> <span class="n">source_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_fn_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_fn_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_fn_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">io_source</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="n">target_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">target</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># If the source is a list inside of a list, remove the outer list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="c1"># Check for a write to a file</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fn</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="n">method_var</span> <span class="o">=</span> <span class="n">function_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_var</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_var</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">method_name</span> <span class="o">=</span> <span class="n">function_name</span>
                <span class="c1"># Remove first index of an array function as it&#39;s</span>
                <span class="c1"># really a type name not the variable for input.</span>
                <span class="k">if</span> <span class="n">function_name</span> <span class="ow">is</span> <span class="s2">&quot;Array&quot;</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># If a RHS of an assignment is an array getter,</span>
                <span class="c1"># for example, meani.get_((runs[0])), we only need</span>
                <span class="c1"># the array name (meani in this case) and append</span>
                <span class="c1"># to source.</span>
                <span class="c1"># if &quot;.get_&quot; in src[&quot;call&quot;][&quot;function&quot;]:</span>
                <span class="k">if</span> <span class="n">method_name</span> <span class="o">==</span> <span class="s2">&quot;get_&quot;</span><span class="p">:</span>
                    <span class="n">get_array_name</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.get_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                    <span class="p">)</span>
                    <span class="n">var_arr_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">get_array_name</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_arr_name</span><span class="p">)</span>

                <span class="c1"># Bypassing identifiers who have I/O constructs on their source</span>
                <span class="c1"># fields too.</span>
                <span class="c1"># Example: (i[0],) = format_10_obj.read_line(file_10.readline())</span>
                <span class="c1"># &#39;i&#39; is bypassed here</span>
                <span class="c1"># TODO this is only for PETASCE02.for. Will need to include &#39;i&#39;</span>
                <span class="c1">#  in the long run</span>
                <span class="n">bypass_match_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_io_variables</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bypass_match_source</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                    <span class="c1"># TODO This is a hack for SIR&#39;s retval to be included as</span>
                    <span class="c1">#  an assign function (will not have an input). But,</span>
                    <span class="c1">#  moving on a proper method for handling IO is required.</span>
                    <span class="c1">#  Uncomment the line below to revert to old form.</span>
                    <span class="c1"># return fn</span>
                    <span class="n">io_source</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># TODO Finalize the spec for calls here of this form:</span>
                <span class="c1">#  &quot;@container::&lt;namespace_path_string&gt;::&lt;scope_path_string&gt;::</span>
                <span class="c1">#   &lt;container_base_name&gt;&quot; and add here.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">io_source</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">source_ins</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                        <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_ins</span><span class="p">)</span>
                <span class="c1"># Check for cases of string index operations</span>
                <span class="k">if</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;f_index&quot;</span><span class="p">,</span> <span class="s2">&quot;get_substr&quot;</span><span class="p">]:</span>
                    <span class="n">string_var</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">string_var</span><span class="p">]</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">string_var</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_string</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_string</span><span class="p">)</span>
            <span class="c1"># The code below is commented out to not include any `literal`</span>
            <span class="c1"># values in the input of `function` bodies. The spec does mention</span>
            <span class="c1"># including `literals` so if needed, uncomment the code block below</span>

            <span class="c1"># elif &quot;type&quot; in src and src[&quot;type&quot;] == &quot;literal&quot;:</span>
            <span class="c1">#     variable_type = self.type_def_map[src[&quot;dtype&quot;]]</span>
            <span class="c1">#     source_string = f&quot;@literal::{variable_type}::{src[&#39;value&#39;]}&quot;</span>
            <span class="c1">#     source.append(source_string)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     assert False, f&quot;Unidentified source: {src}&quot;</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span>
            <span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_source</span>
        <span class="p">]</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">target_string</span><span class="p">],</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">fn</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_io_variables</span><span class="p">(</span><span class="n">variable_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function scans each variable from a list of currently defined</span>
<span class="sd">            variables and removes those which are related to I/O such as format</span>
<span class="sd">            variables, file handles, write lists and write_lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">io_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(format_\d+_obj)|(file_\d+)|(write_list_\d+)|&quot;</span> <span class="sa">r</span><span class="s2">&quot;(write_line)&quot;</span>
        <span class="p">)</span>
        <span class="n">io_match_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">io_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">var</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span>
            <span class="k">if</span> <span class="n">io_match_list</span><span class="p">[</span><span class="n">variable_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>

<div class="viewcode-block" id="GrFNGenerator.make_call_body_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_call_body_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_call_body_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            We are going to remove addition of functions such as &quot;max&quot;, &quot;exp&quot;,</span>
<span class="sd">            &quot;sin&quot;, etc to the source list. The following two lines when</span>
<span class="sd">            commented helps us do that. If user-defined functions come up as</span>
<span class="sd">            sources, some other approach might be required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO Try with user defined functions and see if the below two lines</span>
        <span class="c1">#  need to be reworked</span>
        <span class="c1"># name = source[&quot;call&quot;][&quot;function&quot;]</span>
        <span class="c1"># source_list.append({&quot;name&quot;: name, &quot;type&quot;: &quot;function&quot;})</span>

        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="n">source_string</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_string</span><span class="p">)</span>
                    <span class="c1"># TODO Adding boolean literals as an input to an assign</span>
                    <span class="c1">#  function but not integer literals?</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">item</span>
                        <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
                        <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span>
                    <span class="p">):</span>
                        <span class="n">source_string</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;@literal::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_string</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="c1"># Handles a case where array declaration size</span>
                        <span class="c1"># was given with a variable value.</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                                <span class="n">variable</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;@variable:&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::0&quot;</span>
                                <span class="p">)</span>
                                <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">source_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_decorators"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_decorators">[docs]</a>    <span class="k">def</span> <span class="nf">process_decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Go through each decorator and extract relevant information.</span>
<span class="sd">            Currently this function only checks for the static_vars decorator</span>
<span class="sd">            for the SAVEd variables and updates variable_types with the data</span>
<span class="sd">            type of each variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">decorator</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">decorator_function_name</span> <span class="o">=</span> <span class="n">decorator</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">decorator_function_name</span> <span class="o">==</span> <span class="s2">&quot;static_vars&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">decorator</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                    <span class="n">variable_type</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">[</span>
                        <span class="n">variable_type</span>
                    <span class="p">]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_dictionary</span><span class="p">(</span><span class="n">dicts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function merges the entire dictionary created by `gen_grfn`</span>
<span class="sd">            into another dictionary in a managed manner. The `dicts` argument is</span>
<span class="sd">            a list of form [{}, {}, {}] where each {} dictionary is the grfn</span>
<span class="sd">            specification of a function. It contains `functions` and</span>
<span class="sd">            `identifiers` as its keys. Additionally, if the python code has a</span>
<span class="sd">            starting point, that is also present in the last {} of `dicts`. The</span>
<span class="sd">            function merges the values from the `functions` key of each {} in</span>
<span class="sd">            `dicts` into a single key of the same name. Similarly, it does this</span>
<span class="sd">            for every unique key in the `dicts` dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">))</span>
        <span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>

        <span class="c1"># Create a cross-product between each unique key and each grfn</span>
        <span class="c1"># dictionary</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">dicts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">merged_dict</span>

<div class="viewcode-block" id="GrFNGenerator.get_last_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.get_last_definition">[docs]</a>    <span class="k">def</span> <span class="nf">get_last_definition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">last_definitions</span><span class="p">,</span> <span class="n">last_definition_default</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns the last (current) definition (index) of a</span>
<span class="sd">            variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">last_definition_default</span>

        <span class="c1"># Pre-processing and removing certain Assigns which only pertain to the</span>
        <span class="c1"># Python code and do not relate to the FORTRAN code in any way.</span>
        <span class="n">bypass_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_bypass_io</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bypass_match</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">last_definitions</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_next_definition</span><span class="p">(</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">last_definitions</span><span class="p">,</span> <span class="n">next_definitions</span><span class="p">,</span> <span class="n">last_definition_default</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns the next definition i.e. index of a variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The dictionary `next_definitions` holds the next index of all current</span>
        <span class="c1"># variables in scope. If the variable is not found (happens when it is</span>
        <span class="c1"># assigned for the first time in a scope), its index will be one greater</span>
        <span class="c1"># than the last definition default.</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">last_definition_default</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Update the next definition index of this variable by incrementing</span>
        <span class="c1"># it by 1. This will be used the next time when this variable is</span>
        <span class="c1"># referenced on the LHS side of an assignment.</span>
        <span class="n">next_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Also update the `last_definitions` dictionary which holds the current</span>
        <span class="c1"># index of all variables in scope.</span>
        <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>

<div class="viewcode-block" id="GrFNGenerator.get_variable_type"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.get_variable_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_variable_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns the data type of a variable using the</span>
<span class="sd">            annotation information used to define that variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the variable has been wrapped in a list like x: List[int],</span>
        <span class="c1"># `annotation_node` will be a Subscript node</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation_node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="n">annotation_node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="n">annotation_node</span><span class="o">.</span><span class="n">id</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">[</span><span class="n">data_type</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported type (only float, int, list, real, bool and str &quot;</span>
                <span class="s2">&quot;supported as of now).</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_variables_and_functions</span><span class="p">(</span><span class="n">grfn</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">grfn</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">grfn</span><span class="p">))</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;containers&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">grfn</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">containers</span>

<div class="viewcode-block" id="GrFNGenerator.generate_gensym"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.generate_gensym">[docs]</a>    <span class="k">def</span> <span class="nf">generate_gensym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The gensym is used to uniquely identify any identifier in the</span>
<span class="sd">            program. Python&#39;s uuid library is used to generate a unique 12 digit</span>
<span class="sd">            HEX string. The uuid4() function of &#39;uuid&#39; focuses on randomness.</span>
<span class="sd">            Each and every bit of a UUID v4 is generated randomly and with no</span>
<span class="sd">            inherent logic. To every gensym, we add a tag signifying the data</span>
<span class="sd">            type it represents.</span>
<span class="sd">            &#39;v&#39;: variables</span>
<span class="sd">            &#39;c&#39;: containers</span>
<span class="sd">            &#39;f&#39;: functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gensym_tag_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="p">[:</span><span class="mi">12</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="GrFNGenerator.generate_lambda_function"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.generate_lambda_function">[docs]</a>    <span class="k">def</span> <span class="nf">generate_lambda_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">return_value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">array_assign</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">string_assign</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">d_type_assign</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">,</span>
        <span class="n">state</span><span class="p">,</span>
        <span class="n">is_custom</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generated_lambda_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>
        <span class="n">lambda_for_var</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">lambda_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">argument_strings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># We need to remove the attribute (class member var) from</span>
        <span class="c1"># the source_list as we do not need it in the lambda function</span>
        <span class="c1"># argument. Also, form an __object.attribute__ string.</span>
        <span class="k">if</span> <span class="n">d_type_assign</span><span class="p">:</span>
            <span class="n">d_type</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span><span class="p">]</span>
            <span class="n">target_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types_attributes</span><span class="p">[</span><span class="n">d_type</span><span class="p">]:</span>
                    <span class="n">target_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="c1"># Since the next attribute that will be seen must be</span>
                    <span class="c1"># dependent on the current attribute type, here it&#39;s</span>
                    <span class="c1"># updating the d_type.</span>
                    <span class="n">d_type</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

        <span class="c1"># If a custom lambda function is encountered, create its function</span>
        <span class="c1"># instead</span>
        <span class="k">if</span> <span class="n">is_custom</span><span class="p">:</span>
            <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;def </span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="s2">    &quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lambda_code_generator</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span><span class="p">)</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="n">lambda_code_generator</span><span class="o">.</span><span class="n">generate_code</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">,</span> <span class="n">PrintState</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Should always return&quot;</span>
            <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_strings</span><span class="p">)</span>
        <span class="c1"># Sort the arguments in the function call as it is used in the operation</span>
        <span class="n">input_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># Add type annotations to the function arguments</span>
        <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">input_list</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">array_types</span><span class="p">:</span>
                <span class="n">lambda_for_var</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">lambda_for_var</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">annotation</span><span class="p">:</span>
                <span class="c1"># `variable_types` does not contain annotations for variables</span>
                <span class="c1"># for indexing such as &#39;abc_1&#39;, etc. Check if the such variables</span>
                <span class="c1"># exist and assign appropriate annotations</span>
                <span class="n">key_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">var</span><span class="p">,</span> <span class="n">dicn</span><span class="p">:</span> <span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dicn</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var</span><span class="p">])</span>
                <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span>
                    <span class="n">key_match</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="c1"># function argument requires annotation only when</span>
            <span class="c1"># it&#39;s dealing with simple variable (at least for now).</span>
            <span class="c1"># TODO String assignments of all kinds are class/method related</span>
            <span class="c1">#  operations and will not involve annotations. Discuss this.</span>
            <span class="k">if</span> <span class="n">lambda_for_var</span> <span class="ow">and</span> <span class="n">annotation</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">:</span>
                    <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_map</span><span class="p">[</span><span class="n">annotation</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Annotation must be a regular type or user defined &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;type. Annotation: </span><span class="si">{</span><span class="n">annotation</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">argument_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">annotation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Currently, this is for array specific else case.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">argument_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
                <span class="n">lambda_for_var</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;def </span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argument_strings</span><span class="p">)</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="s2">    &quot;</span>
        <span class="p">)</span>
        <span class="c1"># If a `decision` tag comes up, override the call to genCode to manually</span>
        <span class="c1"># enter the python script for the lambda file.</span>
        <span class="k">if</span> <span class="s2">&quot;__decision__&quot;</span> <span class="ow">in</span> <span class="n">function_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;np.where(</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> if </span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> else </span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">string_assign</span><span class="p">:</span>
            <span class="n">array_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="p">:</span>
                <span class="n">array_name</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">array_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
                <span class="n">lambda_code_generator</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_code_generator</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span><span class="p">)</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">lambda_code_generator</span><span class="o">.</span><span class="n">generate_code</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">PrintState</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array_assign</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span>
                        <span class="p">)</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    return </span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">array_assign_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">string_assign</span><span class="p">:</span>
                <span class="n">lambda_code_generator</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_numpy</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span><span class="p">][</span><span class="s2">&quot;length&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">lambda_code_generator</span><span class="o">.</span><span class="n">generate_code</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">PrintState</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span><span class="p">][</span><span class="s2">&quot;annotation&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span><span class="p">][</span>
                        <span class="s2">&quot;annotation&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span><span class="p">][</span><span class="s2">&quot;annotation_assign&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span><span class="p">][</span>
                        <span class="s2">&quot;annotation_assign&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">string_assign_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">d_type_assign</span><span class="p">:</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    return </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;[^ ]&quot;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">indent</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;return &quot;</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">indent</span><span class="p">:]</span>
            <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_strings</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.generate_container_id_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.generate_container_id_name">[docs]</a>    <span class="k">def</span> <span class="nf">generate_container_id_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">namespace_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="n">container_basename</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace</span><span class="p">(</span><span class="n">namespace_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scope_path</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">scope_path_string</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scope_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scope_path_string</span> <span class="o">=</span> <span class="n">scope_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid scope_path type </span><span class="si">{</span><span class="n">scope_path</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">container_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;@container::</span><span class="si">{</span><span class="n">namespace</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">scope_path_string</span><span class="si">}</span><span class="s2">::&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">container_basename</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">container_id</span></div>

<div class="viewcode-block" id="GrFNGenerator.generate_variable_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.generate_variable_definition">[docs]</a>    <span class="k">def</span> <span class="nf">generate_variable_definition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">d_type_object_assign</span><span class="p">,</span> <span class="n">state</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function generates the GrFN structure for a variable</span>
<span class="sd">            definition, of the form:</span>
<span class="sd">            variable: {</span>
<span class="sd">                        name:</span>
<span class="sd">                        source_refs:</span>
<span class="sd">                        gensym:</span>
<span class="sd">                        domain:</span>
<span class="sd">                        domain_constraints:</span>
<span class="sd">                        }</span>
<span class="sd">            Args:</span>
<span class="sd">                variables (list): List of variables.</span>
<span class="sd">                reference (str): Either array&#39;s indexing variable (i.e. i</span>
<span class="sd">                for array[i]) or derived type object&#39;s referencing class</span>
<span class="sd">                member variable (i.e. k for x.k)</span>

<span class="sd">            Returns:</span>
<span class="sd">                list : Generated GrFN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="s2">&quot;annotation&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># If this is a string initialization without assignment,</span>
                <span class="c1"># the index will be 0 by default</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">domains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_domain_dictionary</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">:</span>
            <span class="c1"># Since we need to update the domain of arrays that</span>
            <span class="c1"># were passed to a function once the program actually</span>
            <span class="c1"># finds about it, we need to temporarily hold the domain</span>
            <span class="c1"># information in the dictionary of domain list.</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">domain</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">derived_type_objects</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

            <span class="c1"># Only array variables hold dimensions in their domain</span>
            <span class="c1"># when they get declared, we identify the array variable</span>
            <span class="c1"># declaration by simply checking the existence of the dimensions</span>
            <span class="c1"># key in the domain. Also, the array was previously passed</span>
            <span class="c1"># to functions.</span>
            <span class="k">if</span> <span class="s2">&quot;dimensions&quot;</span> <span class="ow">in</span> <span class="n">domain</span> <span class="ow">and</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span><span class="p">:</span>
                <span class="c1"># Since we can&#39;t simply do &quot;dom = domain&quot;</span>
                <span class="c1"># as this will do a replacement of the dict element</span>
                <span class="c1"># not the actual domain object of the original function</span>
                <span class="c1"># argument, we need to clean off the existing contents</span>
                <span class="c1"># first and then add the array domain spec one-by-one.</span>
                <span class="k">for</span> <span class="n">dom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_arg_domain</span><span class="p">[</span><span class="n">variable</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                    <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
                    <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;dimensions&quot;</span><span class="p">]</span>
                    <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;elem_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;elem_type&quot;</span><span class="p">]</span>
                    <span class="n">dom</span><span class="p">[</span><span class="s2">&quot;mutable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="s2">&quot;mutable&quot;</span><span class="p">]</span>

        <span class="n">variable_gensym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gensym</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># var_type = state.variable_types[variable]</span>
            <span class="k">if</span> <span class="n">d_type_object_assign</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">reference</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">variable</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">reference</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">variable_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">namespace</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="si">}</span><span class="s2">::&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># TODO Change the domain constraint. How do you figure out the domain</span>
        <span class="c1">#  constraint?</span>
        <span class="n">domain_constraint</span> <span class="o">=</span> <span class="s2">&quot;(and (&gt; v -infty) (&lt; v infty)))&quot;</span>

        <span class="n">variable_definition</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable_name</span><span class="p">,</span>
            <span class="s2">&quot;gensym&quot;</span><span class="p">:</span> <span class="n">variable_gensym</span><span class="p">,</span>
            <span class="s2">&quot;source_refs&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">domain</span><span class="p">,</span>
            <span class="s2">&quot;domain_constraint&quot;</span><span class="p">:</span> <span class="n">domain_constraint</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">variable_definition</span></div>

<div class="viewcode-block" id="GrFNGenerator.get_domain_dictionary"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.get_domain_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="n">domain_dictionary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">variable</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">variable_type</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_variable_types</span><span class="p">:</span>
                <span class="n">variable_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Mark if a variable is mutable or not.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_map</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_map</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="s2">&quot;parameter&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">is_mutable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_mutable</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Array as a function argument handler.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">handling_f_args</span> <span class="ow">and</span> <span class="n">variable_type</span> <span class="o">==</span> <span class="s2">&quot;array&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_array_arg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="c1"># Retrieve variable type name (i.e. integer, float,</span>
            <span class="c1"># __derived_type__)</span>
            <span class="k">if</span> <span class="n">variable_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_def_map</span><span class="p">:</span>
                <span class="n">type_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_def_map</span><span class="p">[</span><span class="n">variable_type</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">variable_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_types</span><span class="p">:</span>
                <span class="n">type_name</span> <span class="o">=</span> <span class="n">variable_type</span>
                <span class="c1"># Since derived type variables are not a regular type variable,</span>
                <span class="c1"># we need to needs to them manually here into variable_types</span>
                <span class="c1"># dictionary to be referenced later in the stream.</span>
                <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">type_found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_names</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">mod</span> <span class="o">!=</span> <span class="s2">&quot;main&quot;</span>
                            <span class="ow">and</span> <span class="n">mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_summary</span>
                            <span class="ow">and</span> <span class="n">variable_type</span>
                            <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_summary</span><span class="p">[</span><span class="n">mod</span><span class="p">][</span><span class="s2">&quot;derived_type_list&quot;</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="n">type_found</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">type_name</span> <span class="o">=</span> <span class="n">variable_type</span>
                            <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_name</span>

                <span class="k">assert</span> <span class="n">type_found</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="n">variable_type</span><span class="si">}</span><span class="s2"> is not a valid type.&quot;</span>

            <span class="n">domain_dictionary</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">type_name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mutable&quot;</span><span class="p">:</span> <span class="n">is_mutable</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">domain_dictionary</span></div>

<div class="viewcode-block" id="GrFNGenerator.generate_function_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.generate_function_name">[docs]</a>    <span class="k">def</span> <span class="nf">generate_function_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">arr_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function generates the name of the function inside the</span>
<span class="sd">            container wiring within the body of a container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variable_spec_regex</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;@.*?::(?P&lt;namescope&gt;.*?::.*?)::(&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;?P&lt;variable&gt;.*?)::(?P&lt;index&gt;.*)&quot;</span>
        <span class="p">)</span>
        <span class="n">variable_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">variable_spec_regex</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variable_match</span><span class="p">:</span>
            <span class="n">namespace_scope</span> <span class="o">=</span> <span class="n">variable_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;namescope&quot;</span><span class="p">)</span>
            <span class="n">variable_name</span> <span class="o">=</span> <span class="n">variable_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arr_index</span><span class="p">:</span>
                <span class="n">variable_name</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">arr_index</span><span class="p">:</span>
                    <span class="n">variable_name</span> <span class="o">=</span> <span class="n">variable_name</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">variable_index</span> <span class="o">=</span> <span class="n">variable_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>

            <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">namespace_scope</span>
                <span class="o">+</span> <span class="n">function_type</span>
                <span class="o">+</span> <span class="n">variable_name</span>
                <span class="o">+</span> <span class="s2">&quot;::&quot;</span>
                <span class="o">+</span> <span class="n">variable_index</span>
            <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_multiple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">],</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">x</span> <span class="ow">in</span> <span class="n">function_type</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;assign&quot;</span><span class="p">,</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span> <span class="s2">&quot;decision&quot;</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="p">):</span>
                <span class="n">spec_type</span> <span class="o">=</span> <span class="s2">&quot;lambda&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec_type</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Cannot match regex for variable spec: </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">spec_type</span><span class="p">}</span></div>

<div class="viewcode-block" id="GrFNGenerator.load_updated"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.load_updated">[docs]</a>    <span class="k">def</span> <span class="nf">load_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grfn_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function parses through the GrFN once and finds the</span>
<span class="sd">            container spec of functions whose `updated` fields needs to be</span>
<span class="sd">            filled in that functions&#39; function call spec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">container</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">container</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_functions</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">container_grfn</span> <span class="ow">in</span> <span class="n">grfn_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;containers&quot;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">body_function</span> <span class="ow">in</span> <span class="n">container_grfn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]:</span>
                        <span class="n">function_name</span> <span class="o">=</span> <span class="n">body_function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">function_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;@container&quot;</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">function_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">container</span>
                        <span class="p">):</span>
                            <span class="n">updated_variable</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">body_function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_argument_map</span><span class="p">[</span><span class="n">container</span><span class="p">][</span>
                                    <span class="s2">&quot;updated_indices&quot;</span>
                                <span class="p">]</span>
                            <span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">updated_variable</span><span class="p">)):</span>
                                <span class="n">old_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                                    <span class="n">updated_variable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="p">)</span>
                                <span class="n">new_index</span> <span class="o">=</span> <span class="n">old_index</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">updated_var_list</span> <span class="o">=</span> <span class="n">updated_variable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                                    <span class="s2">&quot;::&quot;</span>
                                <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">updated_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">new_index</span><span class="p">))</span>
                                <span class="n">updated_variable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;::&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                    <span class="n">updated_var_list</span>
                                <span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_functions</span><span class="p">[</span>
                                    <span class="n">container</span>
                                <span class="p">][</span><span class="s2">&quot;scope&quot;</span><span class="p">]</span>
                                <span class="n">variable_name</span> <span class="o">=</span> <span class="n">updated_var_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">variable_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_variable_definition</span><span class="p">(</span>
                                    <span class="n">variable_name</span><span class="p">,</span>
                                    <span class="kc">None</span><span class="p">,</span>
                                    <span class="kc">False</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">update_functions</span><span class="p">[</span><span class="n">container</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">],</span>
                                <span class="p">)</span>
                                <span class="n">variable_name_list</span> <span class="o">=</span> <span class="n">variable_spec</span><span class="p">[</span>
                                    <span class="s2">&quot;name&quot;</span>
                                <span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">variable_name_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">new_index</span><span class="p">))</span>
                                <span class="n">variable_spec</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;::&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                    <span class="n">variable_name_list</span>
                                <span class="p">)</span>
                                <span class="n">grfn_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_spec</span><span class="p">)</span>
                            <span class="n">body_function</span><span class="p">[</span><span class="s2">&quot;updated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_variable</span>
        <span class="k">return</span> <span class="n">grfn_dict</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_array_dimension</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">array_dimensions</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is for extracting bounds of an array.</span>

<span class="sd">            Args:</span>
<span class="sd">                sources (list): A list holding GrFN element of</span>
<span class="sd">                array function. For example, Array (int, [[(0, 10)]).</span>
<span class="sd">                array_dimensions (list): An empty list that will be</span>
<span class="sd">                populated by current function with the dimension info.</span>
<span class="sd">                inputs (list): A list that holds inputs dictionary</span>
<span class="sd">                extracted from sources.</span>

<span class="sd">            Returns:</span>
<span class="sd">                None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A multi-dimensional array handler</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">low_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;list&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;list&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="n">array_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">low_bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 1-D array handler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;list&quot;</span><span class="p">]</span>
            <span class="c1"># Get lower bound of an array</span>
            <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># When an index is a scalar value</span>
                <span class="n">low_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># When an index is a variable</span>
                <span class="n">low_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
            <span class="c1"># Get upper bound of an array</span>
            <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">array_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">low_bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">low_bound</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">),</span> <span class="s2">&quot;low_bound must be &lt;integer&gt; type and 0 (zero) for now.&quot;</span>
                <span class="n">array_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;low_bound type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">low_bound</span><span class="p">)</span><span class="si">}</span><span class="s2"> is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;currently not handled.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_array_setter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">container_id_name</span><span class="p">,</span> <span class="n">arr_index</span><span class="p">,</span> <span class="n">state</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function is for handling array setter (ex. means.set_(...)).</span>

<span class="sd">            Args:</span>
<span class="sd">                node: The node referring to the array</span>
<span class="sd">                function (list): A list holding the information of the function</span>
<span class="sd">                for JSON and lambda function generation.</span>
<span class="sd">                arg (list): A list holding the arguments of call[&#39;inputs&#39;].</span>
<span class="sd">                name (str): A name of the array.</span>
<span class="sd">                container_id_name (str): A name of function container. It&#39;s an</span>
<span class="sd">                array name with other appended info. in this function.</span>
<span class="sd">                arr_index (str): Index of a target array.</span>
<span class="sd">                state: The current state of the system</span>

<span class="sd">            Returns:</span>
<span class="sd">                (list) function: A completed list of function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_d_object_name</span><span class="p">:</span>
                <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">argument_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># Array index is always one of</span>
        <span class="c1"># the lambda function argument</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">arr_index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arithmetic_ops</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># For array setter value handler</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># If an input is a simple variable.</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
                    <span class="n">input_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                        <span class="n">var_name</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># It&#39;s not an error, so just pass it.</span>
                    <span class="k">pass</span>
            <span class="c1"># If an input is an array.</span>
            <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                <span class="n">ref_call</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;.get_&quot;</span> <span class="ow">in</span> <span class="n">ref_call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]:</span>
                    <span class="n">get_array_name</span> <span class="o">=</span> <span class="n">ref_call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.get_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">get_array_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
                        <span class="n">argument_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_array_name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">get_array_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                            <span class="n">ip_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                                <span class="n">get_array_name</span><span class="p">,</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                                <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">function</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_array_name</span><span class="si">}</span><span class="s2">::&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ip_index</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># It&#39;s not an error, so just pass it.</span>
                        <span class="k">pass</span>

        <span class="c1"># Generate lambda function for array[index]</span>
        <span class="n">lambda_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_lambda_function</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">container_id_name</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">argument_list</span><span class="p">,</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">function</span>

    <span class="k">def</span> <span class="nf">_generate_array_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is for generating array index grfn</span>
<span class="sd">        handling both single and multi-dimensional arrays.</span>

<span class="sd">        Args:</span>
<span class="sd">            node: The node referring to the array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list) index: Formed array index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
        <span class="c1"># Case 1: Single dimensional array</span>
        <span class="k">if</span> <span class="n">args_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">args_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Num&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Case 1.1: Single dimensional array with arithmetic</span>
        <span class="c1"># operation as setter index</span>
        <span class="k">elif</span> <span class="n">args_name</span> <span class="o">==</span> <span class="s2">&quot;ast.BinOp&quot;</span><span class="p">:</span>
            <span class="n">left_ast</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">right_ast</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="c1"># Get the operator&#39;s left side value</span>
            <span class="k">if</span> <span class="n">left_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
            <span class="k">elif</span> <span class="n">left_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Num&quot;</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n</span>
            <span class="c1"># Get the arithmetic operator</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arithmetic_ops</span><span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">6</span><span class="p">:]]</span>
            <span class="c1"># Get the operator&#39;s right side value</span>
            <span class="k">if</span> <span class="n">right_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
            <span class="k">elif</span> <span class="n">right_ast</span> <span class="o">==</span> <span class="s2">&quot;ast.Num&quot;</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
        <span class="c1"># Case 2: Multi-dimensional array</span>
        <span class="k">elif</span> <span class="n">args_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Tuple&quot;</span><span class="p">:</span>
            <span class="n">md_array_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">md_array_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_array</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">md_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md_array_name</span><span class="p">)</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">elts</span>
            <span class="n">dimension_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
                <span class="n">ast_name</span> <span class="o">=</span> <span class="n">dimension</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">ast_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span>
                    <span class="n">dimension_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimension</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">ast_name</span> <span class="o">==</span> <span class="s2">&quot;ast.Num&quot;</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unable to handle </span><span class="si">{</span><span class="n">ast_name</span><span class="si">}</span><span class="s2"> for multi-dimensional &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;array&quot;</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">dimension_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unable to handle </span><span class="si">{</span><span class="n">args_name</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="GrFNGenerator.get_derived_type_attributes"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.get_derived_type_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">get_derived_type_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function retrieves the derived type attributes</span>
<span class="sd">        from the ast and return the updated last definition dict</span>
<span class="sd">        and populated attribute list&quot;&quot;&quot;</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">node_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">node_value</span> <span class="o">==</span> <span class="s2">&quot;ast.Attribute&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">attr</span><span class="p">:</span>
            <span class="n">attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">:</span>
            <span class="n">attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="n">last_definitions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">last_definitions</span><span class="p">[</span><span class="n">attrib</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_last_definition</span><span class="p">(</span>
                <span class="n">attrib</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">last_definitions</span></div>

<div class="viewcode-block" id="GrFNGenerator.replace_multiple"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.replace_multiple">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">replace_multiple</span><span class="p">(</span><span class="n">main_string</span><span class="p">,</span> <span class="n">to_be_replaced</span><span class="p">,</span> <span class="n">new_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Replace a set of multiple sub strings with a new string in main</span>
<span class="sd">            string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over the strings to be replaced</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">to_be_replaced</span><span class="p">:</span>
            <span class="c1"># Check if string is in the main string</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">main_string</span><span class="p">:</span>
                <span class="c1"># Replace the string</span>
                <span class="n">main_string</span> <span class="o">=</span> <span class="n">main_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">new_string</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">main_string</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_updated</span><span class="p">(</span><span class="n">argument_list</span><span class="p">,</span> <span class="n">body_variable_list</span><span class="p">,</span> <span class="n">f_array_arg</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function finds and generates a list of updated identifiers</span>
<span class="sd">            in a container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO After implementing everything, check if `argument_dict` and</span>
        <span class="c1">#  `body_dict` will be the same as `function_state.last_definitions`</span>
        <span class="c1">#  before and after getting `body_grfn`. If so, remove the creation</span>
        <span class="c1">#  of `argument_dict` and `body_dict` and use the `last_definitions`</span>
        <span class="c1">#  instead</span>
        <span class="n">argument_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">body_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">updated_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variable_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*::(?P&lt;variable&gt;.*?)::(?P&lt;index&gt;.*$)&quot;</span><span class="p">)</span>
        <span class="c1"># First, get mapping of argument variables and their indexes</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">argument_list</span><span class="p">:</span>
            <span class="n">var_match</span> <span class="o">=</span> <span class="n">variable_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">var_match</span><span class="p">:</span>
                <span class="n">argument_dict</span><span class="p">[</span><span class="n">var_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="s2">&quot;index&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error when parsing argument variable &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="c1"># Now, get mapping of body variables and their latest indexes</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">body_variable_list</span><span class="p">:</span>
            <span class="n">var_match</span> <span class="o">=</span> <span class="n">variable_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">var_match</span><span class="p">:</span>
                <span class="n">body_dict</span><span class="p">[</span><span class="n">var_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="s2">&quot;index&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error when parsing body variable &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="c1"># Now loop through every argument variable over the body variable to</span>
        <span class="c1"># check if the indices mismatch which would indicate an updated variable</span>
        <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">argument_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">body_dict</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">body_dict</span><span class="p">[</span><span class="n">argument</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">argument_dict</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">updated_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">argument</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">body_dict</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># If argument is an array type, get the current index and</span>
            <span class="c1"># update it. Then, append to the function&#39;s updated list</span>
            <span class="k">elif</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">f_array_arg</span><span class="p">:</span>
                <span class="n">updated_idx</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span>
                <span class="n">updated_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">argument</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">updated_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">updated_list</span>

<div class="viewcode-block" id="GrFNGenerator.check_io_variables"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.check_io_variables">[docs]</a>    <span class="k">def</span> <span class="nf">check_io_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function scans the variable and checks if it is an io</span>
<span class="sd">            variable. It returns the status of this check i.e. True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">io_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_bypass_io</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">variable_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">io_match</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_call_inputs</span><span class="p">(</span>
        <span class="n">call_function</span><span class="p">,</span>
        <span class="n">function_input</span><span class="p">,</span>
        <span class="n">container_argument</span><span class="p">,</span>
        <span class="n">loop_condition_inputs</span><span class="p">,</span>
        <span class="n">loop_condition_inputs_lambda</span><span class="p">,</span>
        <span class="n">state</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function parses a call function (such as when reading an</span>
<span class="sd">            array) and loads all respective input variables from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check if the call is from an array call. We only update the</span>
        <span class="c1"># lists if it is an array operation (such as samples.get_((x[0]))</span>
        <span class="k">if</span> <span class="s2">&quot;.get_&quot;</span> <span class="ow">in</span> <span class="n">call_function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]:</span>
            <span class="n">array_name</span> <span class="o">=</span> <span class="n">call_function</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.get_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">array_index</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">array_name</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span>
            <span class="p">)</span>
            <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_name</span><span class="si">}</span><span class="s2">::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_name</span><span class="si">}</span><span class="s2">::-1&quot;</span><span class="p">)</span>
            <span class="n">loop_condition_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">array_name</span><span class="si">}</span><span class="s2">::-1&quot;</span><span class="p">)</span>
            <span class="n">loop_condition_inputs_lambda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">inputs</span> <span class="ow">in</span> <span class="n">call_function</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">function_input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">container_argument</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;@variable::</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                        <span class="p">)</span>
                        <span class="n">loop_condition_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;@variable::&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">::-1&quot;</span>
                        <span class="p">)</span>
                        <span class="n">loop_condition_inputs_lambda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">var</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_duplicate_from_list</span><span class="p">(</span><span class="n">input_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This helper function removes any duplicates from a list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return list(set(input_list))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">input_list</span><span class="p">))</span>

<div class="viewcode-block" id="GrFNGenerator.get_variables"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.get_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">variable_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">condition_sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="n">variable_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">variable_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="n">function_dict</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;__str__&quot;</span> <span class="ow">in</span> <span class="n">function_dict</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]:</span>
                    <span class="n">var_name</span> <span class="o">=</span> <span class="n">function_dict</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">var_node</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span>
                                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">var_name</span><span class="p">,</span>
                                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">var_name</span><span class="p">],</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">]</span>
                    <span class="n">variable_list</span> <span class="o">+=</span> <span class="n">var_node</span>
                <span class="c1"># TODO: Will have to add other if cases for other string</span>
                <span class="c1">#  types here</span>

        <span class="c1"># Remove any duplicate dictionaries from the list. This is done to</span>
        <span class="c1"># preserve ordering.</span>
        <span class="c1"># Reference: https://www.geeksforgeeks.org/</span>
        <span class="c1"># python-removing-duplicate-dicts-in-list/</span>
        <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variable_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">variable_list</span></div></div>


<div class="viewcode-block" id="get_path"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_path">[docs]</a><span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the path of a file starting from the root of</span>
<span class="sd">        the delphi repository. The returned path varies depending on whether</span>
<span class="sd">        it is for a namespace or a source variable, which is denoted by the</span>
<span class="sd">        `instance` argument variable. It is important to note that the path</span>
<span class="sd">        refers to that of the original system being analyzed i.e. the Fortran</span>
<span class="sd">        code and not the intermediate Python file which is used to generate</span>
<span class="sd">        the AST.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span>
        <span class="n">source_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[./]*(.*)&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">source_match</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Original Fortran source file for </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="sa">f</span><span class="s2">&quot;not found.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">source_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;namespace&quot;</span><span class="p">:</span>
        <span class="n">source_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[./]*(.*)\.&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">source_match</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Namespace path for </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> not found.&quot;</span>
        <span class="k">return</span> <span class="n">source_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Error when trying to get the path of file </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">.&quot;</span></div>


<div class="viewcode-block" id="dump_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.dump_ast">[docs]</a><span class="k">def</span> <span class="nf">dump_ast</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span> <span class="n">annotate_fields</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a formatted dump of the tree in *node*. This is mainly useful for</span>
<span class="sd">        debugging purposes. The returned string will show the names and the</span>
<span class="sd">        values for fields. This makes the code impossible to evaluate,</span>
<span class="sd">        so if evaluation is wanted *annotate_fields* must be set to False.</span>
<span class="sd">        Attributes such as line numbers and column offsets are not dumped by</span>
<span class="sd">        default. If this is wanted, *include_attributes* can be set to True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_format</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">iter_fields</span><span class="p">(</span><span class="n">ast_node</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">include_attributes</span> <span class="ow">and</span> <span class="n">ast_node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">level</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ast_node</span><span class="o">.</span><span class="n">_attributes</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">ast_node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;(&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">annotate_fields</span>
                        <span class="k">else</span> <span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[&quot;</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">_format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ast_node</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ast_node</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected AST, got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_format</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_comments"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.process_comments">[docs]</a><span class="k">def</span> <span class="nf">process_comments</span><span class="p">(</span><span class="n">source_comment_dict</span><span class="p">,</span> <span class="n">generator_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function replaces the keys in the source comments that are</span>
<span class="sd">        function names in the source files into their container id name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grfn_argument_map</span> <span class="o">=</span> <span class="n">generator_object</span><span class="o">.</span><span class="n">function_argument_map</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source_comment_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">grfn_argument_map</span><span class="p">:</span>
            <span class="n">source_comment_dict</span><span class="p">[</span>
                <span class="n">grfn_argument_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">source_comment_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">source_comment_dict</span></div>


<span class="c1"># noinspection PyDefaultArgument</span>
<div class="viewcode-block" id="create_grfn_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.create_grfn_dict">[docs]</a><span class="k">def</span> <span class="nf">create_grfn_dict</span><span class="p">(</span>
    <span class="n">lambda_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">asts</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">mode_mapper_dict</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">original_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">mod_log_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">module_file_exist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">module_import_paths</span><span class="o">=</span><span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Create a Python dict representing the GrFN, with additional metadata</span>
<span class="sd">    for JSON output. &quot;&quot;&quot;</span>

    <span class="n">lambda_string_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;from numbers import Real</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from random import random</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from delphi.translators.for2py.strings import *</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;import numpy as np</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;import delphi.translators.for2py.math_ext as math</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">state</span> <span class="o">=</span> <span class="n">GrFNState</span><span class="p">(</span><span class="n">lambda_string_list</span><span class="p">)</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="n">GrFNGenerator</span><span class="p">()</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Populate list of modules that the program imports</span>
    <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;modules&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="o">!=</span> <span class="s2">&quot;main&quot;</span><span class="p">:</span>
            <span class="n">generator</span><span class="o">.</span><span class="n">module_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">fortran_file</span> <span class="o">=</span> <span class="n">original_file</span>

    <span class="c1"># Currently, we are specifying the module file with</span>
    <span class="c1"># a prefix &quot;m_&quot;, this may be changed in the future.</span>
    <span class="c1"># If it requires a change, simply modify this below prefix.</span>
    <span class="n">module_file_prefix</span> <span class="o">=</span> <span class="s2">&quot;m_&quot;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">mod_log_file_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_f</span><span class="p">:</span>
        <span class="n">module_logs</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_f</span><span class="p">)</span>
        <span class="c1"># Load module summary on memory for later use</span>
        <span class="n">generator</span><span class="o">.</span><span class="n">module_summary</span> <span class="o">=</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_info&quot;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">filename_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;path&gt;.*/)(?P&lt;filename&gt;.*).py&quot;</span><span class="p">)</span>
        <span class="n">file_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename_regex</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">file_match</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t match filename to any format: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">)</span>

        <span class="c1"># Since we do not have separate variable pickle file</span>
        <span class="c1"># for m_*.py, we need to use the original program pickle</span>
        <span class="c1"># file that module resides.</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">module_file_exist</span><span class="p">:</span>
            <span class="n">module_file_path</span> <span class="o">=</span> <span class="n">file_name</span>
            <span class="c1"># Ignoring the module file prefix</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">module_file_prefix</span><span class="p">)</span> <span class="p">:]</span>
            <span class="n">org_file</span> <span class="o">=</span> <span class="n">get_original_file_name</span><span class="p">(</span><span class="n">original_file</span><span class="p">)</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">org_file</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">filename</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_variable_map.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">variable_map</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">generator</span><span class="o">.</span><span class="n">variable_map</span> <span class="o">=</span> <span class="n">variable_map</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to read file </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Extract variables with type that are declared in module</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">module_variable_types</span> <span class="o">=</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;symbol_types&quot;</span><span class="p">]</span>
    <span class="c1"># Extract functions (and subroutines) declared in module</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subprograms&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">subp</span> <span class="ow">in</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;subprograms&quot;</span><span class="p">][</span><span class="n">module</span><span class="p">]:</span>
            <span class="n">generator</span><span class="o">.</span><span class="n">module_subprograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_info&quot;</span><span class="p">]:</span>
                <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_info&quot;</span><span class="p">][</span><span class="n">module</span><span class="p">][</span><span class="s2">&quot;symbol_types&quot;</span><span class="p">][</span><span class="n">subp</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;func&quot;</span>

    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;imports&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">subm</span> <span class="ow">in</span> <span class="n">mode_mapper_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;imports&quot;</span><span class="p">][</span><span class="n">module</span><span class="p">]:</span>
            <span class="n">import_module_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">subm</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">import_function_list</span> <span class="o">=</span> <span class="n">subm</span><span class="p">[</span><span class="n">import_module_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">import_function_list</span>
                <span class="ow">and</span> <span class="n">import_module_name</span> <span class="ow">in</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_info&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">symbols</span> <span class="o">=</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_info&quot;</span><span class="p">][</span><span class="n">import_module_name</span><span class="p">][</span>
                    <span class="s2">&quot;symbol_types&quot;</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">symbols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;func&quot;</span><span class="p">:</span>
                        <span class="n">generator</span><span class="o">.</span><span class="n">module_subprograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="n">generator</span><span class="o">.</span><span class="n">module_subprograms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">import_function_list</span><span class="p">)</span>

    <span class="c1"># Generate GrFN with an AST generated from Python IR.</span>
    <span class="n">grfn</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">asts</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;use_mapping&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;use_mapping&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="ow">in</span> <span class="n">generator</span><span class="o">.</span><span class="n">module_names</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">module_name</span> <span class="ow">and</span> <span class="n">module_name</span> <span class="o">==</span> <span class="n">user</span>
            <span class="p">):</span>
                <span class="n">module_paths</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">import_mods</span> <span class="ow">in</span> <span class="n">module</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">mod_name</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">import_mods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">module_path</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">path</span> <span class="o">+</span> <span class="n">module_file_prefix</span> <span class="o">+</span> <span class="n">mod_name</span> <span class="o">+</span> <span class="s2">&quot;_GrFN.json&quot;</span>
                        <span class="p">)</span>
                        <span class="n">module_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module_path</span><span class="p">)</span>
                <span class="n">module_import_paths</span><span class="p">[</span><span class="n">user</span><span class="p">]</span> <span class="o">=</span> <span class="n">module_paths</span>

    <span class="c1"># If the GrFN has a `start` node, it will refer to the name of the</span>
    <span class="c1"># PROGRAM module which will be the entry point of the GrFN.</span>
    <span class="k">if</span> <span class="n">grfn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">):</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">generator</span><span class="o">.</span><span class="n">function_definitions</span><span class="p">:</span>
        <span class="c1"># TODO: The `grfn_spec` mentions this to be null (None) but it looks</span>
        <span class="c1">#  like `networks.py` requires a certain function. Finalize after</span>
        <span class="c1">#  `networks.py` is completed.</span>
        <span class="c1"># grfn[&quot;start&quot;] = None</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">generator</span><span class="o">.</span><span class="n">function_definitions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Add the placeholder to enter the grounding and link hypothesis information</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;grounding&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># TODO Add a placeholder for `types`. This will have to be populated when</span>
    <span class="c1">#  user defined types start appearing.</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">derived_types_grfn</span>
    <span class="c1"># Get the file path of the original Fortran code being analyzed</span>
    <span class="n">source_file</span> <span class="o">=</span> <span class="n">get_path</span><span class="p">(</span><span class="n">original_file</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">)</span>

    <span class="c1"># TODO Hack: Currently only the file name is being displayed as the</span>
    <span class="c1">#  source in order to match the handwritten SIR model GrFN JSON. Since</span>
    <span class="c1">#  the directory of the `SIR-Gillespie-SD_inline.f` file is the root,</span>
    <span class="c1">#  it works for this case but will need to be generalized for other cases.</span>
    <span class="n">file_path_list</span> <span class="o">=</span> <span class="n">source_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_path_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># Get the source comments from the original Fortran source file.</span>
    <span class="n">source_file_comments</span> <span class="o">=</span> <span class="n">get_comments</span><span class="p">(</span><span class="n">original_file</span><span class="p">)</span>
    <span class="n">comment_dict</span> <span class="o">=</span> <span class="n">process_comments</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">source_file_comments</span><span class="p">),</span> <span class="n">generator</span><span class="p">)</span>
    <span class="n">source_comments</span> <span class="o">=</span> <span class="n">comment_dict</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;source_comments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_comments</span>

    <span class="c1"># dateCreated stores the date and time on which the lambda and GrFN files</span>
    <span class="c1"># were created. It is stored in the YYYMMDD format</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;date_created&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">Z&quot;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">lambda_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">lambda_fh</span><span class="p">:</span>
        <span class="n">lambda_fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_string_list</span><span class="p">))</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">mod_log_file_path</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_f</span><span class="p">:</span>
        <span class="n">json_f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">module_logs</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">grfn</span></div>


<div class="viewcode-block" id="generate_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generate_ast">[docs]</a><span class="k">def</span> <span class="nf">generate_ast</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates the AST of a python file using Python&#39;s ast</span>
<span class="sd">        module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokenize</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span></div>


<div class="viewcode-block" id="get_asts_from_files"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_asts_from_files">[docs]</a><span class="k">def</span> <span class="nf">get_asts_from_files</span><span class="p">(</span><span class="n">file_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">printast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the AST of each python file in the</span>
<span class="sd">        python_file_list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ast_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
        <span class="n">ast_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_ast</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">printast</span><span class="p">:</span>
            <span class="c1"># If the printAst flag is set, print the AST to console</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">dump_ast</span><span class="p">(</span><span class="n">ast_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">ast_list</span></div>


<div class="viewcode-block" id="get_system_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_system_name">[docs]</a><span class="k">def</span> <span class="nf">get_system_name</span><span class="p">(</span><span class="n">pyfile_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the name of the system under analysis. Generally,</span>
<span class="sd">    the system is the one which is not prefixed by `m_` (which represents</span>
<span class="sd">    modules).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">system_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">pyfile_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m_&quot;</span><span class="p">):</span>
            <span class="n">system_name_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*/(.*)\.py&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">system_name_match</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;System name for file </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> not found.&quot;</span>
            <span class="n">system_name</span> <span class="o">=</span> <span class="n">system_name_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">path_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.*)/.*&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">path_match</span><span class="p">,</span> <span class="s2">&quot;Target path not found&quot;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">system_name</span> <span class="ow">or</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Error when trying to find the system name of the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;analyzed program.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">system_name</span><span class="p">,</span> <span class="n">path</span></div>


<div class="viewcode-block" id="generate_system_def"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generate_system_def">[docs]</a><span class="k">def</span> <span class="nf">generate_system_def</span><span class="p">(</span>
    <span class="n">python_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">module_grfn_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">import_grfn_paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">module_logs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">original_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function generates the system definition for the system under</span>
<span class="sd">    analysis and writes this to the main system file.  &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">system_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_system_name</span><span class="p">(</span><span class="n">python_list</span><span class="p">)</span>
    <span class="n">system_filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">/system.json&quot;</span>
    <span class="n">module_name_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;(?P&lt;path&gt;.*/)m_(&quot;</span> <span class="sa">r</span><span class="s2">&quot;?P&lt;module_name&gt;.*)_GrFN.json&quot;</span>
    <span class="p">)</span>

    <span class="n">grfn_components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">module_grfn</span> <span class="ow">in</span> <span class="n">module_grfn_list</span><span class="p">:</span>
        <span class="n">code_sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">module_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">module_name_regex</span><span class="p">,</span> <span class="n">module_grfn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">module_match</span><span class="p">:</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;module_name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">module_name</span> <span class="ow">in</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_to_file&quot;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">module_logs</span><span class="p">[</span><span class="s2">&quot;mod_to_file&quot;</span><span class="p">][</span><span class="n">module_name</span><span class="p">]:</span>
                    <span class="n">code_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">code_sources</span><span class="p">:</span>
            <span class="n">code_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_file_path</span><span class="p">)</span>
        <span class="n">grfn_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;grfn_source&quot;</span><span class="p">:</span> <span class="n">module_grfn</span><span class="p">,</span>
                <span class="s2">&quot;code_source&quot;</span><span class="p">:</span> <span class="n">code_sources</span><span class="p">,</span>
                <span class="s2">&quot;imports&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">grfn</span> <span class="ow">in</span> <span class="n">import_grfn_paths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">import_grfn_paths</span><span class="p">[</span><span class="n">grfn</span><span class="p">]:</span>
            <span class="n">grfn_components</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;imports&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">system_def</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">system_name</span><span class="p">,</span> <span class="s2">&quot;components&quot;</span><span class="p">:</span> <span class="n">grfn_components</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">system_filepath</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">system_filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">systems_def</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">systems_def</span><span class="p">[</span><span class="s2">&quot;systems&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">system_def</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">systems_def</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;systems&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">system_def</span><span class="p">]}</span>

    <span class="k">return</span> <span class="n">system_def</span></div>


<div class="viewcode-block" id="process_files"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.process_files">[docs]</a><span class="k">def</span> <span class="nf">process_files</span><span class="p">(</span>
    <span class="n">python_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">grfn_tail</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">lambda_tail</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">original_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">print_ast_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function takes in the list of python files to convert into GrFN</span>
<span class="sd">    and generates each file&#39;s AST along with starting the GrFN generation</span>
<span class="sd">    process. &quot;&quot;&quot;</span>

    <span class="n">module_file_exist</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">module_mapper</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">grfn_filepath_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ast_list</span> <span class="o">=</span> <span class="n">get_asts_from_files</span><span class="p">(</span><span class="n">python_list</span><span class="p">,</span> <span class="n">print_ast_flag</span><span class="p">)</span>

    <span class="c1"># Regular expression to identify the path and name of all python files</span>
    <span class="n">filename_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;path&gt;.*/)(?P&lt;filename&gt;.*).py&quot;</span><span class="p">)</span>

    <span class="c1"># First, find the main python file in order to populate the module</span>
    <span class="c1"># mapper</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">python_list</span><span class="p">:</span>
        <span class="n">file_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename_regex</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">file_match</span><span class="p">,</span> <span class="s2">&quot;Invalid filename.&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">)</span>

        <span class="c1"># Ignore all Python files of modules created by `pyTranslate.py`</span>
        <span class="c1"># since these module files do not contain a corresponding XML file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m_&quot;</span><span class="p">):</span>
            <span class="n">xml_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">rectified_</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">.xml&quot;</span>
            <span class="c1"># Calling the `get_index` function in `mod_index_generator.py` to</span>
            <span class="c1"># map all variables and objects in the various files</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">module_file_exist</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">get_original_file_name</span><span class="p">(</span><span class="n">original_file_path</span><span class="p">)</span>
            <span class="n">xml_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">rectified_</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">.xml&quot;</span>
        <span class="c1"># Calling the `get_index` function in `mod_index_generator.py` to</span>
        <span class="c1"># map all variables and objects in the various files</span>
        <span class="n">module_mapper</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">xml_file</span><span class="p">)</span>

    <span class="n">module_import_paths</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">ast_string</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ast_list</span><span class="p">):</span>
        <span class="n">lambda_file</span> <span class="o">=</span> <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">lambda_tail</span>
        <span class="n">grfn_file</span> <span class="o">=</span> <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">grfn_tail</span>
        <span class="n">grfn_dict</span> <span class="o">=</span> <span class="n">create_grfn_dict</span><span class="p">(</span>
            <span class="n">lambda_file</span><span class="p">,</span>
            <span class="p">[</span><span class="n">ast_string</span><span class="p">],</span>
            <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
            <span class="n">module_mapper</span><span class="p">,</span>
            <span class="n">original_file_path</span><span class="p">,</span>
            <span class="n">module_file_exist</span><span class="p">,</span>
            <span class="n">module_import_paths</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">module_file_exist</span><span class="p">:</span>
            <span class="n">main_python_file</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.py&quot;</span>
            <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_python_file</span>
        <span class="n">grfn_filepath_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grfn_file</span><span class="p">)</span>
        <span class="c1"># Write each GrFN JSON into a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">grfn_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_handle</span><span class="p">:</span>
            <span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">grfn_dict</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_original_file_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_original_file_name">[docs]</a><span class="k">def</span> <span class="nf">get_original_file_name</span><span class="p">(</span><span class="n">original_file_path</span><span class="p">):</span>
    <span class="n">original_file</span> <span class="o">=</span> <span class="n">original_file_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">original_file</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--files&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A list of python files to generate a PGM for&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-p&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--grfn_suffix&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for the output PGM&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-l&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--lambda_suffix&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for output lambda functions&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--out&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Text file containing the list of output python files being &quot;</span>
        <span class="s2">&quot;generated&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--print_ast&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print ASTs&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--original_file&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename of the original Fortran file&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Read the outputFile which contains the name of all the python files</span>
    <span class="c1"># generated by `pyTranslate.py`. Multiple files occur in the case of</span>
    <span class="c1"># modules since each module is written out into a separate python file.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">arguments</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">python_files</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># The Python file names are space separated. Append each one to a list.</span>
    <span class="n">python_file_list</span> <span class="o">=</span> <span class="n">python_files</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="n">grfn_suffix</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">grfn_suffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lambda_suffix</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">lambda_suffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fortran_file</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">original_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">print_ast</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">print_ast</span>

    <span class="n">process_files</span><span class="p">(</span>
        <span class="n">python_file_list</span><span class="p">,</span> <span class="n">grfn_suffix</span><span class="p">,</span> <span class="n">lambda_suffix</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">,</span> <span class="n">print_ast</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Adarsh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>