

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Grounded Function Network (GrFN) Documentation &mdash; delphi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Delphi Database" href="delphi_database.html" />
    <link rel="prev" title="delphi.GrFN.networks.ForwardInfluenceBlanket.run" href="generated/delphi.GrFN.networks.ForwardInfluenceBlanket.run.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> delphi
          

          
            
            <img src="_static/delphi_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Grounded Function Network (GrFN) Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">[0.2.8]</span></code> - 2019-09-01</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#changes">Changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#grfn-spec-index">grfn_spec Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background-from-source-code-to-dynamic-system-representation">Background: From source code to dynamic system representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spec-notation-conventions">Spec Notation Conventions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#identifiers-grounding-scopes-namespaces-and-gensyms">Identifiers: grounding, scopes, namespaces and gensyms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preamble">Preamble</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier">Identifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grounding-and-source-code-reference">Grounding and source code reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-name">Base Name</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope-and-namespace-paths">Scope and Namespace Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#path-strings">Path Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier-string">Identifier String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier-gensym">Identifier Gensym</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grounding-metadata-spec">Grounding Metadata spec</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier-specification">Identifier Specification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variable-and-function-identifiers-and-references">Variable and Function Identifiers and References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-naming-convention">Variable Naming Convention</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-reference">Variable Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-naming-convention">Function Naming Convention</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-grfn-specification">Top-level GrFN Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-specification">Variable Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-value-domain">Variable Value Domain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-spec-examples">&lt;variable_spec&gt; examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function-specification">Function Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-assign-specification">Function Assign Specification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-assign-body-literal">Function assign body Literal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-assign-body-lambda">Function assign body Lambda</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-container-specification">Function Container Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-reference-specification">Function Reference Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-loop-plate-specification">Function Loop Plate Specification</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#change-log">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#m9-2019-07-01"><code class="docutils literal notranslate"><span class="pre">[0.1.m9]</span></code> - 2019-07-01:</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#added">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="#changed">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#m5-2019-05-01"><code class="docutils literal notranslate"><span class="pre">[0.1.m5]</span></code> - 2019-05-01:</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="#removed">Removed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#m3-2019-03-01"><code class="docutils literal notranslate"><span class="pre">[0.1.m3]</span></code> - 2019-03-01:</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#releases">Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="delphi_database.html">The Delphi Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="grfn_openapi.html">GrFN OpenAPI Specification</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">delphi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Grounded Function Network (GrFN) Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/grfn_spec.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="grounded-function-network-grfn-documentation">
<h1>Grounded Function Network (GrFN) Documentation<a class="headerlink" href="#grounded-function-network-grfn-documentation" title="Permalink to this headline">¶</a></h1>
<p><strong>Version 0.2.8</strong></p>
<div class="section" id="id1">
<h2><code class="docutils literal notranslate"><span class="pre">[0.2.8]</span></code> - 2019-09-01<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Changes since [0.1.m9]</p>
<div class="section" id="changes">
<h3>Changes<a class="headerlink" href="#changes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Major refactoring of GrFN Spec into</p>
<ol class="simple">
<li><p>OpenAPI</p></li>
<li><p>GrFN documentation (this document)</p></li>
</ol>
</li>
<li><p>Change GrFN specification versioning from <code class="docutils literal notranslate"><span class="pre">#.#.m#</span></code> to <code class="docutils literal notranslate"><span class="pre">#.#.#</span></code></p>
<ul>
<li><p>Previous release was <code class="docutils literal notranslate"><span class="pre">[0.1.m9]</span></code></p></li>
<li><p>Advancing minor version to 2 with refactoring to OpenAPI</p></li>
</ul>
</li>
</ul>
<p><a class="reference external" href="#change-og">Change Log</a> (from previous releases)</p>
</div>
</div>
<div class="section" id="grfn-spec-index">
<h2>grfn_spec Index<a class="headerlink" href="#grfn-spec-index" title="Permalink to this headline">¶</a></h2>
<p>Example whole system GrFN specification file structure</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace1</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace1_lambdas</span><span class="o">.</span><span class="n">py</span>
<span class="n">namespace2</span><span class="o">.</span><span class="n">json</span>
<span class="n">namespace2_lambdas</span><span class="o">.</span><span class="n">py</span>
<span class="o">...</span>
</pre></div>
</div>
<p>NOTE: <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> and <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a> are both formatted as <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>, but with particular <a class="reference external" href="#variable-and-function-identifiers-and-references">naming conventions</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;system_def&gt;</span></code> ::=  # serves as an index; has to be a DAG</p>
<ul>
<li><p>“date_created” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # name of system; optional?</p></li>
<li><p>“components” : list of <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec_refs&gt;</span></code>[attrval] ::=</p>
<ul>
<li><p>“name” : <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a></p></li>
<li><p>“imports” : list of <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a> # specifies which grfn_spec files to load</p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#top-level-grfn-specification"><code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“date_created” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“namespace” : <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a> # ‘current’ namespace; grfn_spec filename will be the same</p></li>
<li><p>“imports” : list of <code class="docutils literal notranslate"><span class="pre">&lt;import_identifier_spec&gt;</span></code>[attrval] ::=</p>
<ul>
<li><p>“source_identifier” : <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a></p></li>
<li><p>“name” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # the name as used locally in this grfn_spec</p></li>
</ul>
</li>
<li><p>“source” : list of <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;source_code_file_path&gt;</span></code></a></p></li>
<li><p>“start”: list of <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # ‘top-level’ function(s)</p></li>
<li><p>“identifiers” : list of <a class="reference external" href="#identifier-specification"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“base_name” : <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a></p></li>
<li><p>“scope” : <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code></a></p></li>
<li><p>“namespace” : <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code></a></p></li>
<li><p>“source_references” : list of <a class="reference external" href="#grounding-and-source-code-reference"><code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code></a></p></li>
<li><p>“gensym” : <a class="reference external" href="#identifier-gensym"><code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code></a></p></li>
<li><p>“grounding” : list of <a class="reference external" href="#grounding-metadata-spec"><code class="docutils literal notranslate"><span class="pre">&lt;grounding_metadata_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“source” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # URI to source document</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;definition&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;units&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;constraint&quot;</span></code></p></li>
<li><p>“value” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
<li><p>“score” : <code class="docutils literal notranslate"><span class="pre">&lt;real&gt;</span></code> # confidence score of grounding</p></li>
</ul>
</li>
</ul>
</li>
<li><p>“variables” : list of <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“name” : <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
<li><p>“domain” : <a class="reference external" href="#variable-value-domain"><code class="docutils literal notranslate"><span class="pre">&lt;variable_domain_type&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;integer&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;boolean&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code></p></li>
<li><p>“precision” : TODO</p></li>
</ul>
</li>
<li><p>“domain_constraints” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> # a disjunctive normal form, with v := variable value</p>
<ul>
<li><p>e.g., <code class="docutils literal notranslate"><span class="pre">&quot;(or</span> <span class="pre">(and</span> <span class="pre">(&lt;</span> <span class="pre">v</span> <span class="pre">infty)</span> <span class="pre">(&gt;=</span> <span class="pre">v</span> <span class="pre">5)</span> <span class="pre">(and</span> <span class="pre">(&gt;</span> <span class="pre">v</span> <span class="pre">-infty)</span> <span class="pre">(&lt;</span> <span class="pre">v</span> <span class="pre">0)))&quot;</span></code></p></li>
<li><p>Could this more generally reference other variables?</p></li>
</ul>
</li>
<li><p>“mutable” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
</ul>
</li>
<li><p>“functions” : list of <a class="reference external" href="#function-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code></a> … instances of the following:</p>
<ul>
<li><p><a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“name” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a></p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;assign&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;condition&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;decision&quot;</span></code></p></li>
<li><p>“arguments” : list of [ <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> ]</p></li>
<li><p>“return_value” : <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
<li><p>“body” : one of the following:</p>
<ul>
<li><p><a class="reference external" href="#function-assign-body-literal"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_literal_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;literal&quot;</span></code></p></li>
<li><p>“value” : <a class="reference external" href="#function-assign-body-literal"><code class="docutils literal notranslate"><span class="pre">&lt;literal_value&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“dtype” : <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;integer&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;boolean&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code></p></li>
<li><p>“value” : <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#function_assign_body_lambda"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_lambda_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;lambda&quot;</span></code></p></li>
<li><p>“name” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a></p></li>
<li><p>“reference” : <a class="reference external" href="#funciton-assign-body-lambda"><code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code></a> ::= a <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> denoting the python function in <code class="docutils literal notranslate"><span class="pre">lambdas.py</span></code></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#function-container-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_container_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“name” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a></p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;container&quot;</span></code></p></li>
<li><p>“arguments” : list of [ <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> ]</p></li>
<li><p>“updated” : list of <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> # variables side-effected during execution</p></li>
<li><p>“return_value” : <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
<li><p>“body” : list of <a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#function-loop-plate-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_loop_plate_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“name” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a></p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;loop_plate&quot;</span></code></p></li>
<li><p>“arguments” : list of <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
<li><p>“updated” : list of <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> # variables side-effected during execution</p></li>
<li><p>“test_at_end” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
<li><p>“exit_condition” : <code class="docutils literal notranslate"><span class="pre">&lt;loop_condition&gt;</span></code> ::= # continue loop WHILE predicate evaluates to “output_literal”</p>
<ul>
<li><p>“arguments” : list of [ <a class="reference external" href="#variable-reference"><code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> ]</p></li>
<li><p>“return_value” : <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> # the named variable of the exit_condition result</p></li>
<li><p>“output_literal” : <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> | <code class="docutils literal notranslate"><span class="pre">FALSE</span></code></p></li>
<li><p>“predicate” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a> # reference to lambda fn computing the condition (which must match the output_literal in order to exit)</p></li>
</ul>
</li>
<li><p>“body” : list of <a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“function” : <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a></p></li>
<li><p>“arguments” : list of [ <a class="reference external" href="#variable-reference"><code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> ]</p></li>
<li><p>“return_value” : <a class="reference external" href="#variable-reference"><code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code></a> | <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“name” : [ <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> | <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a> ]</p></li>
<li><p>“type” : <code class="docutils literal notranslate"><span class="pre">&quot;variable&quot;</span></code> | <code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#variable-reference"><code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code></a>[attrval] ::=</p>
<ul>
<li><p>“variable” : <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a></p></li>
<li><p>“index” : <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="background-from-source-code-to-dynamic-system-representation">
<h3>Background: From source code to dynamic system representation<a class="headerlink" href="#background-from-source-code-to-dynamic-system-representation" title="Permalink to this headline">¶</a></h3>
<p>GrFN, pronounced “Griffin”, is the central representation generated and manipulated by the <a class="reference external" href="https://ml4ai.github.io/automates/">AutoMATES</a> system (incorporating <a class="reference external" href="https://ml4ai.github.io/delphi">Delphi</a>).</p>
<p>The goal of GrFN is to provide the end-point target for a translation from the semantics of program (computation) specification (as asserted in source code) and scientific domain concepts (as expressed in text and equations) to the semantics of a (discretized) dynamic system model (akin to an extended version of a probabilistic graphical model).</p>
<p>A key assumption is that the program source code we are analyzing is intended to model aspects of some target physical domain, and that this target physical domain is a dynamical system that evolves over time. This means that some source code variables are assumed to correspond to dynamical system states of the represented system.</p>
<p>The system is decomposed into a set of individual states (represented as (random) variables), where the values of the states at any given time are a function of the values of zero or more other states at the current and/or previous time point(s). Because we are considering the evolution of the system over time, in general every variable has an index. The functional relationships may be instantaneous (based on the variables indexed at the same point in time) or a function of states of variables at different time indices.</p>
<p>There are four components in AutoMATES that generate (contribute to) and/or consume (operate on) GrFN:</p>
<ul class="simple">
<li><p>Program Analysis (PA) - generates</p></li>
<li><p>Text Reading (TR) - generates</p></li>
<li><p>Equation Reading (ER) - generates</p></li>
<li><p>Model Analysis (MA) - consumes</p></li>
</ul>
<p>GrFN integrates the extracted <em>Function Network</em> representation of source code (the result of Program Analysis) along with associated extracted comments, links to natural language text (the result of natural language processing by Text Reading), and links to and representation of equations (the result of equation extraction by Equation Reading).</p>
</div>
<div class="section" id="spec-notation-conventions">
<h3>Spec Notation Conventions<a class="headerlink" href="#spec-notation-conventions" title="Permalink to this headline">¶</a></h3>
<p>This specification (spec) document describes the GrFN JSON schema, specifying the JSON format that is to be generated by Program Analysis, Text Reading and Equation Reading. Model Analysis is the current main consumer; we also hope that other scientific model analysis systems (e.g., from the ASKE Program) will also be consumers and/or generators.</p>
<p>In this document we adopt a simplified <a class="reference external" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur Form (BNF)</a>-inspired grammar specification convention combined with a convention for intuitively defining JSON attribute-value lists. The schema definitions and instance GrFN examples are rendered in <code class="docutils literal notranslate"><span class="pre">monospaced</span> <span class="pre">font</span></code>, and interspersed with comments/discussion.</p>
<p>Following BNF convention, elements in <code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code> denote nonterminals, with <code class="docutils literal notranslate"><span class="pre">::=</span></code> indicating a definition of how a nonterminal is expanded. We will use some common nonterminals with standard expected interpretations, such as <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> for strings, <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> for integers, etc. Many of the definitions below will specify JSON attribute-value lists; when this is the case, we will decorate the nonterminal element definition by adding <code class="docutils literal notranslate"><span class="pre">[attrval]</span></code>, as follows::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">element_name</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span> 
</pre></div>
</div>
<p>We will then specify the structure of the JSON attribute-value list attributes (quoted strings) and their value types using a mixture of <a class="reference external" href="https://www.json.org/">JSON</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>.</p>
<p>For example, the following grfn_spec definition</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
	<span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
	<span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span> <span class="o">|</span> <span class="s2">&quot;units&quot;</span> <span class="o">|</span> <span class="s2">&quot;constraint&quot;</span>
	<span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> 
</pre></div>
</div>
<p>specifies the structure of the grfn JSON instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
	<span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="s2">&quot;http://epirecip.es/epicookbook/chapters/sir/intro&quot;</span><span class="p">,</span>
	<span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span><span class="p">,</span>
	<span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="s2">&quot;susceptible individuals&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also use the following conventions in the discussion below:</p>
<ul class="simple">
<li><p>‘FUTURE’: Tags anticipated extensions that may be needed but not yet
supported.</p></li>
<li><p>‘CHOICE’: Captures discussion of a CHOICE that does not yet have a clear
resolution</p></li>
<li><p>‘FOR NOW’: Tags the approach being currently taken, eiher in response to FUTURE or CHOICE.</p></li>
</ul>
</div>
</div>
<div class="section" id="identifiers-grounding-scopes-namespaces-and-gensyms">
<h2>Identifiers: grounding, scopes, namespaces and gensyms<a class="headerlink" href="#identifiers-grounding-scopes-namespaces-and-gensyms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="preamble">
<h3>Preamble<a class="headerlink" href="#preamble" title="Permalink to this headline">¶</a></h3>
<p>The current GrFN design strategy is to separate <em>identifiers</em> (any program symbol used to denote a program element) from the <em>program elements</em> themselves (namely, variables and functions), as each program element will be denoted by one or more identifiers, and the different types of program elements themselves have intended scientific modeling “functions”: variables (may) represent aspects of the modeled domain, and functions represent processes that change variable states.</p>
<p>A key role of identifiers in the GrFN representation is to enable <em>linking</em> (grounding) of program elements to information extracted by Text and Equation Reading. Identifiers bring together two types of information that make this linking possible:</p>
<ol class="simple">
<li><p>The identifier name (<a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a>) and namespace context (<a class="reference external" href="#scope-and-namespace-paths">scope and namespace paths</a>) of the identifier as it appears in program source context are used as evidence of potential semantic relations to other textual sources based on string similarity or name embedding;</p></li>
<li><p>Information about the location and neighborhood in source code where the identifier is used (a <a class="reference external" href="#grounding-and-source-code-reference"><code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code></a>) provides additional sources of evidence, based on proximity to source code comments and docstrings, as well as proximity to uses of other identifiers.</p></li>
</ol>
<p>An linking/grounding inference algorithm uses string or embedding similarity between base, scope and namespace names and information extracted from documents by Text Reading to form hypotheses of potential links between identifiers and the text-extracted information. Such link hypotheses are explicitly connected to identifiers in GrFN (by instances of <a class="reference external" href="#grounding-metadata-spec"><code class="docutils literal notranslate"><span class="pre">&lt;grounding_metadata_spec&gt;</span></code></a>).</p>
<p>Program elements (variables and functions) are associated with identifiers based on declarations in source code, and thereafter, the use of the same identifiers elsewher in source code is a denotation of the variable or function. Information from Text Reading (e.g., “mentions” of domain concept terms or phrases in text) associated with identifiers is then linked to program elements by association of the idenifier. For example, the indicator ‘S’ may store an integer and be described in documentation as associated with (defined as representing) the “susceptible population”.</p>
</div>
<div class="section" id="identifier">
<h3>Identifier<a class="headerlink" href="#identifier" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference external" href="#identifier-specification">identifier</a> is a symbol used to uniquely identify a program element in code, where a <em>program element</em> is a</p>
<ul class="simple">
<li><p>constant value</p></li>
<li><p>variable</p></li>
<li><p>function</p></li>
</ul>
<blockquote>
<div><p>FUTURE: possibly: type, class</p>
</div></blockquote>
<p>More than one identifier can be used to denote the same program element, but an identifier can only be associated with one program element at a time.</p>
</div>
<div class="section" id="grounding-and-source-code-reference">
<h3>Grounding and source code reference<a class="headerlink" href="#grounding-and-source-code-reference" title="Permalink to this headline">¶</a></h3>
<p>Identifiers play a key role in connecting the model as implemented in source code to the target domain that it models. <em>Grounding</em> is the task of inferring what aspect of the target scientific domain a program element may correspond to. Identifiers, by their <a class="reference external" href="#base-name">(base) name(s)</a> and the context of their declaration and use (i.e., where they occur in code, through their <a class="reference external" href="#scope-and-namespace-paths">scope and namespace</a>), and the linline comment and doc strings that occur around them, provide clues to what program elements are intended to represent in the target domain. For this reason, we need to associate with identifiers several pieces of information. This information will be collected during program analysis and associated with the identifier declaration:</p>
<blockquote>
<div><p>FUTURE: General handling of pointers/references (related to the concept of having an “alias”) will require care, as this introduces the possiblity of multiple identifiers being used to refer to the same program element, and also a single identifier being used to refer to different program elements in different contexts. In the general case it is not possible to determine all pointer references <em>statically</em>. (DSSAT does include some pointers.)</p>
</div></blockquote>
<p>To facilitate grounding inference, the <a class="reference external" href="#identifier-specification"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code></a> will have a “source_references” attribute whose value is a list of <code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code>s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">source_code_reference</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The string contains information to indicate the location within the source code where an identifier was used.</p>
<blockquote>
<div><p>TODO: Program Analysis and Text and Equation Reading (NLP processing of comments and source literature) will determine how source code references are represented within the string. It may be sufficient to have a single line number to represent the source code line within which the identifier was used.</p>
</div></blockquote>
</div>
<div class="section" id="base-name">
<h3>Base Name<a class="headerlink" href="#base-name" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> is intended to correspond (when available) to the identifier token name as it appears in the source language (e.g., Fortran). The <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> is itself a string</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">base_name</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>but follows the conventions of <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">python identifier specification rules</a> (which includes Fortran naming syntax).</p>
<blockquote>
<div><p>FUTURE: may extend this as more source languages are supported.</p>
</div></blockquote>
<p>Below, we specify the conventions for <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code>s of identifiers that do not originate in the source code:</p>
<ul class="simple">
<li><p><a class="reference external" href="#variable-naming-convention">Variable Naming Convention</a></p></li>
<li><p><a class="reference external" href="#function-naming-convention">Function Naming Convention</a></p></li>
</ul>
</div>
<div class="section" id="scope-and-namespace-paths">
<h3>Scope and Namespace Paths<a class="headerlink" href="#scope-and-namespace-paths" title="Permalink to this headline">¶</a></h3>
<p>Identifiers may have the same <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> (as it appears in source code) but be distinguished by either (or both) the “<a class="reference external" href="https://en.wikipedia.org/wiki/Scope_(computer_science)">scope</a>” and “<a class="reference external" href="https://en.wikipedia.org/wiki/Namespace">namespace</a>” within which they are defined in the source code.</p>
<p>Each source language has its own rules for specifying scope and namespace, and it will be the responsibility of each program analysis module (e.g., Fortran <code class="docutils literal notranslate"><span class="pre">for2py</span></code>) to identify the hierarchical structure of the context that uniquely identifies the specific scope and/or namespace within which an identifier <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> is defined. However, generally scopes and namespaces may be defined hierarchically, such that the name for each level of the hierarchy taken together uniquely define the context. A “path” of names appears to be sufficient to generally represent the hierarchical context for either a specific scope or namespace. In general, names for a path are listed in order from general (highest level in the hierarchy) to specific.</p>
<p>Examples:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>: As will be described below, program analysis will assign unique names for scopes (see <a class="reference external" href="#function-naming-convention">discussion below under conditional, container and loop_plate function naming convention</a>). Given these names, the scopes of the two inner loops within the outer loop of function <code class="docutils literal notranslate"><span class="pre">foo</span></code> in this example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>      <span class="c1"># assigned name &#39;loop$1&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>  <span class="c1"># assigned name &#39;loop$1&#39; (in the scope</span>
                             <span class="c1">#    ... of the outer loop$1)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>  <span class="c1"># assigned name &#39;loop$2&#39; (also in the</span>
                             <span class="c1">#    ... scope of the outer loop$1)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>… would be uniquely specified by the following path (respectively):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$1&quot;</span><span class="p">,</span> <span class="s2">&quot;loop$2&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>In general, it is not necessary within GrFN to independently declare scopes. Instead, we simply specify the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code> in an indicator declaration as a list of strings under the “scope” attribute in the identifier declaration (below).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">scope_path</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “top” level of the file (i.e., not enclosed within another program block context) will be assigned the default scope name of “_TOP”. All other scopes are either explicitly named (such as a named function), or are assigned a unique name by program analysis according to the rules of the type of scope (such as container, loop, conditional, etc), defined below. In such cases other than top, there is no need to include the “_TOP” in the path – it will be assumed that those named scopes are all within the default top-level scope.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code>: Different languages have different conventions for defining namespaces, but in general they are either (1) explicitly defined within source code by namespace declarations (such as Fortran “modules” or C++ “namespace”s), or (2) implicitly defined by the project directory structure within which a file is located (as in Python). In the case of namespaces defined by project directory structure, two files in different locations in the project directory tree may have the same name. To distinguish these, program analysis will capture the path of the directory tree from the root to the file. The final name in the path, which is the name of the source file, will drop the file extension. For example, the namespace for file <code class="docutils literal notranslate"><span class="pre">baz.py</span></code> within the following directory tree</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">/</span>
    <span class="n">bar</span><span class="o">/</span>
        <span class="n">baz</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>would be the uniquely specified by the following path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="s2">&quot;baz&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the case of declared namespaces, the namespace declaration will determine the path (which may only consist of one string name).</p>
<p>Again, it is not necessary within GrFN to independently declare a namespace; like the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>, we specify the <code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code> within an identifier declaration as a list strings under the “namespace” attribute in the identifier declaration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">namespace_path</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Like the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code>, the string names of the path uniquely defining the namespace are in in order from general to specific, with the last string name either being the implicit namespace defined by the source code file, or the user-defined name of the namespace.</p>
</li>
</ul>
</div>
<div class="section" id="path-strings">
<h3>Path Strings<a class="headerlink" href="#path-strings" title="Permalink to this headline">¶</a></h3>
<p>It will be convenient to be able to express <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code></a>s and <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code></a>s using single strings within GrFN (particularly when building an identifier string). For this we introduce a special string notation in which the string names that make up a path are expressed in order but separated by periods. These representations will be referred to as the <code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code>, respectively. The string representations of the <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code></a> and <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code></a> examples above would be:</p>
<ul>
<li><p>Example <code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.loop$1.loop$1&quot;</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.loop$1.loop$2&quot;</span>
</pre></div>
</div>
</li>
<li><p>Example <code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;foo.bar.baz&quot;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="identifier-string">
<h3>Identifier String<a class="headerlink" href="#identifier-string" title="Permalink to this headline">¶</a></h3>
<p>Identifiers are uniquely defined by their <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a>, <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path&gt;</span></code></a>, and <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code></a>. It will be convenient to refer unambiguously to any identifier using a single string, outside of the identifier specification declaration (defined below). We define an <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code> by combining the ‘namespace’, ‘scope’ and ‘base_name’ (in that order) within a single string by separating the <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a>, <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code></a> and <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> by double-colons:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;&lt;namespace_path_string&gt;::&lt;scope_path_string&gt;::&lt;base_name&gt;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>s will be used to denote identifiers as they are used in variable and function specifications (described below).</p>
</div>
<div class="section" id="identifier-gensym">
<h3>Identifier Gensym<a class="headerlink" href="#identifier-gensym" title="Permalink to this headline">¶</a></h3>
<p>One of the outputs of program analysis is a functionally equivalent version of the original source code and lambda functions (described below), both expressed in Python (as the intermediate target language). All identifiers in the output Python must match identifiers in GrFN. Since capturing the semantics (particularly the namespace and scope context) results in a representation that does not appear to be consistently expressible in legal Python symbol names, we will use <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s that can be represented (generally more compactly) as legal Python names and associated uniquely with identifiers.</p>
<blockquote>
<div><p>FUTURE: Create a hashing function that can translate uniquely back and forth between <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s and identifier strings.</p>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: Generate <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>s as Python names that start with a letter followed by a unique integer. The letter could be ‘g’ for a generic gensym (e.g., g2381), or ‘v’ to indicate a variable identifier (e.g., v921) and ‘f’ to indicate a function identifier (e.g. f38).</p>
</div></blockquote>
<p>Each identifier will be associated one-to-one with a unique <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code>.</p>
</div>
<div class="section" id="grounding-metadata-spec">
<h3>Grounding Metadata spec<a class="headerlink" href="#grounding-metadata-spec" title="Permalink to this headline">¶</a></h3>
<p>Text Reading is currently working on extracting three types of information that can be associated with identifiers:</p>
<ul class="simple">
<li><p>Definitions (e.g., ‘wind speed’, ‘susceptible individuals’)</p></li>
<li><p>Units (e.g., ‘millimeters’, ‘per capita’)</p></li>
<li><p>Constraints (e.g., ‘&gt; 0’, ‘&lt;= 100’)</p></li>
</ul>
<p>Each of these types can be expressed as an instance of a <code class="docutils literal notranslate"><span class="pre">&lt;grounding_metadata_spec&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
	<span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
	<span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;definition&quot;</span> <span class="o">|</span> <span class="s2">&quot;units&quot;</span> <span class="o">|</span> <span class="s2">&quot;constraint&quot;</span>
	<span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> 
</pre></div>
</div>
<blockquote>
<div><p>FUTURE: add confidence/belief score</p>
</div></blockquote>
</div>
<div class="section" id="identifier-specification">
<h3>Identifier Specification<a class="headerlink" href="#identifier-specification" title="Permalink to this headline">¶</a></h3>
<p>Each identifier within a GrFN specification will have a single <code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code> declaration. An identifier will be declared in the GrFN spec JSON by the following attribute-value list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">identifier_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;base_name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">base_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;scope&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">scope_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;namespace&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">namespace_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;source_references&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">source_code_reference</span><span class="o">&gt;</span>
    <span class="s2">&quot;gensym&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">gensym</span><span class="o">&gt;</span>
    <span class="s2">&quot;grounding&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">grounding_metadata_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="variable-and-function-identifiers-and-references">
<h2>Variable and Function Identifiers and References<a class="headerlink" href="#variable-and-function-identifiers-and-references" title="Permalink to this headline">¶</a></h2>
<div class="section" id="variable-naming-convention">
<h3>Variable Naming Convention<a class="headerlink" href="#variable-naming-convention" title="Permalink to this headline">¶</a></h3>
<p>A variable name will be an <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>A top level source variable named ABSORPTION would then simply have the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> of “ABSORPTION” plus the relevant <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a> and <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code></a>.</p>
<p>When there are two (or more) separate instances of new variable declarations in the same context (same namespace and scope) using the same name, then we’ll add an underscore and number to the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> to distinguish them. For example, if ABSORPTION is defined twice in the same namespace and scope, then the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> of the first (in order in the source code) is named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ABSORPTION_1&quot;</span>
</pre></div>
</div>
<p>And the second:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ABSORPTION_2&quot;</span>
</pre></div>
</div>
<p>Finally, in some cases (described below), program analysis will introduce variables (e.g., when analyzing conditionals). The naming conventions for the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> of such introduced variables are described below.</p>
</div>
<div class="section" id="variable-reference">
<h3>Variable Reference<a class="headerlink" href="#variable-reference" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span> 
    <span class="s2">&quot;variable&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In addition to capturing source code variable environment context in variable declarations, we also need a mechanism to disambiguate specific instances of <em>use</em> of the same variable within the same context to accurately capture the logical order of variable value updates. In this case, we consider this as a repeated reference to the same variable. The semantics of repeated reference is captured by the variable “index” attribute of a <code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code>. The index integer serves to disambiguate the execution order of the variable state references, as determined during program analysis.</p>
</div>
<div class="section" id="function-naming-convention">
<h3>Function Naming Convention<a class="headerlink" href="#function-naming-convention" title="Permalink to this headline">¶</a></h3>
<p>Function names, like variable names, are also ultimately <a class="reference external" href="#identifier-specification">identifiers</a> that will commonly be referenced within GrFN by their <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> (and therefore include their <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a> and <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code></a>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">identifier_string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>However, there are additional rules for determining the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> of the function. Because of this particular set of rules, the <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> of the function name will be referred to as a <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>. The general string format for a <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;function_base_name&gt; ::= &lt;function_type&gt;[$[&lt;var_affected&gt;|&lt;code_given_name&gt;]]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_type&gt;</span></code> is the string representing which of the four types the function belongs to (the types are described in more detail, below): <a class="reference external" href="#function-assign-specification">“assign”</a>, <a class="reference external" href="#function-assign-specification">“condition”</a>, <a class="reference external" href="#function-assign-specification">“decision”</a>, <a class="reference external" href="#function-container-specification">“container”</a>, <a class="reference external" href="#function-loop-plate-specification">“loop_plate”</a>. In the case of a loop_plate, we will name the specific loop using the generic name “loop” along with an integer (starting with value 1) uniquely distinguishing loops within the same namespace and scope.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> is used when the function identified by program analysis has also been given a name within source code. For example, in this python example:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">foo</span><span class="p">()</span><span class="o">:</span>
    <span class="p">...</span>
</pre></div>
</div>
<p>the function foo is a type of “container” and its <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> is “foo”, making the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;container$foo&quot;</span>
</pre></div>
</div>
<p>The optional <code class="docutils literal notranslate"><span class="pre">&lt;var_affected&gt;</span></code> will only be relevant for assign, condition and decision function types, and the name of the variable affected will be added after the <code class="docutils literal notranslate"><span class="pre">&lt;function_type&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code>. For example, a condition involving the setting of the (inferred) boolean variable IF_1 would have the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;condition$IF_1&quot;</span>
</pre></div>
</div>
<p>Here are example function names for each function type. In each example, we assume the function is defined within the scope of another function, UPDATE_EST, and the namespace CROP_YIELD.</p>
<ul>
<li><p><a class="reference external" href="#function-assign-specification"><strong>Assign</strong></a>: An assignment of the variable with the <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code> “CROP_YIELD::UPDATE_EST::YIELD_EST” (which denotes the identifier with <code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code> “YIELD_EST” in the scope of the function UPDATE_EST declared in the namespace CROP_YIELD) has the <code class="docutils literal notranslate"><span class="pre">function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;assign$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
<p>If this assignment takes place in the function UPDATE_EST and the namespace CROP_YIELD, then the full <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> of the function identifier would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::UPDATE_EST::assign$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-assign-specification"><strong>Condition</strong></a>: A condition assigning the (inferred) boolean variable IF_1 in the scope of the function UPDATE_EST of the namespace CROP_YIELD would have the <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::UPDATE_EST::condition$IF_1&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-assign-specification"><strong>Decision</strong></a>: A decision function assigns a variable a value based on the (outcome) state of a condition variable. If the variable “YIELD_EST” (from the namespace “CROP_YIELD” and scope “UPDATE_EST”) is being updated as a result of a conditional outcome in the namespace “CROP_YIELD” and scope “DERIVE_YIELD”, then the <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::DERIVE_YIELD::decision$CROP_YIELD::UPDATE_EST::YIELD_EST&quot;</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#function-container-specification"><strong>Container</strong></a>: A container function declared in source code to have the name CROP_YIELD would then have the <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> of CROP_YIELD, and if this was declared at the top level of a file (defining the namespace) called CROP_YIELD would have the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;container$CROP_YIELD&quot;</span>
</pre></div>
</div>
<p>and the full <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code> of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::NULL::container$CROP_YIELD&quot;</span>
</pre></div>
</div>
<p>(Note that the first occurrence of “CROP_YIELD” in the string is for the namespace, the NULL is because it’s defined at the top level, and then the second occurrence of “CROP_YIELD” is the <code class="docutils literal notranslate"><span class="pre">&lt;code_given_name&gt;</span></code> of CROP_YIELD.)</p>
</li>
<li><p><a class="reference external" href="#function-loop-plate-specification"><strong>Loop_plate</strong></a>: Loops themselves are not assigned identifiers within source code, so identifiers will be assigned during program analysis. As described above, the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> of the loop_plate function type is “loop” followed by a ‘$’ and an integer starting from <code class="docutils literal notranslate"><span class="pre">1</span></code> that distinguishes the loop from any other loops occurring in the same namespace and scope.</p>
<ul>
<li><p>A single loop within the function CROP_YIELD of the namespace CROP_YIELD has the <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD::loop$1&quot;</span>
</pre></div>
</div>
</li>
<li><p>The third of three loops within the function CROP_YIELD of namespace CROP_YIELD:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD::loop$3&quot;</span>
</pre></div>
</div>
</li>
<li><p>A loop nested in the context of the second loop, “loop$2”, in the CROP_YIELD function within the CROP_YIELD namespace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD.loop$2::loop$1&quot;</span>
</pre></div>
</div>
</li>
<li><p>An assignment of the variable “CROP_YIELD::_TOP::RAIN” (i.e., the variable “RAIN” was defined in the default “top”-level scope, within the namespace CROP_YIELD) within a single loop in the CROP_YIELD function in the CROP_YIELD namespace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;CROP_YIELD::CROP_YIELD.loop$1::assign$CROP_YIELD::_TOP::RAIN&quot;</span>
</pre></div>
</div>
<p>(Note that the above string is still unambiguous to parse to recover the components pieces of the name: the first two names separated by ‘::’ are the <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path_string&gt;</span></code></a> followed by the <a class="reference external" href="#path-strings"><code class="docutils literal notranslate"><span class="pre">&lt;scope_path_string&gt;</span></code></a>, with the rest being the <code class="docutils literal notranslate"><span class="pre">&lt;function_base_name&gt;</span></code> of the function, which itself is an “assign” of a variable that itself is a complete <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>)</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="top-level-grfn-specification">
<h2>Top-level GrFN Specification<a class="headerlink" href="#top-level-grfn-specification" title="Permalink to this headline">¶</a></h2>
<p>The top-level structure of the GrFN specification is the <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code> and is itself a JSON attribute-value list, with the following schema definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grfn_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;date_created&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">source_code_file_path</span><span class="o">&gt;</span>
    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;identifiers&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">identifier_spec</span><span class="o">&gt;</span>
    <span class="s2">&quot;variables&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_spec</span><span class="o">&gt;</span>
    <span class="s2">&quot;functions&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “date_created” attribute is a string representing the date+time that the current GrFN was generated (this helps resolve what version of the program analysis code (e.g., for2py) was used).</p>
<p>There may be a single GrFN spec file for multiple source code files.</p>
<blockquote>
<div><p>CHOICE: A source file may define identifiers and program elements that are then referenced/used in many other system program unit components (other files). We can defined the concepts of a “Program” as the collection of source code from a file plus any other files containing source code that it references/uses. If we have a single GrFN spec for each “Program”, then we will be repeatedly reproducing many identifiers and other program element declarations (variables, functions). The alternatives are:</p>
</div></blockquote>
<blockquote>
<div><ol class="simple">
<li><p>A single GrFN spec for a given “Program” and live with the redundant re-representation of source code that is shared across different units.</p></li>
<li><p>Have a single GrFN spec for each individual file and develop method for importing/using GrFN specs that are used by other GrFN specs. (A variant of this approach could allow only including GrFN spec for the parts of the shared source code that are directly relevant to a “Program”.)</p></li>
</ol>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: Go with Option (1): The main target of a GrFN spec file is <em>all</em> of the source code files involved in defining a “Program”.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE: Add ability for GrFN specs to “import” and/or “use” other GrFN specs of other modules (leading to the more efficient option (2)).</p>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: the “source” attribute is a list of one or more <code class="docutils literal notranslate"><span class="pre">&lt;source_code_file_path&gt;</span></code>s. The <code class="docutils literal notranslate"><span class="pre">&lt;source_code_file_path&gt;</span></code> identifying a source file is represented the same way as a <a class="reference external" href="#scope-and-namespace-paths"><code class="docutils literal notranslate"><span class="pre">&lt;namespace_path&gt;</span></code></a>, except that the final name (the name of the file itself) <em>will</em> include the file extension.</p>
</div></blockquote>
<p>It is conventient to explicitly represent the functions that are intended to be called as the “top level” functions of the “Program”. We will refer to these as “start” points. These may be explicity specified by a programmer/user.</p>
<blockquote>
<div><p>FOR NOW: “start” points will be manually specified.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE: Consider methods of automatically inferring the “start” points. For example, these might be the roots of the computation graph representing the “Program”. However, there are subtleties here: e.g., function call loops (fn1 calls fn2, which calls fn1).</p>
</div></blockquote>
<p>To capture this concept, the “start” attribute is a list of zero or more names of the entry point(s) of the (Fortran) source code (for example, the PROGRAM module). These will be function <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>s. In the absence of any entry point, this value will be an empty list: <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>The “identifiers” attributes contains a list of <a class="reference external" href="#identifier-specification"><code class="docutils literal notranslate"><span class="pre">&lt;identifer_spec&gt;</span></code></a>s.</p>
<blockquote>
<div><p>FUTURE: It may also be desirable to add an attribute to represent the program analysis code version used to generate the GrFN (as the program analysis code is evolving and each change has different properties).</p>
</div></blockquote>
<blockquote>
<div><p>FOR NOW: “dateCreated” will play this role.</p>
</div></blockquote>
<p>The “variables” attribute contains a list of <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>s.</p>
<blockquote>
<div><p>(NOTE: In GrFN version 0.1.m3, <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>s were defined in the context of <a class="reference external" href="#function-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code></a>s. With need to iterate over variables (e.g. when performing inference for associating comments and text with variable definitions), it is more convenient to group variable specifications at the top level. Starting in GrFN version 0.1.m5, references to variables within functions will use <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>s to identify the variables, and <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>s will be listed in the top-level GrFN “variables” attribute.)</p>
</div></blockquote>
<p>A (partial) example instance of the JSON generated for a <code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code> of an analyzed file in the path ‘crop_system/yield/crop_yield.py’ is:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;dateCreated&quot;</span><span class="o">:</span> <span class="s2">&quot;20190127&quot;</span><span class="p">,</span>
    <span class="s2">&quot;source&quot;</span><span class="o">:</span> <span class="p">[[</span><span class="s2">&quot;crop_system&quot;</span><span class="p">,</span> <span class="s2">&quot;yield&quot;</span><span class="p">,</span> <span class="s2">&quot;crop_yield.py&quot;</span><span class="p">]],</span>
    <span class="s2">&quot;start&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;MAIN&quot;</span><span class="p">],</span>
    <span class="s2">&quot;identifiers&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">identifier_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
    <span class="s2">&quot;variables&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">variable_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
    <span class="s2">&quot;functions&quot;</span><span class="o">:</span> <span class="p">[...</span> <span class="nx">function_specs</span> <span class="nx">go</span> <span class="nx">here</span><span class="p">...]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-specification">
<h2>Variable Specification<a class="headerlink" href="#variable-specification" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;domain&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_domain_type</span><span class="o">&gt;</span>
    <span class="s2">&quot;mutable&quot;</span> <span class="p">:</span> <span class="n">TRUE</span> <span class="o">|</span> <span class="n">FALSE</span>
</pre></div>
</div>
<p>As defined above, the <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> is itself an <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>.</p>
<p>The “mutable” attribute specifies whether the variable value <em>can</em> (TRUE) or <em>cannot</em> (FALSE) be changed. (Note that the values TRUE and FALSE are JSON Boolean values.) Mutability is determined by Program Analysis, and Model Analysis can use this information in sensitivity anlysis (if the constant value of a non-mutable variable can be determined, then the variable does not need to be varied in sensitivity analysis).</p>
<blockquote>
<div><p>TODO: Possibly make explicit specification of “mutable” optional, with default value TRUE, so only need to explicitly specify when FALSE. Does this cause trouble for parsing?</p>
</div></blockquote>
<p>Some languages (including Fortran and Python) provide mechanisms for making variable declarations private (such as Python’s name mangling, by prepending an underscore to a variable name).</p>
<blockquote>
<div><p>FOR NOW: Our hypothesis is that simply prepending another underscore (following python <a class="reference external" href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references">name mangling</a>) will make the “private” variable <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base_name&gt;</span></code></a> unique from other variable names. Also, Program Analysis will “preserve” the semantics of privacy by ensuring there are no outer-scope references to a private variable, and this will carry through in explicit references (or lack thereof, in this case) captured in the GrFN spec (in particular, in the <a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a>s of the “body” of container and loop_plate function specs).</p>
</div></blockquote>
<div class="section" id="variable-value-domain">
<h3>Variable Value Domain<a class="headerlink" href="#variable-value-domain" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">variable_domain_type</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “domain” attribute of a <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a> specifies what values the variable can be assigned to. To start, we will keep things simple and restrict ourselves to four types that can be specified as strings:</p>
<ul class="simple">
<li><p>“real” (i.e. a floating-point number)</p></li>
<li><p>“integer”</p></li>
<li><p>“boolean”</p></li>
<li><p>“string”</p></li>
</ul>
<p>(The idea of the variable domain is intended to be close to the idea of
the “support” of a random variable, although should also correspond to
standard data types.)</p>
<blockquote>
<div><p>FUTURE: Extend to accommodate arrays.</p>
</div></blockquote>
<blockquote>
<div><p>FUTURE:</p>
</div></blockquote>
<blockquote>
<div><ul class="simple">
<li><p>Accommodate other structures: Unions, composite data structures, classes.</p></li>
<li><p>Extend the domain specification to represent whether there are bounds on the values (e.g., positive integers, or real values in (0,10], etc.). When we move to doing this, the value of “domain” will itself become a new JSON attrval type.</p></li>
</ul>
</div></blockquote>
<p>Python is a strongly-typed language, but is also a dynamically typed language. However, that’s not to say that there is no type specification in Python. Python 3 now provides nascent support for explicit typing via <a class="reference external" href="https://docs.Python.org/3/library/typing.html">type
hints</a>.</p>
<blockquote>
<div><p>FUTURE: Explore whether/how type hints get represented in the AST. This will matter when we get to adding more explicit variable domain semantics in later model analysis.</p>
</div></blockquote>
<p>For our purposes in the near term, we do want to capture what type and value-domain information is available; there are two main sources of this information (parentheses note the analysis process that may extract/infer/preserve this information):</p>
<ol class="simple">
<li><p><strong>Source Declarations</strong>: (Program Analysis) Fortran statically specifies types in declarations.
We can preserve type information in Program Analysis-generated Python code by using type hints or by adding to generated docstrings.</p></li>
<li><p><strong>Docstrings</strong>: (Text Reading) Source code docstrings and comments may provide information about types and value ranges that can be inferred by Text Reading.</p></li>
</ol>
</div>
<div class="section" id="variable-spec-examples">
<h3>&lt;variable_spec&gt; examples<a class="headerlink" href="#variable-spec-examples" title="Permalink to this headline">¶</a></h3>
<p>Here are three examples of <code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code> objects:</p>
<ul>
<li><p>Example of a “standard” variable MAX_RAIN within the CROP_YIELD function of the CROP namespace:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::CROP_YIELD::MAX_RAIN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">FALSE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Example of loop index variable DAY in the context of the second instance of a loop in the function CROP_YIELD (in the CROP namespace):</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::CROP_YIELD.loop$2::DAY&quot;</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">TRUE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Example of variable introduced (inferred) when analyzing a conditional statement that is within the named function UPDATE_EST of the CROP namespace:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;CROP::UPDATE_EST::IF_1&quot;</span>
    <span class="s2">&quot;domain&quot;</span><span class="o">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mutable&quot;</span><span class="o">:</span> <span class="nx">TRUE</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="function-specification">
<h2>Function Specification<a class="headerlink" href="#function-specification" title="Permalink to this headline">¶</a></h2>
<p>Next we have the <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>.</p>
<p>All <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s include a <a class="reference external" href="#function-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;function_name&gt;</span></code></a>, following the <a class="reference external" href="#function-naming-convention">function naming convention described above</a>.</p>
<p>There are five types of functions; three types can be expressed using the same attributes in their JSON attribute-value list (<a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code></a>), while the others (<a class="reference external" href="#function-container-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_container_spec&gt;</span></code></a>, <a class="reference external" href="#function-loop-plate-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_loop_plate_spec&gt;</span></code></a>) require different attributes. So this means there are three specializations of the &lt;function_spec&gt;, one of which (<a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code></a>) will be used for three function types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_spec</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span>
    <span class="o">&lt;</span><span class="n">function_assign_spec</span><span class="o">&gt;</span>         <span class="c1"># covers &quot;assign&quot;, &quot;condition&quot;, &quot;decision&quot;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_container_spec</span><span class="o">&gt;</span>    <span class="c1"># type &quot;container&quot;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_loop_plate_spec</span><span class="o">&gt;</span>   <span class="c1"># type &quot;loop_plate&quot;</span>
</pre></div>
</div>
<p>All three specs will have a “type” attribute with a string value that will unambiguously identify which type of function is being specified. The five possible types are:</p>
<ul class="simple">
<li><p>“<a class="reference external" href="#function-assign-specification">assign</a>”</p>
<ul>
<li><p>“<a class="reference external" href="#function-assign-specification">condition</a>” (a special case of Assign)</p></li>
<li><p>“<a class="reference external" href="#function-assign-specification">decision</a>”  (a special case of Assign)</p></li>
</ul>
</li>
<li><p>“<a class="reference external" href="#function-container-specification">container</a>”</p></li>
<li><p>“<a class="reference external" href="#function-loop-plate-specification">loop_plate</a>”</p></li>
</ul>
<p>All <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s will also have a “name” attribute with a unique
<a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> (across <code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code>s), as described above under the <a class="reference external" href="#function-naming-convention">Function Naming Convention</a> section; as described in that section, the function <a class="reference external" href="#base-name"><code class="docutils literal notranslate"><span class="pre">&lt;base\_name&gt;</span></code></a> will include the function type name, but having the explicit type attribute makes JSON parsing easier.</p>
<div class="section" id="function-assign-specification">
<h3>Function Assign Specification<a class="headerlink" href="#function-assign-specification" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code> denotes the setting of the value of a
variable. The values are assigned to the “target” variable (denoted by
a <a class="reference external" href="#variable-reference"><code class="docutils literal notranslate"><span class="pre">&lt;variable_reference&gt;</span></code></a> or <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a>) and the value is determined by the “body” of the assignment, which itself may either be a literal value (specified by <a class="reference external" href="#function-assign-body-literal"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_literal_spec&gt;</span></code></a>) or a lambda function (specified by <a class="reference external" href="#function-assign-body-lambda"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_lambda_spec&gt;</span></code></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;assign&quot;</span> <span class="o">|</span> <span class="s2">&quot;condition&quot;</span> <span class="o">|</span> <span class="s2">&quot;decision&quot;</span>
        <span class="c1"># note that the value of the &quot;type&quot; is a literal/terminal </span>
        <span class="c1"># value of the grammar</span>
    <span class="s2">&quot;sources&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;target&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_assign_body_literal_spec</span><span class="o">&gt;</span> 
             <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_assign_body_lambda_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>There are three types of assign functions, distinguished by the value of the attribute “type”.</p>
<ul class="simple">
<li><p><strong>“assign”</strong>: This represents the general case of assignment of a variable to some value.</p></li>
<li><p><strong>“condition”</strong>: In the special case where Program Analysis is analyzing a conditional (i.e., “if”) statement, then Program Analysis will infer a new boolean target variable, and the computation of the condition itself will be represented by a function assigning the inferred boolean variable value. Semantically, this is nothing more than an assignment of a boolean variable, but conceptually it will be useful to distinguish assignments used for conditions from other assignments.</p></li>
<li><p><strong>“decision”</strong>: Also as part of analyzing a conditional, any variables whose values are updated as a result of the condition outcome must have their values updated. These will be updated by “decision” assignment functions, whose target is the variable being updated, and the computations will involve the state of the conditional variable, the previous state of the variable being updated, and possibly other variable values. Again, semantically this is nothing more than an assignment, but is useful to distinguish from other assignments.</p></li>
</ul>
<p>The identifier conventions for assign, condition and decision functions is described above in the section on <a class="reference external" href="#function-naming-convention">Function Naming Convention</a>.</p>
<p>For “sources” and “target”: When there is no need to refer to the variable by its relative index, then <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> (itself an <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>) is sufficient, and index will be assumed to be 0 (if at all relevant).</p>
<p>In other cases, the variables will be referenced using the <code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code>, to indicate the return value of the function. There may also be cases where the sources can be a function, either built-in or user-defined. These two will be referenced using <code class="docutils literal notranslate"><span class="pre">&lt;function_source_reference&gt;</span></code> defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_source_reference</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span>
   <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span> <span class="p">]</span>
   <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;variable&quot;</span> <span class="o">|</span> <span class="s2">&quot;function&quot;</span>
</pre></div>
</div>
<div class="section" id="function-assign-body-literal">
<h4>Function assign body Literal<a class="headerlink" href="#function-assign-body-literal" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_literal_spec&gt;</span></code> asserts the assignment of a <code class="docutils literal notranslate"><span class="pre">&lt;literal_value&gt;</span></code> to the target variable. The <code class="docutils literal notranslate"><span class="pre">&lt;literal_value&gt;</span></code> has a data type (corresponding to one of our four domain types), and the value itself will be represented generically in a string (the string will be parsed to extract the actual value according to its data type).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_body_literal_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;literal&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">literal_value</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">literal_value</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;dtype&quot;</span> <span class="p">:</span> <span class="s2">&quot;real&quot;</span> <span class="o">|</span> <span class="s2">&quot;integer&quot;</span> <span class="o">|</span> <span class="s2">&quot;boolean&quot;</span> <span class="o">|</span> <span class="s2">&quot;string&quot;</span>
    <span class="s2">&quot;value&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-assign-body-lambda">
<h4>Function assign body Lambda<a class="headerlink" href="#function-assign-body-lambda" title="Permalink to this headline">¶</a></h4>
<p>When more computation is done to determine the value that is being assigned to the variable in the <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code></a>, then <code class="docutils literal notranslate"><span class="pre">&lt;function_assign_body_lambda_spec&gt;</span></code> is used.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_assign_body_lambda_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;lambda&quot;</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;reference&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">lambda_function_reference</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>FUTURE: Eventually, we can expand this part of the grammar to accommodate a restricted set of arithmetic operations involved in computing the final value (this is now of interest in the World Modelers program and we’re interested in supporting this in Delphi).</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code> references the source code function in the <code class="docutils literal notranslate"><span class="pre">lambdas.py</span></code> file that does the computation, in the translated Python generated by program analysis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">lambda_function_reference</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>NOTE: The <code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code>, which refers to the post-analysis lambdas function created by Program Analysis is <em>NOT</em> to be confused with a <a class="reference external" href="#grounding-and-source-code-reference"><code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code></a>, which refers to the original source code that was analyzed (i.e., the original Fortran source code).</p>
</div></blockquote>
<p>Any variables that are required as arguments to the lambda function must correspond to the “source” list of variables (<a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> references) in the <a class="reference external" href="#function-assign-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_assign_spec&gt;</span></code></a>.</p>
<p>As noted above, due to the more semantically rich identifier specification and <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> representation, it is not straightforward to use the <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a> as the python symbol in the translated Python generated by program analysis. Instead, function and variable identifiers will be represented in the generated Python using their <a class="reference external" href="#identifier-gensym">gensym</a>. For debugging and visualization purposes, the generated Python code may be displayed with <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>s (or some version that is closer to legal Python naming, although in general it does not appear to be possible to create “safe” Python names directly from <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code></a>s).</p>
</div>
</div>
<div class="section" id="function-container-specification">
<h3>Function Container Specification<a class="headerlink" href="#function-container-specification" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">&lt;function_container_spec&gt;</span></code> represents the grouping of a set of variables and how they are updated by functions. Generally the “function container” corresponds to functions (or subroutines) defined in source code. A “function container” is also defined for the “top” level of a source code file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_container_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;container&quot;</span>
    <span class="s2">&quot;DOCS&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;output&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>There will be a container function for each source code function. For this reason, we need an “input” variable list (of 0 or more variables) as well as an “output” variable. In Python, a function only returns a value if there is an explicit return expression. Otherwise it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The “body” is specified by a list of <a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a></p>
<p>Case 1: subroutine</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo1_subroutine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">foo2_subroutine</span><span class="p">():</span>
    <span class="n">Integer</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">foo1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">foo1</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>now z = 5 and w = 5</p>
<p>Case 2: fortran function with simple return</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">&lt;-</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">foo2</span><span class="p">():</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
</pre></div>
</div>
<p>Case 3: fortran function with return expression</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>becomes...</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
  <span class="n">foo_return1</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>

<span class="k">return</span> <span class="n">foo_return1</span>
</pre></div>
</div>
<p>Case 4: conditional return statements</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="c1">#fortran function</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="section" id="function-reference-specification">
<h3>Function Reference Specification<a class="headerlink" href="#function-reference-specification" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;function&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span> <span class="p">]</span>
    <span class="s2">&quot;output&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code> defines the “wiring” of functions, specifying associations of variables to function inputs (arguments) and the function output variable (FOR NOW: assuming all functions set zero or one variable state).</p>
</div>
<div class="section" id="function-loop-plate-specification">
<h3>Function Loop Plate Specification<a class="headerlink" href="#function-loop-plate-specification" title="Permalink to this headline">¶</a></h3>
<p>The concept behind a “loop plate” is a generalization of the <a class="reference external" href="https://en.wikipedia.org/wiki/Graphical_model">probabilistic graphical model</a> convention for <a class="reference external" href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a>, extended to represent dynamic processes (a specification of a sequence of state changes).</p>
<blockquote>
<div><p>TODO: Provide more background on the “loop plate” concept.</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">function_loop_plate</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;loop_plate&quot;</span>
    <span class="s2">&quot;input&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index_variable&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;index_iteration_range&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">index_range</span><span class="o">&gt;</span>
    <span class="s2">&quot;condition&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">loop_condition</span><span class="o">&gt;</span>
    <span class="s2">&quot;body&quot;</span> <span class="p">:</span> <span class="nb">list</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">function_reference_spec</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The “input” list of <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code></a> objects should list all variables that are set in the scope outside of the loop_plate.</p>
<p>The current loop_plate specification is aimed at handling for-loops. (assumes “index_variable” and “index_iteration_range” are specified)</p>
<blockquote>
<div><p>FUTURE: Generalize to do-while loop by just relying on the “condition” <code class="docutils literal notranslate"><span class="pre">&lt;loop_condition&gt;</span></code> to determine when loop completes. We can then remove “index_variable” and “index_iteration_range”. There will still need to be a mechanism for identifying index_variable(s).</p>
</div></blockquote>
<p>The “index_variable” is the named variable that stores the iteration state of the loop; the naming convention of this variable is described above, in the Variable naming convention section. The only new element introduced is the <code class="docutils literal notranslate"><span class="pre">&lt;index_range&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">index_range</span><span class="o">&gt;</span><span class="p">[</span><span class="n">attrval</span><span class="p">]</span> <span class="p">::</span><span class="o">=</span>
    <span class="s2">&quot;start&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
    <span class="s2">&quot;end&quot;</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_reference</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">variable_name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This definition permits loop iteration bounds to be specified either as literal integers, or as the values of variables.</p>
</div>
</div>
</div>
<div class="section" id="change-log">
<h1>Change Log<a class="headerlink" href="#change-log" title="Permalink to this headline">¶</a></h1>
<p>Inspired by <a class="reference external" href="https://keepachangelog.com">Keep a Changelog</a></p>
<p>This project does not (yet) adhere to <a class="reference external" href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a></p>
<div class="section" id="m9-2019-07-01">
<h2><code class="docutils literal notranslate"><span class="pre">[0.1.m9]</span></code> - 2019-07-01:<a class="headerlink" href="#m9-2019-07-01" title="Permalink to this headline">¶</a></h2>
<div class="section" id="added">
<h3>Added<a class="headerlink" href="#added" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>GrFN_spec Index with links for quick reference navigation.</p></li>
<li><p>Changelog, inspired by <a class="reference external" href="https://keepachangelog.com">Keep a Changelog</a>.</p></li>
<li><p><a class="reference external" href="#grounding-metadata-spec"><code class="docutils literal notranslate"><span class="pre">&lt;grounding_metadata_spec&gt;</span></code></a> in “grounding” field of <a class="reference external" href="#identifier-specification"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code></a>. Includes source, type (definition, units, constraints) and value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;system_def&gt;</span></code> for defining the GrFN representation of a system (collection of source files and multiple modules).</p></li>
</ul>
</div>
<div class="section" id="changed">
<h3>Changed<a class="headerlink" href="#changed" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Reorganized and rewrote portions of Introduction.</p></li>
<li><p>Modified <a class="reference external" href="#function-reference-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_reference_spec&gt;</span></code></a> so that it now has an “exit_condition” to represent while loops, and subsumes for/iteration loops.</p></li>
<li><p>Modified <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;varaible_spec&gt;</span></code></a> adding variable value “domain” constraints.</p></li>
</ul>
</div>
</div>
<div class="section" id="m5-2019-05-01">
<h2><code class="docutils literal notranslate"><span class="pre">[0.1.m5]</span></code> - 2019-05-01:<a class="headerlink" href="#m5-2019-05-01" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Added<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Added “mutable” attribute to <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>.</p></li>
<li><p>Added “variables” attribute to top-level <a class="reference external" href="#top-level-grfn-specification"><code class="docutils literal notranslate"><span class="pre">&lt;grfn_spec&gt;</span></code></a>, which contains the list of all <code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code>s. This change also means that <a class="reference external" href="#function-specification"><code class="docutils literal notranslate"><span class="pre">&lt;function_spec&gt;</span></code></a>s no longer house <a class="reference external" href="#variable-specification"><code class="docutils literal notranslate"><span class="pre">&lt;variable_spec&gt;</span></code></a>s, but instead just the <a class="reference external" href="#variable-naming-convention"><code class="docutils literal notranslate"><span class="pre">&lt;variable_names&gt;</span></code></a> (which themselves are <a class="reference external" href="#identifier-string"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>s</a>).</p></li>
<li><p>Added links to help topic navigation.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>Changed<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Clarified distinction between <a class="reference external" href="#grounding-and-source-code-reference"><code class="docutils literal notranslate"><span class="pre">&lt;source_code_reference&gt;</span></code></a>s (linking identifiers to where they are used in the analyzed source code) and <a class="reference external" href="#function-assign-body-lambda"><code class="docutils literal notranslate"><span class="pre">&lt;lambda_function_reference&gt;</span></code></a>s (which denote functions in the Program Analysis-generated lambdas file source code); previously these two concepts were ambiguous.</p></li>
</ul>
</div>
<div class="section" id="removed">
<h3>Removed<a class="headerlink" href="#removed" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Removed <a class="reference external" href="#identifier-specification"><code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code></a> “aliases” attribute. To be handled later as part of pointer/reference analysis.</p></li>
</ul>
</div>
</div>
<div class="section" id="m3-2019-03-01">
<h2><code class="docutils literal notranslate"><span class="pre">[0.1.m3]</span></code> - 2019-03-01:<a class="headerlink" href="#m3-2019-03-01" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>Added<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Addition of identifiers: <code class="docutils literal notranslate"><span class="pre">&lt;identifier_spec&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;identifier_string&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;gensym&gt;</span></code> (for identifiers in generated code)</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3>Changed<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Revision of Introduction</p></li>
<li><p>Updates to naming conventions for variables and functions</p></li>
<li><p>General cleanup of discussion throughout</p></li>
</ul>
</div>
</div>
<div class="section" id="releases">
<h2>Releases<a class="headerlink" href="#releases" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Unreleased: [development GrFN OpenAPI] <a class="reference external" href="https://github.com/ml4ai/delphi/blob/grfn/docs/grfn_spec">devlopment GrFN documentation</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m9_milestone_report/GrFN_specification_v0.1.m9">0.1.m9</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m5_final_phase1_report/GrFN_specification_v0.1.m5">0.1.m5</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m3_report_prototype_system/GrFN_specification_v0.1.m3">0.1.m3</a></p></li>
<li><p><a class="reference external" href="https://github.com/ml4ai/automates/blob/master/documentation/deliverable_reports/m1_architecture_report/GrFN_specification_v0.1">0.1.m1</a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="delphi_database.html" class="btn btn-neutral float-right" title="The Delphi Database" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="generated/delphi.GrFN.networks.ForwardInfluenceBlanket.run.html" class="btn btn-neutral float-left" title="delphi.GrFN.networks.ForwardInfluenceBlanket.run" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Adarsh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>