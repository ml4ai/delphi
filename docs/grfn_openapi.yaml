openapi: 3.0.0

info:
  title: GrFN Spec
  description: Grounded Function Network (GrFN) Specification
  contact:
    name: Clayton T. Morrison
    email: claytonm@email.arizona.edu
  license:
    name: Apache 2.0
    url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
  version: 0.2.1

paths: {}

components:

  schemas:

    system_def:
      title: <system_def>
      description: >
        Specification of a GrFN system consisting of one or
        more GrFN_spec files.
        With imports, the system must represent a DAG.
      required:
        - date_created
        - name
        - components
      properties:
        date_created:
          type: string
          format: date-time
        name:
          type: string
        components:
          type: array
          items:
            $ref: '#/components/schemas/grfn_spec_ref'

    grfn_spec_ref:
      title: <grfn_spec_ref>
      description: >
        Specifies a GrFN_spec file that is part of a GrFN system.
        imports (optional) specifies list of any GrFN_spec files
        that need to also be loaded.
      required:
        - name
      properties:
        name:
          $ref: '#/components/schemas/namespace_path_string'
        imports:
          type: array
          items:
            $ref: '#/components/schemas/namespace_path_string'

    grfn_spec:
      title: <grfn_spec>
      description: >
        The top-level structure of the GrFN specification.


        The `date_created` attribute is a string representing the
        date and time that the current GrFN was generated (this
        helps resolve what versionn of Program Analysis was used.)
        There may be a single GrFN spec file for multiple source
        code files.


        The `source` attribute is a list of one or more
        source_code_file_paths.


        The `start` attribute is a list of function names (as function
        identifier strings) that represent entry points into the
        program.
      required:
        - date_created
        - source
        - identifiers
        - variables
        - functions
      properties:
        date_created:
          type: string
          format: date-time
        source:
          type: array
          items:
            $ref: '#components/schemas/source_code_file_path'
        start:
          type: array
          items:
            type: string
        identifiers:
          type: array
          items:
            $ref: '#components/schemas/identifier_spec'
        types:
          type: array
          items:
            $ref: '#components/schemas/type_spec'
        variables:
          type: array
          items:
            $ref: '#components/schemas/variable_spec'
        functions:
          type: array
          items:
            oneOf:
              - $ref: '#components/schemas/function_assign_spec'
              - $ref: '#components/schemas/function_container_spec'

    identifier_spec:
      title: <identifier_spec>
      description: >
        Each identifier within a GrFN specification will have a single
        <identifier_spec> declaration. An identifier is decalred in the
        GrFN spec.
      required:
        - base_name
        - scope
        - namespace
        - source_references
        - gensym
      properties:
        base_name:
          $ref: '#/components/schemas/base_name'
        scope:
          $ref: '#/components/schemas/scope_path'
        namespace:
          $ref: '#/components/schemas/namespace_path'
        source_references:
          type: array
          items:
            $ref: '#components/schemas/source_code_reference'
        gensym:
          $ref: '#components/schemas/gensym'
        grounding:
          type: array
          items:
            $ref: '#components/schemas/grounding_metadata_spec'

    base_name:
      title: <base_name>
      description:
        The name corresponding (when available) to the identifier
        token name as it appears in the source language (e.g., Fortran).
        The base_name follows the conventions of
        [python identifier specifiation rules](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)
        (which includes Fortran naming syntax).
      type: string

    scope_path:
      title: <scope_path>
      description: >
        Program analysis will assign a unique name to each scope.
        For example, given these unique names, the scopes of two
        inner loops within the outputer loop  of function `foo`
        in the following example

        ```
        def foo():
          for i in range(10):    # assigned name 'loop$1'
            for j in range(10):  # assigned name 'loop$1'
                                 #  (in the scope of outer loop$1)
              x = i * j
            for k in range(10):  # assigned name 'loop$2'
              z = x + 1          #  (in the scope of outer loop$2)
        ```

        ... would be uniquely specified by the following paths
        (respectively)

        ```
            ["foo", "loop$1", "loop$1"]
            ["foo", "loop$1", "loop$2"]
        ```

        The "top" level of the file (i.e., not enclosed within another
        program block context) will be assigned the default empty string
        scope, "".  All other scopes are either explicitly named
        (such as a named function), or are assigned a unique name by
        program anlysis according to the rules of the type of scope
        (such as container, loop, conditional, etc.).
      type: array
      items:
        type: string

    scope_path_string:
      title: <scope_path_string>
      description: >
        A single string representation of a `<scope_path>`.
        String names that make up components of the path are
        expressed in order, separated by periods.
      example:
        '"foo.loop$1.loop$2"'
      type: string

    namespace_path:
      title: <namespace_path>
      description: >
        Different languages have different conventions for defining
        namespaces, but in general they are either

        1. explicitly defined within source code by namespace
        declarations (such as Fortran "modules" or C++ "namespaces"s), or

        2. implicitly defined by the project directory structure


        within which the file is located (as in Python).


        In the case of namespaces defined by the project directory
        structure, two files in different locations in the project
        directory tree may have the same name. To distinguish these,
        program anlaysis will capture the path of the directory tree
        from the root to the file. The final name in the path, which
        is the name of the source file, will drop the extension.
        For example, the namespace for the file `baz.py` within the
        following directory tree


        ```

        foo/
            bar/
                baz.py
        ```

        would be uniquely specified by the following path


        ```
        ["foo", "bar", "baz"]
        ```


        In the case of declared namespaces, the namespace declaration
        will determine the path (which may only consist of one string
        name).
        It is not necessary within GrFN to independently declare a
        namespace; like the `<scope_path>`, we specify the
        `<namespace_path>` within an identifier declaration as a list
        of strings under teh "namespace" attribute in the identifier
        declaration.
        Like the `<scope_path>`, the string names of the path uniquely
        defining the namespace are in in order from general to specific,
        with the last string name either being the implicit namespace
        defined by the source code file, or the user-defined name of
        the namespace.
      type: array
      items:
        type: string

    namespace_path_string:
      title: <namespace_path_string>
      description: >
        A single string representation of a `<namespace_path>`.
        String names that make up components of the path are
        expressed in order, separated by periods.
      example:
        '"foo.bar.baz"'
      type: string

    gensym:
      title: <gensym>
      description: >
        One of the outputs of program analysis is a functionally
        equivalent version of the origianl source code and lambda
        functions, both expressed in Python (as the intermediate
        target language).


        All identifiers in the output Python must match identifiers
        in GrFN.


        Since capturing the semantics (particularly the namespace
        and scope context) results in a representation that is not
        guaranteed to be consistently expressible in legal Ptyhon
        symbol names, we will use `gensym`s that can be  represented
        (generally more compactly) as legal Python names and
        associated uniquely with identifiers.


        In the GrFN_spec, gensyms are represented as strings.
      type: string

    grounding_metadata_spec:
      title: <grounding_metadata_spec>
      description: >
        Text Reading currently extracts three types of information
        that can be associated with identifiers:

        1. Definitions (e.g., 'wind speed', 'susceptible individuals')

        2. Units (e.g., 'millimeters', 'per capita')

        3. Constraints (e.g., '> 0', '<= 100')


        The `type` of a grounding_metadata_spec indicates whether
        it is a 'definition', 'units', or 'constraint'.
        The `source` is a string representing the source of the
        grounding/linking information.
        The `value` is a string representing the value of the
        grounding type.
      required:
        - source
        - types
        - value
      properties:
        source:
          type: string
        type:
          type: string
          enum:
            - definition
            - units
            - constraint
        value:
          type: string

    identifier_string:
      title: <identifer_string>
      description: >
        `<identifier_string>`:
        Identifiers are uniquely defined by their `<base_name>`,
        `<scope_path>` and `<namespace_path>`. It will be convenient
        to refer unambiguously to any identifier using a single
        string, outside of the `<identifier_spec>` delcaration.


        An `<identifer_string>` is a string that combines the
        the `<type>` (either "")
        `<namespace_string>`, `<scope_path_string>` and `<base_name>`
        by double-colons.


        ```
        "<type>::<namespace_path_string>::<scope_path_string>::<base_name>[::<index>]"
        ```


        The fourth element, `<index>`, is only used by variables
        (representing the variable SSA (single static assignment)
        index); functions never have an `<index>`. Therefore, we
        always know, unambiguously, whether we're referring to
        a variable or a function.
      type: string

    variable_name:
      title: <variable_name>
      description: >
        ```
        "<namespace_path_string>::<scope_path_string>::<base_name>::<index>"
        ```


        TODO: url for details and examples
      type: string

    function_name:
      title: <function_name>
      description: >
        ```
        "<namespace_path_string>::<scope_path_string>::<base_name>"
        ```


        where:


        ```
        <base_name> ::= <function_type>[$[<var_affected>|<code_given_name>]]
        ```


        TODO: url for details and examples
      type: string

    type_name:
      title: <type_name>
      description: >
        Denotes a user-defined type; will have a corresponding unique
        `<type_spec>`:


        ```
        "<namespace_path_string>::<scope_path_string>::<base_name>::TYPE"
        ```
      type: string

    type_spec:
      title: <type_spec>
      description: >
        User-defined type
      required:
        - name
        - type
      properties:
        name:
          $ref: '#components/schemas/type_name'
        type:
          type: string
          enum:
            - "type"

    variable_spec:
      title: <variable_spec>
      description: >
        `domain_constraints` is a string representing a disjunctive
        normal form representation with v = variable value


        ```
        "(or (and (< v infty) (>= v 5)) (and (> v -infty) (< v 0)))"
        ```
      required:
        - name
        - index
        - domain
        - mutable
      properties:
        name:
          $ref: '#components/schemas/variable_name'
        index:
          type: integer
        domain:
           $ref: '#components/schemas/type'
        domain_constraints:
          type: string
        mutable:
          type: string
          enum:
            - true
            - false
          default: true

    variable_domain_type:
      title: <variable_domain_type>
      description: >
        The variable domain `type` has a `<type_name>`, which itself
        could be a primitive data type or user-defined type.


        Precision is an optional string representing the precision
        of a primitive data type.
      required:
        - type
      properties:
        type:
          $ref: '#components/schemas/type_name'
        precision:
          type: string

    function_assign_spec:
      title: <function_assign_spec>
      description: >
        A `<function_assign_spec>` denotes the setting of the
        value of a varaible. The values are assigned to the
        "return_value" variable (denoted by a `<variable_name>`) and
        the value is determined by the lambda function denoted by
        the "lambda_source".


        The identifier conventions for assign, condition and decision
        are described in TODO.
      required:
        - name
        - type
        - arguments
        - return_value
      properties:
        type:
          type: string
          enum:
            - assign
            - condition
            - decision
        lambda_source:
          $ref: '#components/schemas/lambda_function_source_reference'
        arguments:
          type: array
          items:
            oneOf:
              - $ref: '#components/schemas/variable_name'
              - $ref: '#components/schemas/function_name'
        return_value:
          $ref: '#components/schemas/variable_name'

    function_container_spec:
      title: <function_container_spec>
      description: >
        "updated" represents varaibles that have been assigned (updated)
        during the execution of the container body.
        "return_value" represents an explicit assignment to a variable
        on exit of the coontainer body.
      required:
        - name
        - type
        - arguments
        - updated
        - return_value
        - body
      properties:
        name:
          $ref: '#components/schemas/function_name'
        type:
          type: string
          enum:
            - container
            - loop
        arguments:
          type: array
          items:
            oneOf:
              - $ref: '#components/schemas/variable_name'
              - $ref: '#components/schemas/function_name'
        updated:
          type: array
          items:
            $ref: '#components/schemas/variable_name'
        return_value:
          $ref: '#components/schemas/variable_name'
        body:
          type: array
          items:
            $ref: '#components/schemas/function_wiring_spec'

    function_wiring_spec:
      title: <function_wiring_spec>
      description: >
        Defines the "wiring" of container or assignment functions,
        specifying associations
        of variables to function arguments ("input") and the
        function return_value ("output").
      required:
        - function
        - input
        - output
      properties:
        function:
          $ref: '#components/schemas/function_reference'
        input:
          type: array
          items:
            oneOf:
              - $ref: '#components/schemas/variable_name'
              - $ref: '#components/schemas/function_name'
        output:
          $ref: '#components/schemas/variable_name'

    function_reference:
      title: <function_reference>
      description:
        A `<function_reference>` is either a

        1. `<function_name>` denoting a function specification (generally
        an another container function).

        2. `<lambda_function_source_reference>` denoting an executable
        lambda function.


        "type" is a convenience indicating whether the "function" is a
        `<function_name>` or `<lambda_function_source_reference>` without
        having to parse the string.
      required:
        - function
        - type
      properties:
        function:
          oneOf:
            - $ref: '#components/schemas/function_name'
            - $ref: '#components/schemas/lambda_function_source_reference'
        type:
          type: string
          enum:
            - function_name
            - lambda_source

    lambda_function_source_reference:
      title: <lambda_function_source_reference>
      description:
        A string representation of a path/reference to a function
        in `lambda.py` that performs the computation (implemented
        in Python and generated by Program Analysis).
      type: string

    source_code_reference:
      title: <source_code_reference>
      description: >
        String containing information to indicate the location
        within the source code where an identifier was used.
      type: string

    source_code_file_path:
      title: <source_code_file_path>
      description: >
        String path to source file, using system root as the
        root, and including the file extension.
      type: string

    type:
      title: <type>
      oneOf:
        - $ref: '#components/schemas/type_type_spec'
        - $ref: '#components/schemas/type_integer'
        - $ref: '#components/schemas/type_float'
        - $ref: '#components/schemas/type_boolean'
        - $ref: '#components/schemas/type_string'
        - $ref: '#components/schemas/type_array'
        - $ref: '#components/schemas/type_list'
        - $ref: '#components/schemas/type_map'
        - $ref: '#components/schemas/type_tuple'

    type_type_spec:
      title: <type_type_spec>
      description:
        Indicator of a user-defined type_spec.
        "name" is a `<type_name>` that identifies the `<type_spec>`.
      required:
        - name
        - type
      properties:
        name:
          $ref: '#components/schemas/type_name'
        type:
          type: string
          enum:
            - "type"

    type_integer:
      title: <type_integer>
      description: >
        Primitive scalar integer
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "integer"
        type:
          type: string
          enum:
            - "type"

    type_float:
      title: <type_float>
      description: >
        Primitive scalar float
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "float"
        type:
          type: string
          enum:
            - "type"

    type_boolean:
      title: <type_boolean>
      description: >
        Primitive scalar boolean
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "boolean"
        type:
          type: string
          enum:
            - "type"

    type_string:
      title: <type_string>
      description: >
        Primitive scalar string
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "string"
        type:
          type: string
          enum:
            - "type"

    type_array:
      title: <type_array>
      description: >
        Array primitive type.
        TODO: the dimensions integers can only be positive;
            need to add constraint
        The "element_type" specifies the `<type>` of the elements
        in the array.
      required:
        - name
        - type
        - dimensions
        - element_type
      properties:
        name:
          type: string
          enum:
            - "array"
        type:
          type: string
          enum:
            - "type"
        dimensions:
          type: array
          items:
            type: integer
        element_type:
           $ref: '#components/schemas/type'

    type_list:
      title: <type_list>
      description:
        List primitive type.
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "list"
        type:
          type: string
          enum:
            - "type"

    type_map:
      title: <type_map>
      description:
        Map primitive type.
      required:
        - name
        - type
      properties:
        name:
          type: string
          enum:
            - "map"
        type:
          type: string
          enum:
            - "type"

    type_tuple:
      title: <type_tuple>
      description:
        Tuple primitive type.
        "element_types" is an array of the `<types>` of each element of the tuple.
        The order of `<types>` corresponds to the order of elements in the
        tuple.
      required:
        - name
        - type
        - element_types
      properties:
        name:
          type: string
          enum:
            - "tuple"
        type:
          type: string
          enum:
            - "type"
        element_types:
          type: array
          items:
            $ref: '#components/schemas/type'

externalDocs:
  description: Find more information here
  url: 'https://ml4ai.github.io/delphi/grfn_spec.html'
