
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro:300,600|Titillium+Web:400,600,700" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="_static/swagger-ui/swagger-ui.css" >
  <style>
    html
    {
      box-sizing: border-box;
      overflow: -moz-scrollbars-vertical;
      overflow-y: scroll;
    }
    *,
    *:before,
    *:after
    {
      box-sizing: inherit;
    }

    body {
      margin:0;
      background: #fafafa;
    }
  </style>

<div id="swagger-ui"></div>
<script src="_static/swagger-ui/swagger-ui-bundle.js"> </script>
<script src="_static/swagger-ui/swagger-ui-standalone-preset.js"> </script>
<script>
    window.onload = function() {

    var spec = {"openapi": "3.0.0", "info": {"title": "GrFN Spec", "description": "Grounded Function Network (GrFN) Specification", "contact": {"name": "Clayton T. Morrison", "email": "claytonm@email.arizona.edu"}, "license": {"name": "Apache 2.0", "url": "http://www.apache.org/licenses/LICENSE-2.0.html"}, "version": "0.2.0"}, "paths": {}, "components": {"schemas": {"system_def": {"title": "<system_def>", "description": "Specification of a GrFN system consisting of one or more GrFN_spec files. With imports, the system must represent a DAG.\n", "required": ["date_created", "name", "components"], "properties": {"date_created": {"type": "string", "format": "date-time"}, "name": {"type": "string"}, "components": {"type": "array", "items": {"$ref": "#/components/schemas/grfn_spec_ref"}}}}, "grfn_spec_ref": {"title": "<grfn_spec_ref>", "description": "Specifies a GrFN_spec file that is part of a GrFN system. imports (optional) specifies list of any GrFN_spec files that need to also be loaded.\n", "required": ["name"], "properties": {"name": {"$ref": "#/components/schemas/namespace_path_string"}, "imports": {"type": "array", "items": {"$ref": "#/components/schemas/namespace_path_string"}}}}, "grfn_spec": {"title": "<grfn_spec>", "description": "The top-level structure of the GrFN specification.\n\nThe `date_created` attribute is a string representing the date and time that the current GrFN was generated (this helps resolve what versionn of Program Analysis was used.) There may be a single GrFN spec file for multiple source code files.\n\nThe `source` attribute is a list of one or more source_code_file_paths.\n\nThe `start` attribute is a list of function names (as function identifier strings) that represent entry points into the program.\n", "required": ["date_created", "source", "identifiers", "variables", "functions"], "properties": {"date_created": {"type": "string", "format": "date-time"}, "source": {"type": "array", "items": {"$ref": "#components/schemas/source_code_file_path"}}, "start": {"type": "array", "items": {"type": "string"}}, "identifiers": {"type": "array", "items": {"$ref": "#components/schemas/identifier_spec"}}, "types": {"type": "array", "items": {"$ref": "#components/schemas/type_spec"}}, "variables": {"type": "array", "items": {"$ref": "#components/schemas/variable_spec"}}, "functions": {"type": "array", "items": {"oneOf": [{"$ref": "#components/schemas/function_assign_spec"}, {"$ref": "#components/schemas/function_container_spec"}]}}}}, "identifier_spec": {"title": "<identifier_spec>", "description": "Each identifier within a GrFN specification will have a single <identifier_spec> declaration. An identifier is decalred in the GrFN spec.\n", "required": ["base_name", "scope", "namespace", "source_references", "gensym"], "properties": {"base_name": {"$ref": "#/components/schemas/base_name"}, "scope": {"$ref": "#/components/schemas/scope_path"}, "namespace": {"$ref": "#/components/schemas/namespace_path"}, "source_references": {"type": "array", "items": {"$ref": "#components/schemas/source_code_reference"}}, "gensym": {"$ref": "#components/schemas/gensym"}, "grounding": {"type": "array", "items": {"$ref": "#components/schemas/grounding_metadata_spec"}}}}, "base_name": {"title": "<base_name>", "description": "The name corresponding (when available) to the identifier token name as it appears in the source language (e.g., Fortran). The base_name follows the conventions of [python identifier specifiation rules](https://docs.python.org/3/reference/lexical_analysis.html#identifiers) (which includes Fortran naming syntax).", "type": "string"}, "scope_path": {"title": "<scope_path>", "description": "Program analysis will assign a unique name to each scope. For example, given these unique names, the scopes of two inner loops within the outputer loop  of function `foo` in the following example\n``` def foo():\n  for i in range(10):    # assigned name 'loop$1'\n    for j in range(10):  # assigned name 'loop$1'\n                         #  (in the scope of outer loop$1)\n      x = i * j\n    for k in range(10):  # assigned name 'loop$2'\n      z = x + 1          #  (in the scope of outer loop$2)\n```\n... would be uniquely specified by the following paths (respectively)\n```\n    [\"foo\", \"loop$1\", \"loop$1\"]\n    [\"foo\", \"loop$1\", \"loop$2\"]\n```\nThe \"top\" level of the file (i.e., not enclosed within another program block context) will be assigned the default empty string scope, \"\".  All other scopes are either explicitly named (such as a named function), or are assigned a unique name by program anlysis according to the rules of the type of scope (such as container, loop, conditional, etc.).\n", "type": "array", "items": {"type": "string"}}, "scope_path_string": {"title": "<scope_path_string>", "description": "A single string representation of a `<scope_path>`. String names that make up components of the path are expressed in order, separated by periods.\n", "example": "\"foo.loop$1.loop$2\"", "type": "string"}, "namespace_path": {"title": "<namespace_path>", "description": "Different languages have different conventions for defining namespaces, but in general they are either\n1. explicitly defined within source code by namespace declarations (such as Fortran \"modules\" or C++ \"namespaces\"s), or\n2. implicitly defined by the project directory structure\n\nwithin which the file is located (as in Python).\n\nIn the case of namespaces defined by the project directory structure, two files in different locations in the project directory tree may have the same name. To distinguish these, program anlaysis will capture the path of the directory tree from the root to the file. The final name in the path, which is the name of the source file, will drop the extension. For example, the namespace for the file `baz.py` within the following directory tree\n\n```\nfoo/\n    bar/\n        baz.py\n```\nwould be uniquely specified by the following path\n\n``` [\"foo\", \"bar\", \"baz\"] ```\n\nIn the case of declared namespaces, the namespace declaration will determine the path (which may only consist of one string name). It is not necessary within GrFN to independently declare a namespace; like the `<scope_path>`, we specify the `<namespace_path>` within an identifier declaration as a list of strings under teh \"namespace\" attribute in the identifier declaration. Like the `<scope_path>`, the string names of the path uniquely defining the namespace are in in order from general to specific, with the last string name either being the implicit namespace defined by the source code file, or the user-defined name of the namespace.\n", "type": "array", "items": {"type": "string"}}, "namespace_path_string": {"title": "<namespace_path_string>", "description": "A single string representation of a `<namespace_path>`. String names that make up components of the path are expressed in order, separated by periods.\n", "example": "\"foo.bar.baz\"", "type": "string"}, "gensym": {"title": "<gensym>", "description": "One of the outputs of program analysis is a functionally equivalent version of the origianl source code and lambda functions, both expressed in Python (as the intermediate target language).\n\nAll identifiers in the output Python must match identifiers in GrFN.\n\nSince capturing the semantics (particularly the namespace and scope context) results in a representation that is not guaranteed to be consistently expressible in legal Ptyhon symbol names, we will use `gensym`s that can be  represented (generally more compactly) as legal Python names and associated uniquely with identifiers.\n\nIn the GrFN_spec, gensyms are represented as strings.\n", "type": "string"}, "grounding_metadata_spec": {"title": "<grounding_metadata_spec>", "description": "Text Reading currently extracts three types of information that can be associated with identifiers:\n1. Definitions (e.g., 'wind speed', 'susceptible individuals')\n2. Units (e.g., 'millimeters', 'per capita')\n3. Constraints (e.g., '> 0', '<= 100')\n\nThe `type` of a grounding_metadata_spec indicates whether it is a 'definition', 'units', or 'constraint'. The `source` is a string representing the source of the grounding/linking information. The `value` is a string representing the value of the grounding type.\n", "required": ["source", "types", "value"], "properties": {"source": {"type": "string"}, "type": {"type": "string", "enum": ["definition", "units", "constraint"]}, "value": {"type": "string"}}}, "identifier_string": {"title": "<identifer_string>", "description": "`<identifier_string>`: Identifiers are uniquely defined by their `<base_name>`, `<scope_path>` and `<namespace_path>`. It will be convenient to refer unambiguously to any identifier using a single string, outside of the `<identifier_spec>` delcaration.\n\nAn `<identifer_string>` is a string that combines the the `<type>` (either \"\") `<namespace_string>`, `<scope_path_string>` and `<base_name>` by double-colons.\n\n``` \"<type>::<namespace_path_string>::<scope_path_string>::<base_name>[::<index>]\" ```\n\nThe fourth element, `<index>`, is only used by variables (representing the variable SSA (single static assignment) index); functions never have an `<index>`. Therefore, we always know, unambiguously, whether we're referring to a variable or a function.\n", "type": "string"}, "variable_name": {"title": "<variable_name>", "description": "``` \"<namespace_path_string>::<scope_path_string>::<base_name>::<index>\" ```\n\nTODO: url for details and examples\n", "type": "string"}, "function_name": {"title": "<function_name>", "description": "``` \"<namespace_path_string>::<scope_path_string>::<base_name>\" ```\n\nwhere:\n\n``` <base_name> ::= <function_type>[$[<var_affected>|<code_given_name>]] ```\n\nTODO: url for details and examples\n", "type": "string"}, "type_name": {"title": "<type_name>", "description": "*User-defined types* (the only type names that show up in `<type_spec>`) are named with this format:\n\n``` \"<namespace_path_string>::<scope_path_string>::<base_name>::TYPE\" ```\n\n*Primitive data types* have no namespace or scope, so are just simple strings with the format: \"<primitive_type_name>\", which consist of one of the following:\n\nBuilt-in primitive scalar types: \"real\", \"integer\", \"boolean\", \"string\"\n\nBuild-in primitive structured types: \"array\", \"list\", \"map\"\n", "type": "string"}, "type_spec": {"title": "<type_spec>", "description": "User-defined type\n", "required": ["name"], "properties": {"name": {"$ref": "#components/schemas/type_name"}}}, "type_array": {"title": "<type_array>", "description": "Array primitive type.", "required": ["name", "dimensions"], "properties": {"name": {"type": "string", "enum": ["array"]}, "dimensions": {"type": "array", "items": {"type": "integer"}}}}, "type_list": {"title": "<type_list>", "description": "List primitive type.", "required": ["name"], "properties": {"name": {"type": "string", "enum": ["list"]}}}, "type_map": {"title": "<type_map>", "description": "Map primitive type.", "required": ["name"], "properties": {"name": {"type": "string", "enum": ["map"]}}}, "variable_spec": {"title": "<variable_spec>", "description": "`domain_constraints` is a string representing a disjunctive normal form representation with v = variable value\n\n``` \"(or (and (< v infty) (>= v 5)) (and (> v -infty) (< v 0)))\" ```\n", "required": ["name", "index", "domain", "mutable"], "properties": {"name": {"$ref": "#components/schemas/variable_name"}, "index": {"type": "integer"}, "domain": {"$ref": "#components/schemas/variable_domain_type"}, "domain_constraints": {"type": "string"}, "mutable": {"type": "string", "enum": [true, false], "default": true}}}, "variable_domain_type": {"title": "<variable_domain_type>", "description": "The variable domain `type` has a `<type_name>`, which itself could be a primitive data type or user-defined type.\n\nPrecision is an optional string representing the precision of a primitive data type.\n", "required": ["type"], "properties": {"type": {"$ref": "#components/schemas/type_name"}, "precision": {"type": "string"}}}, "function_assign_spec": {"title": "<function_assign_spec>", "description": "A `<function_assign_spec>` denotes the setting of the value of a varaible. The values are assigned to the \"return_value\" variable (denoted by a `<variable_name>`) and the value is determined by the \"body\" of the assignment function, which itself may either be a literal value (specified by a `<function_assign_body_literal_spec>`) or a lambda function (specified by a `<function_assign_body_literal_lambda_spec>`).\n\nThe identifier conventions for assign, condition and decision are described in TODO.\n", "required": ["name", "type", "arguments", "return_value", "body"], "properties": {"name": {"$ref": "#components/schemas/function_name"}, "type": {"type": "string", "enum": ["assign", "condition", "decision"]}, "arguments": {"type": "array", "items": {"oneOf": [{"$ref": "#components/schemas/variable_name"}, {"$ref": "#components/schemas/function_name"}]}}, "return_value": {"$ref": "#components/schemas/variable_name"}, "body": {"oneOf": [{"$ref": "#components/schemas/function_assign_body_literal_spec"}, {"$ref": "#components/schemas/function_assign_body_lambda_spec"}]}}}, "function_assign_body_literal_spec": {"title": "<function_assign_body_literal_spec>", "description": "Asserts the assignment of a `<literal_value>` to the target variable.\n", "required": ["type", "value"], "properties": {"type": {"type": "string", "enum": ["literal"]}, "value": {"$ref": "#components/schemas/literal_value"}}}, "literal_value": {"title": "<literal_value>", "description": "A `<literal_value>` has a data type (corresponding to one of our four domain types), and the value itself will be represented generically in a string (the string will be parsed to extract the actual value according to its data type).\n", "required": ["dtype", "value"], "properties": {"dtype": {"type": "string", "enum": ["real", "integer", "boolean", "string"]}, "value": {"type": "string"}}}, "function_assign_body_lambda_spec": {"title": "<function_assign_body_lambda_spec>", "description": "Any variables that are required as arguments to the lambda function must correspond to the \"source\" to the original source code that was analyzed (i.e., the origianl Fortran source code).\n", "required": ["type", "name", "reference"], "properties": {"type": {"type": "string", "enum": ["lambda"]}, "name": {"$ref": "#components/schemas/function_name"}, "reference": {"$ref": "#components/schemas/lambda_function_reference"}}}, "lambda_function_reference": {"title": "<lambda_function_reference>", "description": "A string representation of a path/reference to a function in `lambda.py` that performs the computation (implemented in Python and generated by Program Analysis)."}, "function_container_spec": {"title": "<function_container_spec>", "description": "\"updated\" represents varaibles that have been assigned (updated) during the execution of the container body. \"return_value\" represents an explicit assignment to a variable on exit of the coontainer body.\n", "required": ["name", "type", "arguments", "updated", "return_value", "body"], "properties": {"name": {"$ref": "#components/schemas/function_name"}, "type": {"type": "string", "enum": ["container", "loop"]}, "arguments": {"type": "array", "items": {"oneOf": [{"$ref": "#components/schemas/variable_name"}, {"$ref": "#components/schemas/function_name"}]}}, "updated": {"type": "array", "items": {"$ref": "#components/schemas/variable_name"}}, "return_value": {"$ref": "#components/schemas/variable_name"}, "body": {"$ref": "#components/schemas/function_reference_spec"}}}, "function_reference_spec": {"title": "<function_reference_spec>", "description": "Defines the \"wiring\" of functions, specifying associations of variables to function arguments (\"input\") and the function return_value (\"output\").\n", "required": ["function", "input", "output"], "properties": {"function": {"$ref": "#components/schemas/function_name"}, "input": {"type": "array", "items": {"$ref": "#components/schemas/variable_name"}}, "output": {"$ref": "#components/schemas/variable_name"}}}, "source_code_reference": {"title": "<source_code_reference>", "description": "String containing information to indicate the location within the source code where an identifier was used.\n", "type": "string"}, "source_code_file_path": {"title": "<source_code_file_path>", "description": "String path to source file, using system root as the root, and including the file extension.\n", "type": "string"}}}, "externalDocs": {"description": "Find more information here", "url": "https://ml4ai.github.io/delphi/grfn_spec.html"}};

    // Build a system
    const ui = SwaggerUIBundle({
        spec: spec,
        dom_id: '#swagger-ui',
        deepLinking: true,
        presets: [
        SwaggerUIBundle.presets.apis,
        SwaggerUIStandalonePreset
        ],
        plugins: [
        SwaggerUIBundle.plugins.DownloadUrl
        ],
        layout: "StandaloneLayout"
    })

    window.ui = ui
    }
</script>
